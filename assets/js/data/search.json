[ { "title": "[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 3", "url": "/posts/2022/04/17/01/58/skeleton3/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-04-17 01:58:28 +0900", "snippet": "intro 파트 1,2에서는 Assimp 라이브러리를 사용하여 골격 정보를 로드하는 법을 다루었고, 각 정점이 가중치와 함께 정점에 영향을 미치는 본에 대응하는 법을 다루었다. 이 파트에서는 스켈레톤 애니메이션 기법의 핵심인 행렬 변환에 대해 다룬다. blender에서는 애니메이션을 생성할 때 key-frames에 있는 본의 위치와 각도를 조절하는 키 프레임을 사용한다. 모든 정점들의 위치를 저장하여, 각 프레임마다 해당하는 위치에 정점들을 배치하는 것은 비효율적임.(vertex buffer 등에 문제) How Assimp manages the animation aiNodeAnim positionKey, scaleKey, rotationKey 의 정보들을 가지고 있음. 이 변환 정보를 가지고 행렬을 만들어야함. 그리고 이 행렬을 모델에 적용하여 모델을 움직인다. 하지만 이는 단순하지 않다. parent bone의 움직임이 child bone 에 영향을 주게해야한다. Bone Coordinate System 이처럼 계층구조로 움직이게 하려면 새로운 좌표시스템을 도입해야함.(bone space, bone coordinate) 원점은 본의 기저부분(the base of the bone) (blender에서 amature -&amp;gt; viewport display에서 볼 수 있음) 뼈 자체는 y축을 가리킴 x축과 z축은 y축에 수직에 수직이고 서로 수직임 일반적으로 메쉬의 정점은 로컬 좌표계를 참조함 로컬 좌표계와 본 좌표계의 관계를 알아야함.The bone hierarchy 본 계층구조는 아래와 같다. 리깅할 때 보통 모델의 일부 본을 루트로 지정한다. 나머지 본들은 이 루트에서 나누어진 자식 또는 손자 보통 척추를 루트로 사용한다. 척추에서 사지로 뻗어나감. 루트의 본 공간은 로컬 공간을 참조함. 로컬 공간은 기본적인 좌표 시스템이라 생각할 수 있음 (원점이 {0,0,0}인, 축이 {1,0,0}, {0,1,0}, {0,0,1}) 여기서 루트 본의 기저부는 로컬 공간에서 일반적인 정점과 동일하며, 루트본의 축은 벡터가 된다. 아래는 로컬에서 (1, 1)에 위치한 루트 공간 루트의 자식의 본 공간은 로컬이 아니라 루트를 참조하게 된다. 아래는 루트에서 (1,1)에 위치한 자식 공간 즉, 실제 좌표(로컬에서 볼 때)는 (2, 2) 이렇게 각 본 공간은 부모를 참조한다.Chain of transformation 부모를 참조하는 본 공간을 정의함으로써 우리는 이제 변환 체인을 만들 수 있다. 체인은 각 본에서 루트로 흘러감 한 노드에서 (new T0) 변환에 변화가 생기면 모든 하위 개체에 영향을 주지만, 상위 개체에는 영향을 미치지 않음. 흔한 예제로 태양계 예제가 있다. (태양 - 지구 - 달 / 공전) 달의 위치가 지구를 기준으로 봤을 때 (x, y, z)라면 태양을 기준으로 봤을 때는 T0 * (x, y, z) 은하를 기준으로 보면 T1 * T0 * (x, y, z) Starting the transformation 스켈레톤 애니메이션은 바인딩 포즈에서 로컬에 있는 정점의 위치를 본 좌표계로 변환함으로써 시작한다.(아래 이미지는 평소와 같이 제공되는 정점의 위치) 영향을 미치는 본의 좌표계로 변환하는 것으로 시작 Bone1 을 참조 Bone2 를 참조 부모에서부터 계층구조의 루트까지 적용하면, 다시 로컬 공간으로 오게됨 이 로컬공간에서 월드 공간, 그리고 뷰 공간으로 변환되어 화면에 나타남. 그리고 Assimp에는 global_inverse transform 이라는 것이 있는데 이는 나중에 다룰 것임. (글로벌 역변환) 또한 각 정점은 둘 이상의 본의 영향을 받기 때문에 실제로 여러 본의 변환에 대한 가중 평균을 계산해야한다. 각 본 변환은 루트까지 동일한 방식으로 계산된다. 이런 변환은 애니메이션 중에 조정됨. 이렇게 애니메이션하기 위해 Assimp 는 두 개의 행렬을 제공한다. (offset, node transformation)Assimp offset matrix offset matrix: local to bone space 본 구조체에 있음.(본에는 또한 정점들에 대한 정보가 포함된다.) 루트에서 본까지의 모든 변환이 이미 포함됨. 따라서 계층 구조에 대해서는 걱정할 필요없음. 물론 영향 받는 본에 대해서 여러 좌표를 얻게됨. 이를 하나의 최종 행렬로 계산해야함 가중 평균을 구해서 하나의 행렬로 만들어야함. blender example 본의 기저부가 로컬 공간의 원점에 있고, 본 공간의 축이 로컬 공간의 축과 같으면 기본적으로 아무것도 하지 않음 =&amp;gt; 단위 행렬 만약 한단위 이동한곳에 본이 있으면.. -1만큼 이동해야 원점에 위치하게 되므로 translate(0, -1, 0) 이 적용된 행렬이 offset행렬로 결과가 나온다. 만약 각도가 45도 회전됬으면.. rotate 가 적용된 행렬이 offset 행렬로 나타남 Assimp node transformation matrix 아래는 Assimp 노드 계층구조이다. 노드는 장면의 한 개체를 나타냄 이 때 한 개체의 위치와 방향은 부모를 원점으로 가지는 좌표계의 값이다. (상대적인 값들) 개체는 메시, 본, 카메라, 조명 등에 해당한다. The aiNode structure 노드 계층구조는 단일 루트 노드로 시작한다. 각 노드는 다음과 같은 정보를 포함한다. mChildren: 0개 이상의 자식에 대한 포인터 배열 mMeshes: 0개 이상의 메시에 대한 포인터 배열 mParent: 부모에 대한 포인터 mTransformation: 벡터를 상위 좌표계로 변환해주는것. (예시: 지구의 좌표계에서 태양의 좌표계로 변환해줌) 로컬위치벡터에 오프셋 행렬을 곱한후에는 본 좌표계가 됨. 다음 단계는 계층 구조에서 해당 노드를 찾고 이 노드의 mTransformation 행렬을 적용하고 계속해서 루트까지 이를 반복함. 본들은 노드의 이름과 대응됨. referencesSkeletal Animation In OpenGL using Assimp - Part 3" }, { "title": "[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 2", "url": "/posts/2022/03/25/01/47/skeleton2/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-25 01:47:35 +0900", "snippet": "이번 영상은 본과 그 정점에 미치는 영향을 시각화하는 튜토리얼이다.지금 당장 구현하고 싶은 부분이 아니기 때문에 정리는 생략했다.intro aiScene의 구조는 위와 같다. scene은 mesh 들을 가짐 mesh 에는 bone들이 있음. bone에는 bone의 이름과, offsetMatrix, mWeights가 있음 mWeights는 정점의 인덱스와 정점에 미치는 가중치를 가짐.(0~1.0) offsetMatrix는 mesh space를 bone space로 변환해주는 행렬임. 만약 스키닝된 모델에서 offset만 적용시킬 경우, bone space 원점에 모여있게됨, 여기서 aiScene의 mTransformation 을 적용시킬 경우 바인딩 포즈로 변환, 그리고 mTransformation에 애니메이션의 한 프레임의 변환행렬을 곱해주면 그 프레임에 맞는 포즈로 변환된다. 이에 대해서는 part3에서 다룬다. The Plan 각 본에 영향을 미치는 정점들을 볼 수 있는 유틸리티를 만들것임.(빨강- 강한 영향, 파랑- 약한 영향) 이는 모델이 잘 로드됬는지 디버깅하기 좋음 referencesSkeletal Animation In OpenGL using Assimp - Part 2" }, { "title": "[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 1", "url": "/posts/2022/03/24/03/46/skeleton1/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-24 03:46:39 +0900", "snippet": "Skeleton skeletal animation, skinning 은 애니메이팅의 기본적인 방법이다. skeletal animation 모델을 skin 이라고 부름 (스키닝) bone 은 실제 세계에서와 같이 skin을 움직이는 skeleton. skeleton과 skin 사이에 빈공간만 존재 그러므로, 블렌더와 같은 소프트웨어는 vertices의 리스트만 제공한다. 즉, bone이 움직이고 회전하는 변환이 뼈의 영향을 받는 꼭짓점에 적용되어야함. skeleton 이 아닌 skin만 렌더링됨 skeleton 과 bone의 역할은 단순히 skin에 사용할 수 있는 움직임 범위를 정의하는 데 도움이 된다. 용어 리깅(rigging): 블렌더에서 가상 bone을 skin 내부에 배치하고 특정 신체 부위에 맞게 적절한 길이로 만들고 뼈대로 연결하는 과정 skinning: 정점을 골격에 연결하고 각 정점이 bone의 영향을 받는 정도를 정의하는 프로세스 Animating: 시간 경과에 따른 뼈의 움직임을 정의하는 키프레임 세트를 만들기 위해 리깅 중에 배치된 사용 가능한 컨트롤을 사용. 실제 움직임 모방하는데 도움이 되는 두가지 특성 skeleton의 계층 구조를 정의 대부분 bone에는 부모가 있으므로, 부모 bone 이 움직일 때 자식 bone도 따라옴 이 관계는 단방향 아이는 부모에게 영향을 주지않고 움직임. 만약 모든 정점이 하나의 bone에 의해 완전 제어될 때, 그 모델은 로봇이거나 기계유형의 모델일 가능성이 높음. 예) 자동차의 문과 자동차는 분리됨. 하지만, 각 정점은 하나 이상의 bone의 영향을 받을 수 있다. 하나 이상의 bone이 움직일 때 이러한 bone의 영향을 받는 정점의 변형이 어떻게든 각 bone의 변환을 결합해야 함을 의미한다. 피부(skin)의 탄력을 시뮬레이션하는 것처럼. 이런 동작은 관절 주위가 핵심. 스켈레톤 애니메이션은 영향을 미치는 모든 bone을 기반으로 각 정점의 움직임을 계산하는 측면에서 높은 유연성을 제공함 탄력 시뮬레이션: vertex weights bone과 정점의 각 조합에 가중치를 할당하여 이를 수행 가중치: 0~1 사이의 분수, 정점당 모든 가중치의 합은 1 bone 변환과 가중치의 선형 조합으로 계산을 수행 예) 하나의 정점에 영향을 미치는 두 개의 bone의 가중치가 절반이라면, 정점은 두 bone의 영향을 동등하게 받으며 그 움직임은 두 bone의 움직임의 평균이 된다. Weights in Blender 자동 할당으로 설정 가능 블렌더는 정점과 각 bone 사이의 거리를 기반으로 가중치를 계산한다. 웨이팅 페인팅이라는 블렌더의 기능으로, 모델을 수정하고 조정 가능 특수 브러시로 선택한 bone의 정점 가중치를 높이거나 낮춘다만 일반적으로 아티스트는 skin을 먼저 만들고 skeleton을 만든다. Bind Pos Skeleton이 실제로 렌더링될 신체 부위의 치수와 일치해야 하기 때문에 의미 있음. 이 단계에서 애니메이션 과정이 시작되기 전 피부의 자세를 바인드 포즈라고 한다. 모든 기본 변환 및 수학식이 바인딩 포즈를 시작 위치로 참조하기 때문에 이는 매우 중요하다. 바인드 포즈에서 모델이 어떻게 보여야 하는지에 대한 제한은 없지만, 일반적인 관행은 관절 영역에서 너무 많이 구부러지지 않고 편안한 자세로 모델을 유지하는 것 보통 팔을 옆으로 쭉 뻗고 다리가 곧고 이완된 모델(skeletal animation bind pose) 애니메이션을 적용하지 않고 모델을 렌더링할 때 바인드 포즈로 가져와야 한다. Animating 리깅과 스키닝이 완료되면 모델을 애니메이션할 준비가 완료된것. 동일한 bone 세트를 여러 애니메이션 세트에 사용할 수 있다. 각 애니메이션 세트는 걷기, 달리기등을 시뮬레이션한다. 애니메이션 세트는 아티스트가 애니메이션을 적용할 때 골격에 적용되는 일련의 변형으로 구성된다. 변환: scaling, rotation, tanslation 변환은 일부 프레임 속도에 따라 일정한 간격으로 제공됨 예를 들어 초당 24프레임의 10초 애니메이션에는 240개의 세트가 포함된다. 이 세트는 일반적으로 매우 가깝기 때문에 게임의 실제 프레임 속도가 애니메이션 프레임 속도보다 높으면 연속 변환 사이를 보간하여 더 미세한 애니메이션을 얻을 수 있다. 이러한 변환은 bone의 orientation 변화를 나타내므로 bone의 영향을 받는 정점에 적용하고 기본적으로 모델에 애니메이션을 적용할 수 있습니다. The Plan 이제 skeleton 애니메이션은 다양한 파일 유형에서 지원되며 특정 파일 유형에 대한 로더를 구현하는 경우 해당 파일 유형의 규칙을 준수하기 위해 skeleton 애니메이션 코드가 필요하다. 하지만, Assimp를 사용하기 때문에 이 라이브러리의 규칙과 세부 사항을 준수하기 위한 코드만 있으면 되며 이를 통해 많은 파일 유형을 지원할 수 있다. 먼저, Assimp에서 생성한 데이터 구조를 구문 분석하고 관련 부분을 추출하는 간단한 유틸리티를 만들것이다. 이를 나중에 OpenGL과 통합할것이다. Assimp utility build script(에이에스심피)assimp_sandbox.cpp, build_assimp_sandbox.sh 이 유틸리티는 실제로 애니메이션을 실행하는 데 필요하지 않지만 디버깅 등에 매우 편리하다. 이 유틸리티는 assimp_sandbox.cpp라는 단일 파일로 구성되며 동일한 디렉토리에 build_assimp_sandbox라는 빌드 스크립트도 있다. .sh 파일은 간단하다. #!/bin/bashCPPFLAGS=&quot;-ggdb3&quot;LDFLAGS=`pkg-config --libs assimp`g++ assimp_sandbox.cpp $CPPFLAGS $LDFLAGS -o assimp_sandbox CPPFLAGS라는 빌드 플래그 지금은 디버깅을 위한 디버그 정보로 빌드하기 위해 -ggdb3만 포함 LDFLAGS라는 링크 플래그 pkg-config --libs assimp 호출. 코드가 가능한 한 많은 컴퓨터와 시스템에서 컴파일되기를 바라기 때문에 저자는 빌드 스크립트에서 pkg-config를 자주 사용함. 이를 터미널 해당 경로에서 pkg-config --libs assim를 치면, -lassimp등과 같이 나옴.(머신마다 다름) 빌드 코드는 간단 g++ assimp_sandbox.cpp $CPPFLAGS $LDFLAGS -o assimp_sandbox Start of assimp_sandbox.cpp review Assimp load에 대한 영상 참고헤더파일 먼저 Assimp에 대해 이 세 개의 헤더를 포함해야한다.#include &amp;lt;assimp/Importer.hpp&amp;gt; // C++ importer interface#include &amp;lt;assimp/scene.h&amp;gt; // Output data structure#include &amp;lt;assimp/postprocess.h&amp;gt; // Post processing flags메인함수 main 함수는 다음과 같다.#define ASSIMP_LOAD_FLAGS (aiProcess_Triangulate | aiProcess_GenNormals | aiProcess_JoinIdenticalVertices )int main(int argc, char* argv[]){ if (argc != 2) { printf(&quot;Usage: %s &amp;lt;model filename&amp;gt;\\n&quot;, argv[0]); return 1; } char* filename = argv[1]; Assimp::Importer Importer; const aiScene* pScene = Importer.ReadFile(filename, ASSIMP_LOAD_FLAGS); if (!pScene) { printf(&quot;Error parsing &#39;%s&#39;: &#39;%s&#39;\\n&quot;, filename, Importer.GetErrorString()); return 1; } parse_scene(pScene); return 0;} 매개변수 수를 확인하고 있으며 이 유틸리티에 단일 매개변수가 있기 때문에 2개가 필요하다. 모델 파일을 받는다. argv[0]: 실행 파일 명 그렇지 않은 경우 유틸리티를 종료 argv[1]에서 파일경로를 받고, 기본적으로 모든 Assimp 구문 분석을 처리하는 Assimp Importer 클래스의 객체를 정의한다. ASSIMP_LOAD_FLAGS와 파일 이름을 사용하여 Importer 개체에서 readFile을 호출한다. 플래그: 삼각형으로 + 법선 생성 The aiScene structure aiScene 개체를 사용하여 parse_scene을 호출void parse_scene(const aiScene* pScene){ parse_meshes(pScene);} aiScene은 Assimp와의 모든 상호 작용을 처리하는 주요 객체 모든 정점과 인덱스 및 bone이 있는 aiMesh 객체 배열이 있으므로 parse_scene은 매우 간단 parse_meshes 호출하여 계층구조와 애니메이션을 다룸. The aiMesh structure: parse_meshesvoid parse_meshes(const aiScene* pScene){ printf(&quot;*******************************************************\\n&quot;); printf(&quot;Parsing %d meshes\\n\\n&quot;, pScene-&amp;gt;mNumMeshes); int total_vertices = 0; int total_indices = 0; int total_bones = 0; for (unsigned int i = 0 ; i &amp;lt; pScene-&amp;gt;mNumMeshes ; i++) { const aiMesh* pMesh = pScene-&amp;gt;mMeshes[i]; int num_vertices = pMesh-&amp;gt;mNumVertices; int num_indices = pMesh-&amp;gt;mNumFaces * 3; int num_bones = pMesh-&amp;gt;mNumBones; printf(&quot; Mesh %d &#39;%s&#39;: vertices %d indices %d bones %d\\n\\n&quot;, i, pMesh-&amp;gt;mName.C_Str(), num_vertices, num_indices, num_bones); total_vertices += num_vertices; total_indices += num_indices; total_bones += num_bones; if (pMesh-&amp;gt;HasBones()) { parse_mesh_bones(pMesh); } printf(&quot;\\n&quot;); } printf(&quot;\\nTotal vertices %d total indices %d total bones %d\\n&quot;, total_vertices, total_indices, total_bones);} aiScene의 mNumMeshes 속성에서 찾을 수 있는 aiScene 개체의 메시 수를 출력하는것으로 시작 다음으로 메쉬에 대해 반복하는 정점, 인덱스 및 bone의 총 수에 대해 몇 가지 카운터를 준비 그리고 루프문에서 인덱스 기반으로 mMeshes 배열에서 각 메쉬를 추출한다 인덱스의 수는 면의 수에 3을 곱한 값을 계산합니다.(모든 폴리곤을 삼각 측량(triangulated)했기 때문) aiMesh에서 bone은 배열, mNumBones 로 사이즈 알 수 있음 HasBones을 호출하여 다음으로 bone들을 처리함 parse_mesh_bones를 호출하므로 이제 pars_mesh_bones로 이동 pars_mesh_bonesvoid parse_mesh_bones(const aiMesh* pMesh){ for (unsigned int i = 0 ; i &amp;lt; pMesh-&amp;gt;mNumBones ; i++) { parse_single_bone(i, pMesh-&amp;gt;mBones[i]); }} bone들을 조회하면서 parse_single_bone을 호출.실행 이제 이 코드를 실행해보자. Content/boblampclean.md5mesh를 대상으로 실행할 것이다. 메쉬의 이름을 알 수 있음. 메시와 정점의 개수를 알 수 있음. 뼈의 수도 알 수 있음. 뼈의 수가 28개인곳이 중요한 부분. 이런 정보는 블렌더에서 로드하면 위와 대응됨을 알 수 있음. The aiBone structure: parse_single_bone parse_mesh_bones에서 각 뼈에 대해 parse_single_bone을 호출하고 인덱스도 전달함void parse_single_bone(int bone_index, const aiBone* pBone){ printf(&quot; Bone %d: &#39;%s&#39; num vertices affected by this bone: %d\\n&quot;, bone_index, pBone-&amp;gt;mName.C_Str(), pBone-&amp;gt;mNumWeights); for (unsigned int i = 0 ; i &amp;lt; pBone-&amp;gt;mNumWeights ; i++) { if (i == 0) printf(&quot;\\n&quot;); const aiVertexWeight&amp;amp; vw = pBone-&amp;gt;mWeights[i]; printf(&quot; %d: vertex id %d weight %.2f\\n&quot;, i, vw.mVertexId, vw.mWeight); } printf(&quot;\\n&quot;);} aiBon 구조, 4개의 변수 aiString mName: 블렌더에서 볼 수 있었던 이름 unsigned int mNumWeights: The number of vertices affected by this bone aiMatrix4x4 mOffsetMatrix: Matrix that transforms from mesh space to bone space in bind pose(이 행렬이 바인드 포즈에서 mesh space에서 bone space로 변환) aiVertexWeight* mWeights: The vertices affected by bone. aiVertexWeight 구조, 2개의 변수 unsigned int mVertexId: 정점의 인덱스 float mWeight: (0…1), 범위에 있어야하는 영향의 강도 다시 실행 각 메쉬에 대한 bone 목록, bone들의 이름과 이에 의해 영향을 받는 정점을 얻는다.The first challenge 많은 정점들이 bone에 매핑되며, 많은 bone에 의해 영향을 받는다. 하지만, skeletal animation은 vertex shader에서 구현된다. 기본적으로 정점의 위치를 실제로 변경할 수 있는 유일한 장소이기 때문 따라서 우리가 실제로 필요한 것은 각 정점에서 영향을 미치는 bone으로의 역 매핑이다. a reversed mapping frome each vertex 이 정보는 정점 셰이더에 제공되어야 이 모든 뼈를 기반으로 각 정점의 변환을 계산할 수 있다. 출처Skeletal Animation In OpenGL using Assimp - Part 1" }, { "title": "[UE4] Skeleton Assets: Overview", "url": "/posts/2022/03/24/01/36/UE4_Skeleton_Assets_Overview/", "categories": "game, game-unreal4", "tags": "unreal4", "date": "2022-03-24 01:36:00 +0900", "snippet": "Skeleton Assets: Overview를 보고 정리한 문서Skeleton Assets캐릭터 생성 스켈레탈 메시로 외형부터 만든다. 스켈레탈 메시 == 3D모델 스켈레톤 구성 즉, 캐릭터의 리깅 작업 본이나 관절 계층 구조의 추가 및 정의 등이 진행된다. 캐릭터의 포즈 조정이 가능해짐. 타임라인 상에서 각 포즈들에 키 프레임 지정 포즈에 애니메이션을 부여하는 식으로 애니메이션 제작 임포트 외부 =&amp;gt; 언리얼 임포트 오해 한가지: 1:1 로 대응되는 스켈레톤이 있어야한다는 점 그럴 필요는 없음.(몇몇 조건들이 있긴함.) 본과 계층 구조 정보만을 요구함 언리얼의 스켈레톤은 3D 본 보다는 목록에 더 가까움. 목록: 스켈레탈 메시에서 활용하는 본과 계층구조 정보가 포함되어 있다. 스켈레톤 트리는, 관련 스켈레탈 메시의 애니메이션을 구동하는 데 사용 하나의 스켈레톤 애셋과 스켈레톤 트리를 여러 스켈레탈 메시에서 공유할 수 있다. 스켈레톤 애셋은 그저 스켈레탈 메시의 릭 작업에 활용하는 스켈레톤 애셋의 본의 위치와 계층 구조 정보를 추적하는 목록에 불과하다. 스켈레탈 메시는 그저 이 정보를 언리얼 엔진 내 스켈레톤 애셋으로 전달할 뿐이다. 공유 두 캐릭터가 모두 같은 스켈레톤 애셋을 공유(본과 계층구조의 구성이 같음) 모두 엔진으로 임포트한 애니메이션을 활용가능 서로가 각 스켈레탈 메시에 등록된 애니메이션을 구동할 수 있다. 리타겟팅 애니메이션을 재생하는 각 스켈레탈 애셋의 스켈레톤 메시에 따라 애니메이션이 늘어나거나 생략되는 일이 없도록 약간의 조정을 하는 것 리타겟팅 == 스켈레톤 애셋의 또 다른 기능 단지 본의 위치나 회전 등의 정보만을 추적하는 것이 아님 리타겟팅 =&amp;gt; 본의 트랜스폼 정보 활용 기본 본 구성 + 계층 구조 + 작명 방식 이 같으면, 여기에 추가적인 요소 달기 가능. 임포트할 때 굳이 다른 스켈레톤 에셋 사용안해도됨 애니메이션 리타겟도 가능 =&amp;gt; 서로다른 스켈레톤 애셋을 사용하는 스켈레톤 메시 역시 같은 애니메이션을 공유할 수 있다/공유하지 못할 경우 계층 구조 본 중에 이름이 다르거나 본이나 계층구조가 다른 경우 스켈레톤 애셋을 다시 만들어서 사용해야함. 계층구조 자체를 바꾸어버리면 문제가 생김 (그냥 마지막에 자식을 추가하는것은 별로 문제가 되지않음) 계층구조 순서가 바뀌거나 작명이 바뀌면 문제 발생 가능 애니메이션 리타게팅 작업은 구성하는 데 많은 추가 작업을 요구한다. 스켈레톤 애셋 본의 목록 그리고 계층 정보 캐릭터 애니메이션 구동에 사용 다수의 스켈리탈 메시와 공유됨 애니메이션 리타겟팅에 도움(스켈레톤 애셋이 다른 캐릭터들끼리 애니메이션 공유) sockets, notifies, curve names, slot names 저장 소켓: 손으로 총이나 물건등을 줍거나 할때 노티파이: 이벤트등 처리 커브이름: 모프 타겟에 인플루언스, 본 트랜스폼 편집, 구성해둔 머티리얼 파라미터의 구동에 활용 (캐릭터 볼을 붉히고 싶은 경우, 커브를활용해야함) 이 커브는 특정 애니메이션이 아니라 스켈레톤 애셋에 저장해야함. 그래야 이 스켈레톤 애셋을 공유하는 많은 캐릭터들이 활용할 수 있게됨. 슬롯 이름은 split-body를 구성하고 활용할 수 있는 방법(엉덩이 기준으로 위쪽 몸을 분리해 Upperbody라는 슬롯을 만들 수도 있다.) 슬롯을 기준으로 위 아래 애니메이션 적용 가능(걸으면서 총) 다른 경우 릭애셋 사용 릭: 스켈레톤 애셋 간에 정보만 전달하는 애셋, 중개 애셋 같은 릭을 공유 =&amp;gt; 같은 애니메이션을 공유할 수 있는 정보를 전달받고 있는 상태출처Skeleton Assets: Overview2: share retarget3: different skeletons4: sockets5: slot, notifies, curves" }, { "title": "[UE4] 애니메이션 시작하기", "url": "/posts/2022/03/23/21/58/unreal-animation/", "categories": "game, game-unreal4", "tags": "unreal4", "date": "2022-03-23 21:58:52 +0900", "snippet": "애니메이션 시작하기철학 다용도성 확보(versatile tools) 레이어화된 애니메이션 플로우 다양한 애니메이션 레이어에서 벌어지는 일들을 쉽게 분리해서 레이어별로 반복 처리하고 폴리시할 수 있음. 재사용성 애니메이션 속의 다양한 요소를 다른 캐릭과 애니메이션 등을 공유하는것 ue1: 버텍스 애니메이션 기반 ue2: 스켈레톤 추가, 소켓, 애니메이션 노티파이 등 요소 추가 ue3: cloth 추가, matinee를 위한 시네마틱 에디터가 추가됨개요 스켈레톤이 중심 스켈레톤 메시 : 엔진 퀄리티 기능- LOD와 세트 애니메이션 블루프린트 이벤트 그래프: 애니메이션과 게임 플레이를 연결하는 역할을 한다. 애니메이션 그래프: 게임플레이 변수를 기반으로한 애니메이션 플로가 됨. 애니메이션 시퀀스 : 여러가지 툴로 변환한 후 애니메이션 블루프린트에 배치 피지컬 에셋도 배치 가능 애니메이션 그래프 =&amp;gt; 포즈 계산 =&amp;gt; 스케렐탈 메시 실행 시퀀서 : 시네마틱 툴시퀀스 : 실제 애니메이션스켈레톤과 스켈레톤 메시 FBX 파일을 언리얼 엔진으로 임포트하면, 동일한 FBX 파일 내에 완성된 애니메이션과 서로 다른 애니메이션 다수가 있을것임 리깅 스켈레톤과 메시도 있음 따라서 임포트하면 하나의 파일이 아닌 서로 다른 여러 파일이 갖춰짐 (이렇게 스켈레톤이 갖춰짐) 스켈레톤에는 스켈레탈 메시, 디스플레이되는 지오메트리와 다양한 애니메이션을 각각 서로 다른 파일에 갖추게 된다. 임포트하면, 피직스 에셋도 생성가능 스켈레톤이 피직스 환경에 반응하는 방식을 정의한다. 스켈레톤 메시를 선택 =&amp;gt; 뷰포트 =&amp;gt; 본 =&amp;gt; 스켈레톤 볼 수 있음. 다수의 메시가 스켈레톤에 연결된것을 볼 수 있음. 스켈레톤 가상 본, 소켓등을 연결 가능 (에디터에서 계층구조에 추가 가능) 소켓(socket): 다른 본에 부모설정이 된 요소. 이 소켓의 트랜스폼은 애니메이션을 따른다. 게임플레이에서 처리하려는 특정 요소를 스켈레톤에 붙일 수 있음. 캐릭터가 뭔가 손으로 조종하게하고 싶다면, 손에 소켓을 생성하면됨 리타겟 매니저 시스템 스켈레톤에 연결하는 애니메이션 블루프린트나 메시 등과 같은 모든 애셋을 다른 스켈레톤으로 할당 가능 tool bar =&amp;gt; retarget manager 서로 다른 스켈레톤에 그 애니메이션을 쓸 수 있다. 보통 스켈레톤은 구조가 대체로 비슷, 소스로 사용하는 스켈레톤과 매우 유사함 스켈레톤 메시에는 폴리곤 정보만 저장하는 게 아니라 머티리얼 정보도 저장 LOD세팅도 가능 (regenerate LOD =&amp;gt; 거리에 따른 각자 다른 메시) 피직스 에셋 등을 사용 가능 Clothing 또한 스켈레톤 메시에 저장됨 애니메이션 시퀀스 스켈레톤에 할당된 다양한 애니메이션 파일에서 임포트 가능 임포트되기만하면, 라이브 링크 플러그인과 다양한 DCC를 사용할 수 있다. 런타임에 엔진에서 직접 사전 시각화할 수 있음. 시퀀스 다수가 동일한 스켈레톤에 할당됨. 타임라인 =&amp;gt; 재생 툴 =&amp;gt; 애니메이션 앞뒤로 재생 가능 다양한 에셋에서 시퀀스들을 한 데 결합할 수도 있음 다양한 메타데이타 Anim Curves: 루트모션을 제거하면, 애니메이션중 이동하는 거리 계산 가능(게임플레이에서 사용가능한 정보) 애니메이션에 입력한 모든 메타데이터 =&amp;gt; 이벤트 그래프에서 읽을 수 있다. =&amp;gt; 게임플레이로 넘길 수 있다. Anim Notifies: 특별한 이벤트 추가 가능 (칼을 휘두르면 타격 =&amp;gt; 타격 판정 확인 =&amp;gt; 게임플레이 블루프린터에서 노티파이를 보내 애니메이션의 정확한 위치에서 판정 내리기 가능) Sync Markers: 애니메이션상에서 뭔가 발생할 시점을 알려준다.(마킹) 예를들어 다른 애니메이션과 동기화(왼발, 오른발) 애니메이션 시퀀스가 출처인 에셋도 있음 애니메이션 목록에는 블렌드 스페이스와 몽타주가 있음 montages: 다양한 애니메이션 시퀀스를 서로 그룹화하거나 합침. 애니메이션 큐 (사운드 웨이브의 사운드 큐같은것): 기본적으로 일정 유형의 다양한 에셋 여러개를 한 그룹으로 합침. 몽타주는 게임플레이 중에 쉽게 플레이 가능. 보통 캐릭터의 입력에 따른 반응으로 재생됨(구체적인 반응을 재생하고자할 때) 플로 대신 몽타주로 재생 blend spaces: 애니메이션 합침 (변수 값에 따라,ex. 달리는 캐릭의 각도 변경) pose asset: 애니메이션 쉽게 만들기 가능 Create Asset -&amp;gt; Create PoseAsset -&amp;gt; 애니메이션 속 프레임의 포즈를 포착해 별개의 신규 에셋에 저장한다. =&amp;gt; 다양한 포즈로 서로 블렌딩해서 새 애니메이션 만들기 용이 게임플레이 변수로 제어가능 게임 플레이에서 그 타이밍등을 제어가능 애니메이션 그래프 시퀀스를 재생가능 애니메이션 외적인 변수들을 처리 가능 그래서 게임플레에서 이벤트 그래프로 피드롤 보냄. 이런 변수들을 모두 모아, 자신만의 변수로 변화시킨 다음, 그 정보를 활용해서 애니메이션 그래프 속의 애니메이션 플로를 제어한다. 다양한 정보로 다양한 애니메이션 플로를 재생하게됨. 플로에는 다양한 노드들이 있음. 주요노드는 상태 머신 애니메이션의 플로를 설정해야한다면 상태머신만으로는 부족하지만 주요 툴은 아님 하이엔드 애니메이션 플로에서 굉장히 강력하긴 함. flow control 애니메이션 그래프에는 Flow Control 노드가 있음 Slots 플로가 들어오는곳 슬롯에서 뭔가 시작하면, 슬롯에 넣은걸로 플로를 오버라이드 반응과 관련된 모든걸 저장하는데 슬롯을 사용할 수 있음. 예. 플레이어 공격 =&amp;gt; 공격의 몽타주를 해당 슬롯에 저장 =&amp;gt; 플로에서 재생되는 모든 애니메이션을 읽은 후 그 애니메이션을 출력 Blend and Additive 본 간의 보간, 온갖 다양한 변수들로 수행할 수 있다. Additive: 두 애니메이션을 한 데 섞는게 아니라 애니메이션 하나를 다른 애니메이션 위에 배치하는 것.(공격을 당하면서, 스켈레톤의 흉부가 밀쳐저 뒤로 밀려나는 애니메이션이 있다면, 그 애니메이션을 가장 우선적으로 재생함. 앞서 일어난 일에 따른 결과로 추가 가능) Pose Caching 플로의 현재 위치를 저장해서, 나중에 얻어내는것 공격과 달리기 애니메이션을 블렌딩 Procedural Animations Physics Assets 캡슐을 통해 그래프 =&amp;gt; 캡슐의 연결된 형태를 살펴볼 수 있다. (constraint) 바디간에 어떤 변화가 생기는지 정의해줌 시뮬레이트 =&amp;gt; 물리환경에서의 반응 방식을 볼 수 있다. Rigid Body Node, Anim Dynamics, IK Nodes 이 노드들이 있다면, 피지컬 비헤이비어를 현재 실행중인 애니메이션과 블렌딩 가능 그러면 다시 한 번 애니메이션 플로를 수정하게 됨. 리지드 바디가 피직스 에셋에 연결된 셈 피지컬 애니메이션 profiles =&amp;gt; 모든 컨스트레인트를 정의함 AnimDynamics : 리지드 바디 구성을 사용하지 않고 본 별로 그 작업을 할 수 있다. IK 용도: 캐릭터는 지면을 기준으로 양수인 위치에 양발을 두어야함 =&amp;gt; 양발을 적절한곳에 위치해야함 아무 곳에도 종속되지 않은 위치가 애니메이션 내내 사용되는것. 애니메이션 레이어 애니메이션 플로를 제어하는 소소한 방법들을 만들 수 있다. 게임플레이 입력이나 변수에 따라 레이어간 교체 가능 현업도 가능 =&amp;gt; 두 명의 애니메이터가 동일한 애니메프션 그래프 사용하여 협업가능 한 명이 레이어 하나 작업 =&amp;gt; 다른 한명은 다른 레이어 control rig 스켈레톤 제어 엔진 내에서 리깅을 만들 수 있다. 스켈레톤 계층 구조의 다양한 부위에 따라 비헤이비어를 만들어줄 수 있다. 현재 둔부 위치에 따라 양 발 제어 최종 포즈 노드 그래프의 결과가 나온것 Animation Sharing Manager 다양한 스켈레톤 간에 공유 가능 동일한 스켈레톤과 동일한 스켈레탈 메시를 사용하는 서로 다른 케릭터들 그 중 하나의 포즈를 모두에게 공유 가능 CPU는 수 많은 스켈레톤에 공유된 포즈들만 처리하면된다. 캐릭터 군집 표현 시퀀스 레코더 애니메이션에 일어나는 일을 녹화할 수 있다. 창 =&amp;gt; 시네마틱 =&amp;gt; 시퀀스 레코더 플레이어가 수행한 모든 행동이 기록됨. 시뮬레이션 가능(몇몇 박스를 두고, 피직스 시뮬레이션에 필요한 물리적 영향 계산하고, 런타임에 실제 시뮬하지않고 녹화한것만 보여주면됨) 퍼포먼스 Animation Sharing Manager Animation Budget Allocator 각 애니메이션에 사용할 시간의 예산을 설정할 수 있다. 애니메이션 블루프린터에서는 티킹의 양을 줄여주고 애니메이션을 공유하며 피지컬 비헤이비어를 잘라내는 식으로 예산을 유지함 Animation Tick 티깅되는 애니메이션 수를 줄임 LOD 본의 양 또한 줄임. (손에서 본이 없어짐.) Fast path 블프 노드가 순수하게 C++ 로 컴파일 된 것 처럼 쓰임. Multi Threaded Update 스레드 다수가 대기 상태라면, 시간 많이 아낌 그냥 단일 스레드와 같은 방식으로 실행 조언AnimBP Retargeting 애니메이션 시퀀스뿐만 아니라 애니메이션 블루프린트도 리타깃 가능 베이직 블프 =&amp;gt; 게임속 케릭터 모두 사용하게 가능 =&amp;gt; 모두가 비헤이비어를 글로벌 비헤이비어를 공유해야함 모두가 같은동작 리타깃할 수 있는 모든 것에 복붙하는 것보다 처음부터 잘 설계Layering 상태 머신 단순한게 좋음 스테이트의 모든것은 일반 플로에 추가가능 스테이트머신 중첩 가능 (디버깅 쉬워짐) 플로의 시작점에 애니메이션의 큰 줄기를 만들고 차차 디테일을 추가하는 게 훨씬 쉬운 작업방식Flow control 오버라이드가 필요한 반응 애니메이션등을 주로 슬롯에 저장하는 건 좋지 않다. 게임플레이에 따른 반응만 저장하는게 좋다.(공격 애니메이션) 캐시 사용 비용이 딱히 크지 않음 Ticking and Performance 캐릭터나 특정 액터에서 업데이트 비율 최적화를 활성화할 수 있다. 즉, 애니메이션 캐릭터로부터 멀리 떨어질 수록 티킹도 점점 적어짐 Optimization =&amp;gt; Enable update rate optimizations 캐릭터의 비율에 따른 색상별 디스플레이도 가능 티킹을 줄이는것은 Anim Budgeter 가 알아서 작업 해줌 Physics Behavior 그냥 괜찮은 피직스 에셋 구성이니 필요한 비헤이비어는 최소한으로 줄임. 바디가 피직스에 반응하지 않도록 설정 가능 kinematic으로 유형 변경 simulated == 피직스에 반응 피직스 프로파일 프로파일 다수를 두고 런타임 중에는 변경 가능 피지컬 비헤이비어 유형을 하나 사용하다가 갑자기 다른 프로파일로 변경해 그대로 갈 수 있다. Animation Sharing Manager 무작위 애니메이션을 끼워넣어서 티가 덜나도록 만들기 가능 공유 애니메이션 위에는 반응 애니메이션을 추가할 수 있음 군중속의 캐릭터를 친다면, 반응하게 피직스 또한 추가가능 모두 데이터에 따라 관리됨 (프로퍼티에 의해 설정됨)문제 두 애니메이션 길이가 서로 다르지만 함께 블렌딩해야 합니다. 애니메이션 기능 중 애니메이션을 동기화하여 원활한 트랜지션을 가능하게 하는 것은 무엇인가요? 싱크 그룹 및 싱크 마커 출처ue4: 애니메이션" }, { "title": "[그래프] 벨만-포드 최단 경로 알고리즘", "url": "/posts/2022/03/22/04/45/bellman-ford/", "categories": "algorithm", "tags": "algorithm", "date": "2022-03-22 04:45:04 +0900", "snippet": "Bellman-Ford 다익스트라같이 단일 시작점 최단 경로 알고리즘 하지만 다익스트라는 음수 간선이 있는 경우 잘 동작하지 않음 벨만포드: 음수 사이클 여부 파악 가능, 음수 간선이 있어도 최단 경로 찾기 가능 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤 예측값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식으로 동작. 각 정점까지의 최단 거리의 상한을 담은 배열 upper[]를 유지해야함 동작과정 초기 그래프 구조에 대해 무지한 상태 시작점 s: upper[s] = 0 나머지: upper[x] = inf 벨만-포드 알고리즘은 이 upper값을 실제 최단 거리에 더 가깝게 갱신하기 위해 최단 거리의 특성을 이용한다. 최단거리 특성: dist[v] &amp;lt;= dist[u] + w(u,v) 이 식이 시작점에서 u와 v 까지의 최단거리는 항상 이 식을 만족한다. 이 특성을 이용하면, upper의 값을 최단거리에 가깝게 갱신 가능 완화(relax) upper[u] + w(u, v) &amp;lt; upper[v] u까지 가는 최단 거리는 항상 upper[u] 또는 더 짧다. 이 때 w(u, v)를 붙인 경로의 길이는 결국 upper[u] + w(u,v)가 상한이된다. 따라서 이를 만족하면 upper[v] 를 upper[u] + w(u, v)로 갱신해도 된다. 반복 완화과정을 모든 간선에 대해 반복적으로 실행 성공시 upper는 감소, 결국 최단 거리에 가까워짐 종료 조건과 정당성 증명 s 에서 어떤 정점 u 까지의 최단 경로가 다음과 같다s / - a - b - c - us - a / - b - c - us - a - b / - c - us - a - b - c / - us - a - b - c - u / 최단 경로가 보장된 정점은 / 왼쪽 부분 처음 upper[s] = 0 완화1: 모든 간선완화, (s, a) 또한 완화됨 upper[a] &amp;lt;= upper[s] + w(s, a) 수식이 이후로 항상 성립하게됨 즉, upper[s] 는 0 이므로 upper[a]&amp;lt;= w(s,a) 여기서 w(s,a)는 항상 최단거리 (s-a-b-c-u 가 최단경로라는 가정에 의해) 따라서 a에 대한 최단 거리를 찾음 완화2: upper[b] 가 최단이 됨. s-a 가 최단이고 거기에 (a,b) 간선이 붙어서 업데이트됨 완화4: 결국 upper[u] = dist[u]까지 업데이트됨 완화n: 완화 작업 n 번하면 n개 이하의 간선을 사용하는 최단 경로들을 전부 찾을 수 있다. - 최단 경로는 최대 |V| 개의 정점을 갖기 때문에 최대 |V|-1 개의 간선을 가질 수 있다. - 따라서 모든 간선에 대해 완화 과정은 전체 |V|-1번이면 충분 음수 사이클이 없는 그래프에서 최단 경로가 한 정점을 두 번 지나는 일은 없다 음수 사이클 판정 |V|번 완화하면됨. 사이클이 있으면, 그 사이클에서 완화가 이루어져 업데이트된다. 코드 모든 간선 검사는 중첩 반복문 가장 밖의 for문: |V|번 수행됨 안의 두 for문은 모든 간선을 순회하므로 O(|E|) 결국 전체 시간 복잡도는 O(|V||E|) int V;vector&amp;lt;pair&amp;lt;int, int&amp;gt; &amp;gt; adj[MAX_V];vector&amp;lt;int&amp;gt; bellmanFord(int src){ vector&amp;lt;int&amp;gt; upper(V, INF); upper[src] = 0; bool updated; for(int iter = 0; iter &amp;lt; V; ++iter) { updated = false; for(int here = 0; here &amp;lt; V; ++here) for(int i = 0; i &amp;lt; adj[here].size(); i++) { int there = adj[here][i].first; int cost = adj[here][i].second; if(upper[there] &amp;gt; upper[here] + cost) { upper[there] = upper[here] + cost; updated = true; } } if(!updated) break; } if(updated) upper.clear(); return upper;}실제 경로 계산 알고리즘 수행과정에서 각 정점을 마지막으로 완화시킨 간선들을 모와 스패닝 트리를 만든다. 각 정점을 마지막으로 완화 시킨 간선들은 항상 최단 경로 위에 있음 각 정점에서부터 루트까지 거슬러 올라가면 최단 경로가 됨 " }, { "title": "[learn-opengl] Advanced OpenGL: Advanced GLSL", "url": "/posts/2022/03/20/01/05/opengl25/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-20 01:05:19 +0900", "snippet": "Advanced GLSL 흥미로운 내장 변수들과 shader의 입력과 출력을 구성하는 새로운 방법, uniform buffer objects라고 불리는 유용한 도구를 다룰 것이다.GLSL’s built-in variables 셰이더는 극도로 파이프라인되어 있다. shader 밖의 다른 곳의 데이터가 필요한 경우, 데이터를 전달해야 함. vertex attributes, uniforms, sampler GLSL은 추가적인 여러 내장 변수들을 가짐. gl_ 접두사가 붙어있음. 데이터를 모으거나 작성하는 추가적인 의미를 가짐 앞에서 본 gl_Position 과 gl_FragCoord 같은것들이 이에 해당. 여기에서 모든 내장 변수를 볼 수 있다.Vertex shader variables Vertex shader의 clip-space 출력 위치 벡터인 gl_Position은 렌더링하기위해 필수적인 변수이다.gl_PointSize 기초 도형을 렌더링할 때, GL_POINTS를 선택할 수 있다. 하나의 vertex가 점으로 렌더링되는것. 이 점의 크기를 glPointSize 함수를 사용하여 설정할 수 있다. 하지만 우리는 이 값을 vertex shader에서도 영향을 줄 수 있다. gl_PointSize 의 GLSL 출력 내장 변수는 float 타입 변수이며, 너비와 높이를 픽셀 단위로 설정할 수 있다. Vertex shader에서 점의 크기를 설정하면, vertex 마다 점의 값을 설정 가능. 기본적으로 점 크기 수정은 비활성화 OpenGL에서 GL_PROGRAM_POINT_SIZE를 활성화 시켜야함 glEnable(GL_PROGRAM_POINT_SIZE); 간단한 예제는 점의 크기를 viewer와 vertex 사이의 거리인 clip-space 위치의 z값과 동일하게 설정하는 것. 이 점의 크기는 viewr와 멀리 떨어진 vertex일수록 더 커진다. void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); gl_PointSize = gl_Position.z; } 결과는 다음과 같다. (큰 점이 더 멀리있음) 이를 사용하여 particle을 만들어낼 수 있다.gl_VertexID gl_Position과 gl_PointSize는 출력 변수 결과에 영향을 줌 gl_VertexID는 입력 변수 정수 변수로, 지금 그리고 있는 vertex의 ID를 가짐. 인덱스된 렌더링(glDrawElements)을 수행할 때, 이 변수는 우리가 그리는 정점의 현재 인덱스를 보유한다. 인덱스 없이 그릴때 (glDrawArrays) 이 변수는, 렌더 호출이 시작된 이후 현재 처리된 꼭짓점의 번호를 보유한다.(처리된 vertex 개수) Fragment shader variablesgl_FragCoord gl_FragCoord 벡터의 z요소가 특정 fragment의 깊이값과 동일 이 벡터의 x, y 요소를 사용해보자 x,y 요소는 fragment의 window-space 좌표이다. 이 좌표는 좌측 하단부터 시작한다. glViewport 함수로 800x600을 설정하면, x값은 0~800, y값은 0~600 사이의 값을 가짐. 이 fragment shader를 사용하여 fragment의 윈도우 좌표를 기반으로 다른 컬러 값을 계산할 수 있다. gl_FragCoord변수가 자주 쓰이는 용도는 다른 fragment 연산과 시각적 효과를 비교하기 위해 쓰인다. ex) 하나의 출력은 화면 왼쪽에 렌더링하고, 다른 출력은 화면에 오른족에 렌더링하여 분할된 화면을 만들 수 있다. void main(){ if(gl_FragCoord.x &amp;lt; 400) FragColor = vec4(1.0, 0.0, 0.0, 1.0); else FragColor = vec4(0.0, 1.0, 0.0, 1.0);} 이제 다른 fragment shader 결과를 화면 양쪽에 보여줄 수 있게 되었다. 이는 다른 조명 기술들을 테스팅할 때 유용하다. gl_FrontFacing Face culling을 사용하지 않는다면, gl_FrontFacing 변수로 전면인지 후면인지 알려준다. 이를 사용해 전면에만 다른 컬러 설정 가능 gl_FrontFacing 변수는 이 fragment가 전면이면 true 후면이면 false 를 가지는 bool 타입 변수이다. 예를 들어 안과 밖이 다른 텍스처를 입힌 큐브를 만들 수 있다. #version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D frontTexture;uniform sampler2D backTexture;void main(){ if(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords); else FragColor = texture(backTexture, TexCoords);} 아래처럼 컨테이너 내부에는 다른 텍스처가 보인다. 만약 face culling 을 활성화시키면 gl_FrontFacing은 쓸모없어짐 gl_FragDepth gl_FragCoord는 read-only 변수이다. 하지만, fragment의 depth 값은 설정 가능하다. gl_FragDepth 변수로 shader내에서 depth를 설정할 수 있다. gl_FragDepth = 0.0; // this fragment now has a depth value of 0.0 Shader에서 이 값을 작성하지 않으면, 자동으로 gl_FragCoord.z값으로 설정됨 이 설정은 early depth testing 을 비활성화 시킨다. OpenGL이 fragment shader가 실행되기 전에 이 fragment 가 어떤 depth 값을 가질지 알 수 없기 때문. gl_FragDepth 는 이와같은 성능 패널티를 고려해야함. 하지만 OpenGL4.2 부터는 fragment shader 시작지점에 depth condition과 함께, gl_FragDepth를 재정의함으로써 둘 사이를 조정할 수 있다. layout (depth_&amp;lt;condition&amp;gt;) out float gl_FragDepth; condition 값은 다음 값들을 취할 수 있다. Condition Description any The default value. Early depth testing is disabled. greater You can only make the depth value larger compared to gl_FragCoord.z. less You can only make the depth value smaller compared to gl_FragCoord.z. unchanged If you write to gl_FragDepth, you will write exactly gl_FragCoord.z. greater 나 less를 지정하여, 오직 fragment의 depth 값보다 크거나 작은 값만을 작성할 수 있도록 할 수 있다. 이 방법으로, early depth test를 fragment의 depth 값보다 작거나 큰 값에 대해서 수행할 수 있다. depth 값을 증가시키지만, 일부 early depth testing을 수행하는 예제는 아래와 같다. #version 420 core // note the GLSL version!out vec4 FragColor;layout (depth_greater) out float gl_FragDepth;void main(){ FragColor = vec4(1.0); gl_FragDepth = gl_FragCoord.z + 0.1;}Interface blocks vertex 에서 frag로 데이터 보내고 싶을때, 여러 입력/출력 변수들을 선언했었다. 보낼 데이터가 많을 수 있음 이 변수들을 묶을 수 있도록, GLSL은 interface blocks라고 불리는 것을 제공한다. 이 역시 in, out 키워드를 사용한다. #version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoords;uniform mat4 model;uniform mat4 view;uniform mat4 projection;out VS_OUT{ vec2 TexCoords;} vs_out;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0); vs_out.TexCoords = aTexCoords;} 이를 통해 입/출력을 체계화해줄 수 있다. frag에서도 interface block을 선언해보자 이름은 동일해야함. 하지만 instance 이름은 원하는대로 지정 가능. #version 330 coreout vec4 FragColor;in VS_OUT{ vec2 TexCoords;} fs_in;uniform sampler2D texture;void main(){ FragColor = texture(texture, fs_in.TexCoords);} interface block의 이름이 동일하기만 하면, 서로 연결됨. 이는 코드를 체계화해주고, geometry shader와 같은 특정 shader 단계를 거칠 때 유용하다. Uniform buffer objects shader를 사용할 때, 계속해서 각 shader에서 정확히 동일한 값을 가지는 uniform들을 설정해야함. UBO는 여러 shader program에 걸쳐 동일하게 유지되는 전역 uniform 변수의 모음을 선언할 수 있도록 한다. UBO를 사용할 때 고정 GPU 메모리에서 관련 uniform을 한 번만 설정한다. 셰이더별로 고유한 uniform을 수동으로 설정해야 한다. UBO는 다른 버퍼들과 같은 버퍼 glGenBuffers()로 생성 GL_UNIFORM_BUFFER에 바인딩 모든 연관 uniform 데이터들을 버퍼에 저장가능. 먼저, 간단한 vertex shader에서 projection, view 행렬을 uniform block에 저장할 것이다. #version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices{ mat4 projection; mat4 view;};uniform mat4 model;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0);} 반복문이 돌때마다 projection, view 행렬을 설정하므로, 이를 하나로 저장한것. layout (std140)의 의미: 현재 정의된 uniform block이 특정한 메모리 layout을 사용한다는 뜻. 이 코드는 uniform block layout을 설정한다. Uniform block layout uniform block 내용은 버퍼 객체에 저장되며, 이는 사실상 글로벌 GPU 메모리의 예약된 부분. 이 메모리 조각에는 어떤 종류의 데이터가 있는지에 대한 정보가 없음 메모리의 어떤 부분이 셰이더의 uniform 변수에 해당하는지 OpenGL에 알려줘야함. shader에 아래와 같은 uniform block 이 선언되어 있다고 생각해보자layout (std140) uniform ExampleBlock{ float value; vec3 vector; mat4 matrix; float values[3]; bool boolean; int integer;}; 여기서 알아야하는것은 크기(바이트)와 변수들의 offset(block의 시작위치로부터), 그래야 이들을 buffer에 각자의 순서로 위치시킬 수 있다. 크기: OpenGL에 명시되어 있음, C++ 데이터 타입에 해당 변수 사이의 간격(spacing)은 명확히 명시되어 있지 않음. 이는 하드웨어가 변수들을 적합하다고 생각하는 곳에 위치시키기 때문. ex)일부 하드웨어는 vec3을 float와 인접하게 위치시킨다. 모든 하드웨어가 이렇게 처리할 수 있는것이 아니며, float을 추가하기 전에 vec3을 float[4] 로 만들어 채운다. 기본적으로 GLSL은 shared layout이라는 uniform 메모리 layout을 사용한다.(offset이 하드웨어에 의해 정의되면, 여러 프로그램 간에 일관되게 공유되기 때문) 이를 사용하면, 변수의 순서가 그대로 유지되는 한, GLSL이 최적화를 위해 uniform 변수의 위치를 변경할 수 있다. 우리는 각 uniform 변수들이 가질 offset을 모르기 때문에, uniform buffer를 정확히 채우는 방법을 모른다. 이 정보를 glGetUniformindices 같은 함수를 사용하여 쿼리할 수 있지만, 이 접근 방법은 이 챕터에 맞지 않다. shared layout이 일부 공간을 절약하는 최적화를 주지만, 각 변수들에 대한 offset들을 알아야한다. 하지만, 일반적으로 shared layout 대신 std140 layout을 사용하기도 한다. 이 std140 layout은 각 변수 타입에 대해 룰에 따라 저마다의 offset을 명시하여 메모리 layout을 분명하게 명시한다. 이 것이 명확하게 명시하기 때문에, 수작업으로 각 변수들의 offset을 알아낼 수 있다. 각 변수는 uniform block 내에서 변수가 가질 수 있는 공간(여백을 포함)인 base alignment를 가진다. 이 base alignment는 std140 layout 규칙을 사용하여 계산된다. 그 다음, 각 변수에 대해 우리는 block의 시작으로 부터 해당 변수까지의 바이트 offset인 aligned offset을 계산한다. 이 aligned 바이트 offset은 base alignment의 배수이다. 정확한 layout 규칙은 여기에서 확인할 수 있다. 가장 많이 쓰이는 규칙들은 아래 표에서 찾을 수 있다. int, float, bool 과 같은 GLSL 변수 타입들은 4바이트 타입으로 정의된다. 4바이트의 각 요소들은 N으로 표시됨. Type Layout rule Scalar e.g. int or bool Each scalar has a base alignment of N. Vector Either 2N or 4N. This means that a vec3 has a base alignment of 4N. Array of scalars or vectors Each element has a base alignment equal to that of a vec4. Matrices Stored as a large array of column vectors, where each of those vectors has a base alignment of vec4. Struct Equal to the computed size of its elements according to the previous rules, but padded to a multiple of the size of a vec4. std140 layout 예제는 다음과 같다. (각 멤버들의 aligned offset 계산)layout (std140) uniform ExampleBlock{ // base alignment // aligned offset float value; // 4 // 0 vec3 vector; // 16 // 16 (offset must be multiple of 16 so 4-&amp;gt;16) mat4 matrix; // 16 // 32 (column 0) // 16 // 48 (column 1) // 16 // 64 (column 2) // 16 // 80 (column 3) float values[3]; // 16 // 96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148}; 이렇게 계산된 offset 값들과 함께, glBufferSubData 함수를 사용하여 변수 데이터를 각 offset에 채울 수 있다. std140 layout은 memory layout이 각 program에 대해서 정의되어진 uniform block 형태를 유지한다는 장점이 있다. uniform block을 정의하기전 layout (std140)을 추가함으로, OpenGL에게 이 uniform block이 이를 사용한다라는것을 알려준다. 버퍼를 채우기전에 offset을 쿼리하는 다른 방법이 두가지 존재 shared layout 는 위에서 보았음. packed layout: 컴파일러가 셰이더마다 다를 수 있는 uniform block에서 uniform 변수를 최적화할 수 있기 때문에 layout이 프로그램 간에 동일하게 유지된다는 보장은 없음(공유되지 않음). Using uniform buffers 먼저 glGenBuffers를 사용하여 UBO를 생성한다. buffer object를 가지게되면, 이것을 GL_UNIFORM_BUFFER 타겟에 바인딩하고, glBufferData 함수를 호출하여 충분한 메모리를 할당해준다. unsigned int uboExampleBlock;glGenBuffers(1, &amp;amp;uboExampleBlock);glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);glBufferData(GL_UNIFORM_BUFFER, 152, NULL, GL_STATIC_DRAW); // allocate 152 bytes of memoryglBindBuffer(GL_UNIFORM_BUFFER, 0); 이제 buffer에 데이터를 집어넣거나 수정하고 싶을 경우, uboExampleBlock을 바인딩하고 glBufferSubData함수를 사용하여 메모리를 수정한다. 우리는 오직 이 buffer를 한번 수정하면 이 버퍼를 사용하는 모든 셰이더들은 이 수정된 데이터를 사용하게 된다. OpenGL이 어떠한 uniform block이 어떠한 uniform buffer에 해당하는지 어떻게 아는지? OpenGL에는 uniform buffer를 연결시킬 수 있는곳에 정의된 binding points 가 존재 uniform buffer가 일단 생성되면, 이 binding points들 중 하나에 연결을 하고 또한 이를 shader의 uniform block을 동일한 binding point에 연결한다. 위 이미지에서 볼 수 있듯이, 여러 버퍼들을 여러 binding point에 바인딩 가능하다. uniform block이 동일한 uniform data를 공유할 수 있다.(위 이미지에서 binding point0 부분) 이 때 요구사항은 두 셰이더가 모두 같은 uniform block을 정의해야한다는 것. glUniformBlockBinding: shader &amp;lt;-&amp;gt; binding point 특정 binding point에 uniform block을 연결하기 위해 우리는 glUniform BlockBinding 함수를 호출한다. 파라미터1: program object 파라미터2: uniform block index 파라미터3: binding point uniform block index: shader에 정의된 uniform block의 location index glGetUniformBlockIndex 함수를 통해 얻을 수 있다. 이 함수는 program object를 받아들이고, uniform block의 이름을 받는다. 아래는 binding point를 2로 설정한것.unsigned int lights_index = glGetUniformBlockIndex(shaderA.ID, &quot;Lights&quot;);glUniformBlockBinding(shaderA.ID, lights_index, 2); 이를 각 shader에 반복해야한다. OpenGL 4.2 부터 binding point를 shader에 명확히 저장하는게 가능해짐. 이는 또 다른 layout 지정을 사용하여 glGetUniformBlockIndex 와 glUniformBlockBinding 함수를 사용하지 않아도 되게 해준다. 아래 코드는 binding point를 명확하게 설정한다. layout(std140, binding = 2) uniform Lights { ... };glBindBufferBase: binding point &amp;lt;-&amp;gt; UBO 그런 다음, UBO를 동일한 binding point에 바인딩해야하고 이는 glBindBufferBase나 glBindBufferRange 함수를 통해 수행될 수 있다.glBindBufferBase(GL_UNIFORM_BUFFER, 2, uboExampleBlock);// orglBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152); glBindBufferRange 이 함수는 추가적으로 offset 과 size를 받는다. 이는 지정한 uniform buffer의 영역만 binding point에 바인딩 가능 여러 다른 uniform block들을 하나의 ubo에 연결 가능하다. 데이터 추가 이제 모든 것이 세팅되었으므로, uniform buffer에 데이터를 추가할 수 있다. 모든 데이터를 하나의 바이트 배열로 추가하거나 glBufferSubData 함수를 사용하여 buffer의 특정 부분을 수정할 수 있다. uniform 변수 boolean을 수정하기 위해 다음과 같이 ubo를 수정할 수 있다. glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);int b = true; // bools in GLSL are represented as 4 bytes, so we store it in an integerglBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &amp;amp;b);glBindBuffer(GL_UNIFORM_BUFFER, 0); 이와 같은 과정을 uniform block 내부의 모든 다른 uniform 변수들에 적용 가능하지만, range 파라미터는 다를 것이다.A simple example 계속해서 사용해왔던 3가지 행렬 projection, view, model 이 행렬 중 오직 model 행렬만 자주 변경됨 동일한 행렬의 모음을 사용하는 여러 shader를 가지고 있다면, ubo를 사용하는 것이 좋다. projection, view 를 matrics라는 uniform block에 저장해보자 model은 자주 변경되므로, 이점이 없음 #version 330 corelayout (location = 0) in vec3 aPos;layout (std140) uniform Matrices{ mat4 projection; mat4 view;};uniform mat4 model;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0);} 4개의 큐브를 그리고, 각자 다른 shader program을 사용할것임. vertex shader는 같지만, shader마다 다른 오직 하나의 색만 출력하는 다른 fragment shader를 사용한다. 먼저, vertex shader의 uniform block을 binding point 0으로 설정(각 shader에 대해) unsigned int uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, &quot;Matrices&quot;);unsigned int uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, &quot;Matrices&quot;);glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, 0);glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, 0);glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, 0);glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, 0); 그다음 ubo를 생성하고 binding point 0에 바인딩한다.unsigned int uboMatricesglGenBuffers(1, &amp;amp;uboMatrices);glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);glBufferData(GL_UNIFORM_BUFFER, 2 * sizeof(glm::mat4), NULL, GL_STATIC_DRAW);glBindBuffer(GL_UNIFORM_BUFFER, 0);glBindBufferRange(GL_UNIFORM_BUFFER, 0, uboMatrices, 0, 2 * sizeof(glm::mat4)); 적절히 메모리를 설정, 그리고 binding point를 0으로 설정 그리고 buffer를 채우자 field of view 값을 상수로 유지(카메라 줌이 없으면)하고 싶다면, 한번만 정의하면 됨.(한번만 버퍼에 삽입) buffer object에 충분한 메모리를 할당했기 때문에 glBufferSubData함수를 사용하여 게임 루프에 들어가기 전에 projection 행렬을 저장할 수 있다 glm::mat4 projection = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);glBufferSubData(GL_UNIFORM_BUFFER, 0, sizeof(glm::mat4), glm::value_ptr(projection));glBindBuffer(GL_UNIFORM_BUFFER, 0); 각 렌더링 루프에서 오브젝트를 그리기 전에, buffer의 두 번째 공간에 view 행렬을 넣는다.glm::mat4 view = camera.GetViewMatrix();glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);glBufferSubData(GL_UNIFORM_BUFFER, sizeof(glm::mat4), sizeof(glm::mat4), glm::value_ptr(view));glBindBuffer(GL_UNIFORM_BUFFER, 0); 그리고 matrics uniform block을 가지고 있는 각 vertex shader는 이제 uboMatrix에 저장된 데이터를 가지고 있다. 그러므로 4개의 큐브를 그리면, 동일하게 projection, view 행렬이 유지된다. glBindVertexArray(cubeVAO);shaderRed.use();glm::mat4 model = glm::mat4(1.0f);model = glm::translate(model, glm::vec3(-0.75f, 0.75f, 0.0f)); // move top-leftshaderRed.setMat4(&quot;model&quot;, model);glDrawArrays(GL_TRIANGLES, 0, 36);// ... draw Green Cube// ... draw Blue Cube// ... draw Yellow Cube 설정하는 uniform은 model 행렬뿐이므로, 이전보다 약간의 uniform 호출을 줄였다.전체 소스 UBO 의 장점 한번에 uniform들을 설정하는 것은 하나 하나 설정하는 것보다 빨,ㅁ 여러 shader에 걸쳐있는 동일한 uniform을 수정하고 싶은 경우, 한번에 수정하기 쉬움. 아주 많은 uniform들을 사용할 수 있음. (OpenGL은 관리할 수 있는 uniform의 개수가 제한되어 있음. GL_MAX_VERTEX_UNIFORM_COMPONENTS 를 사용하여 확인 가능) uniform 개수의 한계치에 닿았을 때(ex. 스켈레톤 애니메이션)마다 ubo를 사용하면 좋다. 출처Advanced GLSL: 원문Advanced GLSL: 번역본" }, { "title": "[learn-opengl] Advanced OpenGL: Advanced Data", "url": "/posts/2022/03/20/01/05/opengl24/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-20 01:05:12 +0900", "snippet": "Advanced Data 버퍼들을 좀 더 흥미로운 방법과 texture들을 통해 shader에 많은 양의 data를 전달하는 흥미로운 방법이 존재한다. 이런 버퍼함수들과, 많은 양의 데이터를 저장하기 위해 텍스처 객체를 사용하는 방법을 다룰 것이다. OpenGL에서의 buffer는 특정 메모리를 관리하는것이다. 특정 buffer target에 바인딩하여 의미를 부여해준다. GL_ARRAY_BUFFER 에 바인딩 하면 이 버퍼는 vertex array buffer 이 동일한 버퍼를 다른 것에 바인딩 가능 GL_ELEMENT_ARRAY_BUFFER에 바인딩 가능. OpenGL은 내부적으로 target에 대해 buffer를 저장하고 이 buffer들을 따로 처리한다. glBufferData 지금까지 메모리를 할당해주고, 이 메모리에 데이터를 삽입해주는 glBufferData 함수를 사용하여 buffer 객체에 의해 관리되는 메모리를 채워 왔음. 여기에 NULL 값을 넣는다면, 이 함수는 메모리 할당만 해주고, 데이터를 채워 넣지 않는다. 이는 특정 메모리 크기를 예약하고, 나중에 이 buffer를 채우려고 할 경우에 유용하다. glBufferSubData 대신 glBufferSubData 함수를 사용하여, buffer의 특정 부분을 채우는 것 또한 가능하다. 이 함수는 buffer target, offset, data size, 실제 data를 파라미터로 받는다. offset 지정이 이 함수의 특징 이는 buffer메모리의 특정 부분에만 삽입/ 수정할 수 있도록 해준다. 이 buffer는 충분한 메모리가 할당되어 있어야하므로, glBufferSubData 함수를 호출하기 전에 glBufferData함수를 꼭 호출해야한다. glBufferSubData(GL_ARRAY_BUFFER, 24, sizeof(data), &amp;amp;data); // Range: [24, 24 + sizeof(data)]glMapBuffer pointer에게 buffer의 메모리를 요청하고 데이터를 buffer에 직접 복사하는 방법 이 함수를 사용하면 OpenGL은 현재 바인딩된 buffer의 메모리를 가리키고 있는 포인터를 리턴한다. float data[] = { 0.5f, 1.0f, -0.35f [...]};glBindBuffer(GL_ARRAY_BUFFER, buffer);// get pointervoid *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);// now copy data into memorymemcpy(ptr, data, sizeof(data));// make sure to tell OpenGL we&#39;re done with the pointerglUnmapBuffer(GL_ARRAY_BUFFER); glUnmapBuffer 함수를 통해 포인터 작업이 끝났다고 OpenGL에게 알려줄 수 있음. 이 포인터는 무효화됨. 이 함수는 OpenGL이 buffer에 데이터를 성공적으로 매핑할 수 있는 경우 GL_TRUE를 리턴한다.(unless the data store’s contents became corrupted during the time the data store was mapped) glMapBuffer 함수를 사용하는 것은 먼저 임시 메모리에 저장하지 않고 직접 매핑하기에 유용하다.Batching vertex attributes glVertexAttributePointer 함수를 사용하여 vertex array buffer 내용의 attribute layout을 지정할 수 있었음. vertex array buffer내부에 attribute들을 끼워넣었음.(위치, 법선, 텍스처 좌표들을 메모리에 서로 옆에 배치) 이와 같은 방법말고 다른 방법으로 지정할 수 있다. attribute 유형마다 큰 덩어리로 묶는 방법 파일로부터 vertex 데이터를 불러올 때, 일반적으로 위치, 법선, 텍스처 좌표 배열을 얻는다. 이를 하나의 큰 배열로 결합하는것은 큰 비용 각 유형으로 묶는것이 더 쉬움 glBufferSubData로 이를 쉽게 구현가능하다. float positions[] = { ... };float normals[] = { ... };float tex[] = { ... };// fill bufferglBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &amp;amp;positions);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &amp;amp;normals);glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &amp;amp;tex); 이를 통해 직접적으로 하나의 buffer에 배열을 옮길 수 있다. 또한 이렇게 할 경우, vertex attribute pointer를 수정해야 한다. glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)(sizeof(positions)));glVertexAttribPointer( 2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)(sizeof(positions) + sizeof(normals))); Stride 파라미터는 vertex attribute의 크기와 동일하다.(바로 옆에 같은 유형의 데이터가 있으므로) 이런 방법을 사용하는 것은 OpenGL에 즉각적인 효과는 없다. 단지 좀더 vertex attribue를 설정하는게 좀 더 체계적인 방법임. Copying buffers 하나의 버퍼에 데이터가 채워지면, 이 데이터들을 다른 버퍼와 공유, 복사 할 수 있다.glCopyBufferSubData 한 버퍼에서 다른 버퍼로 비교적 수월하게 복사함 이 함수의 프로토타입은 다음과 같다.void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size); readtarget, writetarget: 복붙할 버퍼 타겟 지정 buffer target: VERTEX_ARRAY_BUFFER =&amp;gt; VERTEX_ELEMENT_ARRAY_BUFFER 가능 그러면 현재 해당 버퍼 대상에 바인딩된 버퍼들이 영향을 받는다. 하지만 둘다 같은 buffer target일 경우.(같은 유형에 2개의 버퍼 바인딩 불가능) 추가적인 buffer target을 사용한다. GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER 이 새로운 버퍼 타겟에 버퍼들을 바인딩하고 파라미터로 넘겨주면 된다. 주어진 size만큼 readoffset에서부터 읽고 writeoffset을 시작지점으로 붙여넣는다. glBindBuffer(GL_COPY_READ_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, 8 * sizeof(float)); 또한 writetarget 버퍼만 바인딩하여 수행 가능float vertexData[] = { ... };glBindBuffer(GL_ARRAY_BUFFER, vbo1);glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, 8 * sizeof(float));출처Advanced Data: 원문Advanced Data: 번역본" }, { "title": "[learn-opengl] Advanced OpenGL: Cubemaps", "url": "/posts/2022/03/18/09/28/opengl23/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-18 09:28:02 +0900", "snippet": "Cubemaps 지금까지 2D 텍스처들을 사용해왔다. 다른 유형도 존재 이번에 다룰 유형은 여러 텍스처들을 하나의 텍스처로 매핑한 텍스처이다. 이를 cubemaps라고 부른다. Cubemap은 각 면을 형성하는 2D 텍스처들을 포함하고 있는 텍스처이다. 유용한 특성: 방향 벡터를 사용하여 인덱싱/ 샘플링될 수 있다는점. ex) 중앙에 위치해 있는 방향 벡터의 원점과 1x1x1의 단위 큐브 이 cubemap으로부터 텍스처를 샘플링하는 것은 다음 이미지 처럼 보인다. (주황색 = 방향벡터) 방향 벡터의 크기(magnitude)는 상관없다. 방향 벡터만 제공된다면, OpenGL이 방향과 맞닿는 해당 텍셀을 얻고, 적절히 샘플링된 텍스처 값을 리턴한다. 이러한 cubemap을 첨부한 큐브도형에서 cubemap을 샘플링하는 방향 벡터는 (보간된) vertex 위치와 비슷하다. 이 방법으로 우리는 이 큐브가 원점에 존재한다면, 이 큐브의 실제 위치 벡터들을 사용하여 cubemap을 샘플링할 수 있다. 그런 다음 이 큐브의 vertex 위치를 텍스처 좌표로서 얻을 수 있다. 그 결과 cubemap의 적절한 각 face를 접근할 수 있는 텍스처 좌표를얻을 수 있다. Creating a cubemap 적절한 텍스처를 생성하고, 적절한 텍스처 타겟에 바인딩해야한다. GL_TEXTURE_CUBE_MAP에 바인딩해야함. unsigned int textureID;glGenTextures(1, &amp;amp;textureID);glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); 6개의 텍스처를 생성해야하므로 6번 glTexImage2D 함수를 6번 호출해야한다. 텍스처 타겟 파라미터에 cubemap의 특정 면을 설정한다. Texture target Orientation GL_TEXTURE_CUBE_MAP_POSITIVE_X Right GL_TEXTURE_CUBE_MAP_NEGATIVE_X Left GL_TEXTURE_CUBE_MAP_POSITIVE_Y Top GL_TEXTURE_CUBE_MAP_NEGATIVE_Y Bottom GL_TEXTURE_CUBE_MAP_POSITIVE_Z Back GL_TEXTURE_CUBE_MAP_NEGATIVE_Z Front 이 enum 변수들은 연속적으로 증가하는 int 변수이므로, 반복문으로 처리 가능하다. POSITIVE_X 부터 시작하여 1씩증가시키자 int width, height, nrChannels;unsigned char *data;for(unsigned int i = 0; i &amp;lt; textures_faces.size(); i++){ data = stbi_load(textures_faces[i].c_str(), &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0); glTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data );} textures_faces 벡터는 cubemap 순서와 같게 텍스처의 경로를 가지고 있음. cubemap은 또한 wrapping, filtering method를 지정할 수 있다. glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); GL_TEXTURE_WRAP_R 은 텍스처의 3번째 차원(z와 동일)에 해당하는 R 좌표에 대한 wrapping method를 설정한다. 두 면의 접합된 부분에 있는 텍스처 좌표가 정확한 면을 가리키지 않을 수 있으므로(일부 하드웨어들의 제한에 의해) GL_CLAMP_TO_EDGE를 사용하여 면 사이를 샘플링할때마다, OpenGL이 항상 그들의 모서리 값을 리턴하도록 해준다. 그런 다음 이 cubemap을 사용할 오브젝트를 그리기 전에, 해당 텍스처 유닛을 활성화하고 렌더링하기 전에 cubemap을 바인딩한다. fragment shader 내부에서 샘플러 타입인 samplerCube를 사용해야한다. 그리고 vec3 타입의 방향벡터를 사용하여 샘플링할 것이다. in vec3 textureDir; // direction vector representing a 3D texture coordinateuniform samplerCube cubemap; // cubemap texture samplervoid main(){ FragColor = texture(cubemap, textureDir);} 이 큐브맵으로, skybox 같은 흥미로운것을 구현할 수 있다.Skybox Skybox는 전체 scene을 둘러싸고 주변 환경 6개의 이미지를 가지고 있는 큰 큐브이다. 보통 비디오게임에서 skybox의 예는 산, 구름, 별이 빛나는 밤하늘 이미지 이러한 skybox 이미지들은 온라인에서 충분히 찾을 수 있음 일반적으로 아래와 같은 패턴을 취한다. 이 6개의 면들을 접어서 큐브를만들려면 거대한 풍경을 시뮬레이션할 수 있는 완전히 텍스처가 입혀진 큐브를 얻을 수 있다. 이러한 형식을 가진 일부 리소스들은 6개의 이미지들로 추출해야한다. 대부분의 경우 6개의 단일 텍스처로 제공된다. 위 skybox는 여기에서 다운받을 수 있다.Loading a skybox 다운받은 텍스처의 경로가 들어있는 faces를 벡터로 받게 하자.unsigned int loadCubemap(vector&amp;lt;std::string&amp;gt; faces){ unsigned int textureID; glGenTextures(1, &amp;amp;textureID); glBindTexture(GL_TEXTURE_CUBE_MAP, textureID); int width, height, nrChannels; for (unsigned int i = 0; i &amp;lt; faces.size(); i++) { unsigned char *data = stbi_load(faces[i].c_str(), &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0); if (data) { glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data ); stbi_image_free(data); } else { std::cout &amp;lt;&amp;lt; &quot;Cubemap tex failed to load at path: &quot; &amp;lt;&amp;lt; faces[i] &amp;lt;&amp;lt; std::endl; stbi_image_free(data); } } glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE); return textureID;} 그다음, 이 함수를 호출하기전에 텍스처 경로를 vector에 선언vector&amp;lt;std::string&amp;gt; faces;{ &quot;right.jpg&quot;, &quot;left.jpg&quot;, &quot;top.jpg&quot;, &quot;bottom.jpg&quot;, &quot;front.jpg&quot;, &quot;back.jpg&quot;};unsigned int cubemapTexture = loadCubemap(faces); 이제 skybox를 cubemap으로서 불러오고, texture에 id를 저장했다. 이 것을 큐브에 바인딩할 수 있고, 언제든 배경으로 사용 가능하다. Displaying a skybox skybox는 cube 위에 그려지기 때문에 또 다른 VAO VBO가 필요하고, 다른 오브젝트들과 마찬가지로 vertex 세트가 필요하다. vertex data cubemap은 큐브의 위치(local positions)를 텍스처 좌표로 사용하여 샘플링될 수 있다. 큐브가 원점(0,0,0)에 위치해있을 때, 각 위치 벡터들은 원점으로부터의 방향벡터와 동일하다. 그러므로 텍스처 좌표는 필요없다. 이 skybox를 렌더링하기 위해 새로운 shader 세트가 필요하다. 오직 하나의 vertex attribute만 필요하므로, vertex는 간단하다. #version 330 corelayout (location = 0) in vec3 aPos;out vec3 TexCoords;uniform mat4 projection;uniform mat4 view;void main(){ TexCoords = aPos; gl_Position = projection * view * vec4(aPos, 1.0);} 이 vertex shader는 입력받은 위치 벡터를 fragment shader로 보낼 텍스처 좌표로 출력한다. fragment shader는 이들을 입력받아 samplerCube를 샘플링할 것이다. #version 330 coreout vec4 FragColor;in vec3 TexCoords;uniform samplerCube skybox;void main(){ FragColor = texture(skybox, TexCoords);} vertex attribute의 위치벡터를 방향벡터로 취하고, 이 것들을 cubemap으로부터 텍스처 값을 샘플링하기 위해 사용한다. 렌더링은 간단히 cubemap 텍스처를 바인딩하면, skybox sampler 는 자동적으로 skybox cubemap으로 채워지게 된다. 먼저 scene에 skybox를 그리고 depth 쓰기를 비활성화할 것이다. (항상 모든 오브젝트들의 뒤에 그려지게됨) glDepthMask(GL_FALSE);skyboxShader.use();// ... set view and projection matrixglBindVertexArray(skyboxVAO);glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);glDrawArrays(GL_TRIANGLES, 0, 36);glDepthMask(GL_TRUE);// ... draw rest of the scene 플레이어를 중앙으로 둘러싼 skybox를 원하므로, 플레이어의 움직임이 영향을 주지 않도록해야한다. 현재 view 행렬은 skybox의 모든 위치들을 회전, 확대, 이동 시키므로, 플레이어가 움직이면 cubemap 또한 움직이게 된다. view 행렬의 이동부분을 지워 움직임이 skybox 위치 벡터에 영향을 주지않도록 해야한다. 4x4 변환 행렬의 좌측 상단 3x3을 취하면, 이동부분을 제거할 수 있다. 회전변환은 유지됨. glm::mat4 view = glm::mat4(glm::mat3(camera.GetViewMatrix())); 이제 결과는 다음과 같다.An optimization 위 예제는, 모든 다른 오브젝트를 그리기 전에 맨 처음에 skybox를 렌더링한다. 이는 효율적이지 않음. fragment shader를 화면의 각 픽셀들마다 실행해야함. skybox의 보이는 부분이 작아도 그럼 early depth testing 을 사용하여 먼저 폐기해야한다. 그러므로, 마지막에 렌더링해야한다. depth 버퍼는 다른 오브젝트의 dpth로 채워지므로, early depth test를 통과한 skybox의 fragment들만 렌더링하면 된다. 이는 fragment shader 호출 횟수를 줄여준다. 문제는 skybox는 대부분 렌더링에 실패할 것이라는점.(1x1x1 큐브이므로) 만약 dpth testing 없이 렌더링하면 skybox가 다른 오브젝트들을 덮어씀 depth buffer에 트릭을 써, skybox가 depth 값을 최댓값인 1.0을 가지게 만들어서 앞에 드른 오브젝트들이 있는 곳은 test에 실패하도록 해야한다. 원근 분할(perspective division)이 vertex shader 가 실행된 후에 gl_Position 의 xyz 좌표를 w 요소로 나눔. 나눗셈 결과 z요소는 vertex의 depth 값과 동일하다. 그러므로, 출력 위치의 z 요소를 w와 동일하게 설정하면, z 값을 항상 1.0으로 만들 수 있다. z = w/w = 1.0 void main(){ TexCoords = aPos; vec4 pos = projection * view * vec4(aPos, 1.0); gl_Position = pos.xyww;} 이러면 NDC 좌표에서 z값은 1.0으로 depth. 값의 최댓값을 가지게 된다. 결과적으로 오브젝트들이 없는 곳에서만 렌더링 된다. depth 함수를 기본값인 GL_LESS 대신에 GL_LEQUAL로 설정해야한다. depth buffer는 skybox에 대해 1.0 값으로 채워지므로, skybox를 통과하게 만들기 위해 전체 소스Environment mapping 이제 하나의 텍스처에 전체 주변환경이 매핑되었다. 이런 환경을 가진 cubemap을 사용하여, 오브젝트에 빛을 반사 혹은 굴절 시키는 특성을 줄 수 있음. 이렇게 cubemap을 사용하는 기술을 environment mapping 기술이라고 부름 가장 많이 사용되는것: reflection, refraction Reflection reflection은 오브젝트(혹은 오브젝트의 어느 부분)이 주변환경을 반사하는 특성이다. 시점의 각도를 기반으로 오브젝트의 컬러들은 환경과 동일하게 설정될 수 있다. ex) 거울을 반사하는 오브젝트 . 반사벡터(reflection vector)를 계산하는 방법과 cubemap을 샘플링하기 위해 이 벡터를 사용하는 방법은 다음과 같다. view 방향 벡터 I 를 기반으로 오브젝트의 법선 벡터 N에 따른 반사 벡터 R을 계산한다. GLSL의 reflect 내장 함수를 사용하여 계산 가능 R은 cubemap을 인덱싱, 샘플링 하기 위한 방향 벡터로 사용된다. 최종 효과는 오브젝트가 skybox를 반사하는 것처럼 보인다. 이미 scene에 skybox를 가지고 있기 때문에 reflection을 생성하는 것은 그리 어렵지 않다. 컨테이너에 반사 속성을 주기 위해 컨테이너에 사용된 fragment shader를 수정할 것이다. #version 330 coreout vec4 FragColor;in vec3 Normal;in vec3 Position;uniform vec3 cameraPos;uniform samplerCube skybox;void main(){ vec3 I = normalize(Position - cameraPos); vec3 R = reflect(I, normalize(Normal)); FragColor = vec4(texture(skybox, R).rgb, 1.0);} I, R을 계산하고, R로 cubemap을 샘플링한다. fragment의 보간된 Normal과 Position 변수를 가지고 있으므로, vertex shader 또한 수정해야한다.#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;out vec3 Normal;out vec3 Position;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main(){ Normal = mat3(transpose(inverse(model))) * aNormal; Position = vec3(model * vec4(aPos, 1.0)); gl_Position = projection * view * vec4(Position, 1.0);} 법선 벡터를 법선 행렬로 변환 Position: world-space 위치 벡터, fragment 에서 view 방향 벡터를 계산하기 위해 법선을 vertex data에 추가하고 attribute pointer에도 수정해야한다. 또한 cameraPos 또한 넘겨줘야한다. 큐브맵을 렌더링하기전에 cubemap 텍스처도 바인딩해야한다.glBindVertexArray(cubeVAO);glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTexture);glDrawArrays(GL_TRIANGLES, 0, 36); 코드를 실행하면, 거울같은 컨테이너를 볼 수 있다. 둘러싼 skybox는 정확히 컨테이너에 반사되고 있다. 전체 소스 반사가 전체 오브젝트에 적용될 때, 이 오브젝트는 스틸이나 크롬같은 높은 반사율을 가진 material 오브젝트처럼 보인다. 하지만 실제 대부분의 모델들은 완전한 반사를하지 않는다. reflection maps: diffuse, specular map 들 처럼, 이 map은 fragment의 반사율을 결정하기 위해 샘플링할 수 있는 텍스처 이미지 이를 이용하여 모델의 어느 부분이 어떠한 세기를 가진 반사율을 보여줄지 결정할 수 있다. Refraction 환경 매핑의 또다른 형태는 refraction(굴절)이라고 불리고 반사와 비슷하다. 굴절은 material의 변화에 따라 빛의 방향이 달라지는 것을 말한다. 굴절은 흔히 빛이 직선으로 통과하지 않고 휘어지는 물과 같은 표면에서 볼 수 있다. 굴절: snell’s law view 벡터 I, 법선 벡터 N, 굴절벡터 R이 있다. view 벡터의 방향이 휘어진게 R로 Cubemap을 샘플링한다. 굴절은 GLSL의 refract 함수를 통해 쉽게 구현될 수 있다. 이 함수는 법선 벡터와 view 방향, 그리고 refractive indices 사이의 비율을 인자로 받는다. 굴절 index는 material의 빛이 왜곡/ 휘어지는 정도를 결정한다. 각 material들은 자신만의 고유한 refactive index를 가진다. 가장 많이 쓰이는 index는 아래 표에서 볼 수 있다. Material Refractive index Air 1.00 Water 1.33 Ice 1.309 Glass 1.52 Diamond 2.42 빛이 통과하는 두 material 사이의 비율을 계산하기 위해 이 index를 사용한다. 현재 예제의 경우 공기 =&amp;gt; 유리 라고 가정함 즉, 비율은 1.0/1.52 = 0.658 fragment를 다음과 같이 수정해보자 void main(){ float ratio = 1.00 / 1.52; vec3 I = normalize(Position - cameraPos); vec3 R = refract(I, normalize(Normal), ratio); FragColor = vec4(texture(skybox, R).rgb, 1.0);} 이 refractive index들을 바꾸면 다른 비주얼 결과를 만들 수 있다. 빛, 반사, 굴절, vertex 움직임의 올바른 결합을 통해 물 그래픽을 만들 수 있다. 물리적인 계산 결과를 위해, 물체를 떠날 때 빛을 다시 굴절시켜주어야한다. 지금은 간단히 한쪽 면만 굴절시킨다. Dynamic environment maps 지금은 skybox를 정적인 이미지의 결합으로 사용함. 즉, 움직이는 오브젝트를 반사/굴절 시키지않음 위 예제는 여러 오브젝트가 있어도 skybox만 비침 Framebuffer를 사용하면 6개의 다른 각도로 찍어 scene 텍스처 생성 가능 이는 비용이 비싸다. =&amp;gt; 성능적으로 큰 패널티 이를 동적 환경 매핑(dynamic environment mapping)이라함 주변환경을 cubemap으로 동적으로 생성, 이를 환경에 매핑 보통의 응용프로그램은 가능한 skybox를 사용하고, 가능한 경우 동적 환경 맵을 생성하기 위해 가능한 한 큐브맵을 미리 렌더링하려고 한다. 동적 환경 매핑을 성능저하 없이 실제 렌더링 응용 프로그램에서 작동하도록하려면, 많은 트릭이 필요 출처Cubemaps: 원문Cubemaps: 번역본" }, { "title": "[learn-opengl] Advanced OpenGL: Framebuffers", "url": "/posts/2022/03/18/08/26/opengl22/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-18 08:26:47 +0900", "snippet": "Framebuffers 지금까지 여러 스크린 버퍼들을 사용해왔다. color buffer: 컬러 값 작성 depth buffer: 깊이 정보 작성 stencil buffer: 특정 조건에 의해 해당 fragment를 폐기함. 이러한 버퍼들을 결합한 것을 Framebuffer라고 한다. 지금까지 우리가 수행했던 렌더링 작업들은 모두 기본 framebuffer에 있는 렌더 buffer의 위에 동작되었다. 기본 framebuffer는 윈도우 창을 생성할 때 생성된다.(glfw가 자동으로 생성) 자신만의 framebuffer를 생성하면, 렌더링하는 데에 추가적인 기능들을 얻을 수 있다. scene을 여러가지 framebuffer로 렌더링하면, 거울을 생성할 수 있고, 멋진 전처리 효과들을 생성할 수 있다.Creating a framebuffer glGenFramebuffers: 새로운 framebuffer 객체를 생성한다.(FBO)unsigned int fbo;glGenFramebuffers(1, &amp;amp;fbo); 먼저 framebuffer 객체를 생성하고 바인딩하여 framebuffer를 활성화 시킨다. 그 후에 조작을 하고, framebuffer를 언바인딩한다. framebuffer를 바인딩하기위해, glBindFramebuffer를 사용한다. glBindFramebuffer(GL_FRAMEBUFFER, fbo); GL_FRAMEBUFFER 타겟에 바인딩함으로써 이후에 나오는 모든 framebuffer 읽기, 쓰기 명령이 현재 바인딩된 framebuffer에 영향을 미친다. framebuffer를 GL_READ_FRAMEBUFFER, GL_DRAW_FRAMEBUFFER 타겟에 바인딩하여 읽기, 쓰기 명령을 구분할 수도 있다. GL_READ_FRAMEBUFFER에 바인딩된 framebuffer는 glReadPixel과 같은 모든 읽기 명령에 사용된다. GL_DRAW_FRAMEBUFFER에 바인딩된 framebuffer는 렌더링, 비우기, 다른 쓰기 연산에 대한 목적지로서 사용된다. 대부분의 경우 GL_FRAMEBUFFER에 바인딩하여 읽고 쓴다. framebuffer 요구사항 완전하게 만들기 위한 요구사항 최소한 하나의 buffer(color, depth 혹은 stencil buffer)를 첨부(attach)해야 합니다. 최소한 하나의 color attachment가 존재해야 합니다. 모든 attachment buffer들은 완전해야 합니다(메모리가 할당). 각 buffer들은 샘플의 갯수가 같아야 합니다. 샘플은 Anti Aliasing에서 다룬다. 요구사항에 따르면 framebuffer에 첨부할 것들을 생성하고 첨부해야한다. glCheckFramebufferStatus 함수에 GL_FRAMEBUFFER 를 인자로 넘겨주어 호출하여 준비가 다 되었는지 확인할 수 있다. GL_FRAMEBUFFER_COMPLETE 를 반환하면 성공하고, 그렇지 않으면 실패. if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)// execute victory dance 이후의 모든 렌더링 작업들은 이제 현재 바인딩된 framebuffer에 첨부된 것들에 렌더링하게 된다. 이 버퍼가 기본 framebuffer가 아니기 때문에, 렌더링 명령들이 윈도우 창의 출력에 아무런 영향을 주지않는다. 즉, off-screen rendering이라고 부른다. 모든 렌더링 작업들을 메인 윈도우 창에 나타내기 위해 0을 바인딩하여 다시 기본 frambuffer를 활성화 시켜야한다. glBindFramebuffer(GL_FRAMEBUFFER, 0); 모든 framebuffer 작업을 완료하면 framebuffer 객체를 제거해야한다. glDeleteFramebuffers(1, &amp;amp;fbo); 완전히 생성되었는지 확인하기전에 하나 이상의 첨부물을 framebuffer에 첨부해야한다. 첨부물(attachment)들은 framebuffer에서 buffer처럼 행동하는 메모리 위치(memory location)이다. 첨부물을 생성할 때, 두 개의 옵션을 가지고 있다. 텍스처 or render buffer objects Texture attachments 텍스처를 프레임 버퍼에 첨부할 때, 마치 모든 렌더링 명령이 일반 color/depth/stencil buffer인 것처럼 텍스처에 쓴다. 텍스처를 사용하면, 모든 렌더링 작업의 결과가 셰이더에서 쉽게 사용할 수 있는 텍스처 이미지로 저장된다는 장점이 있다. framebuffer의 텍스처를 생성하는 것은 일반적인 텍스처와 같다. unsigned int texture;glGenTextures(1, &amp;amp;texture);glBindTexture(GL_TEXTURE_2D, texture);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 차이점은 두가지, 화면의 크기와 동일한 크기(dimensions)로 설정한다. 텍스처의 데이터 매개변수로 NULL 을 전달한다. 오직 메모리만 할당하고 실제로 채워넣진 않는다. 텍스처를 채우는 것은 framebuffer에 렌더링할 때 수행 될 것이다. 대부분의 경우, wrapping methods 이나 mipmapping 를 필요로 하지 않으므로 신경쓰지 않는다. 전체화면을 더 작거나 큰 크기의 텍스처에 렌더링하고 싶다면, glViewport 함수를 다시 호출하여(framebuffer에 렌더링하기 전에) 텍스처의 새로운 크기의 인자로 넘겨주어야한다. (그러지 않으면 화면의 일부분만 텍스처에 그려짐) 이제 이 텍스처를 첨부해야한다.glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, 0); glFramebufferTexture2D target: 텍스처를 첨부할 타겟인 framebuffer(draw, read or both) attachment: 첨부될 첨부물의 타입, 여기서는 color, 마지막에 붙은 0은 하나 이상의 color 첨부물을 첨부 할 수 있다는 것을 암시한다. textarget: 첨부하기 원하는 텍스처 유형 texture: 첨부할 실제 텍스처 level: Mipmap 레벨, 0으로 유지할것임. color 말고 depth, stencil 텍스처를 첨부할 수 있다. depth type: GL_DEPTH_ATTACHMENT depth format, internalformat: GL_DEPTH_COMPONENT stencil type: GL_STENCIL_ATTACHMENT stencil format: GL_STENCIL_INDEX depth, stencil 버퍼를 하나의 텍스처로 만들어 첨부 가능 텍스처의 각 32비트 값은 24비트의 depth 정보, 8비트의 stencil 정보로 이루어짐 GL_DEPTH_STENCIL_ATTACHMENT를 사용하고, 텍스처 형식을 depth 와 stencil 값을 결합한 것으로 설정한다. glTexImage2D( GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, 800, 600, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, 0); Renderbuffer object attachments Renderbuffer 객체는 텍스처 다음에 새로나온 framebuffer 첨부물의 유형이다. 그래서 텍스처는 옛날에만 쓰였던 첨부물 텍스처 이미지와 마찬가지로 이는 실제 buffer다 ex) 바이트, 정수형, 픽셀 등의 배열 이 객체는 읽기 불가능한 대신, framebuffer에대한 off-screen 렌더링에서 텍스처보다 더 최적화되어 있다. Renderbuffer객체는 모든 렌더링 데이터들을 그들의 buffer에 텍스처 형식으로 변환하지 않고 직접적으로 저장한다. 따라서 좀 더 빠른 저장공간을 형성 하지만, renderbuffer 객체는 일반적으로 쓰기만 가능하다. 그들로부터 데이터를 읽을 수 없다.(그러므로 메모리 최적화를 수행할 수 있음) 느리지만, glReadPixels 함수를 통해 현재 바인딩된 framebuffer로부터 픽셀의 특정 영역을 읽을 수 있긴하다. (첨부물 자체에서 직접적으로 읽어오는것은 아님) 데이터가 기본(native) 포맷이기 때문에 데이터를 쓰거나 다른 버퍼에 데이터를 복사할 때 매우 빠르다. 따라서 버퍼 전환과같은 작업들은 이 객체를 사용할 때 빠르다. glfwSwapBuffers함수 또한 renderBuffer 객체로 구현되어있다. 단순히 렌더 버퍼 이미지에 쓰고, 마지막에 다른 이미지로 교체한다. 생성은 다음과 같이 한다. unsigned int rbo;glGenRenderbuffers(1, &amp;amp;rbo); 그리고 비슷하게 바인딩한다. 이후 모든 renderbuffer 작업들은 현재 rbo에 영향을 미친다.glBindRenderbuffer(GL_RENDERBUFFER, rbo); Renderbuffer 객체가 일반적으로 쓰기만 가능하기 때문에 종종 depth, stencil 첨부몰로 사용된다.(대부분 값을 읽을 필요가 없음) 하지만, test시에는 값을 읽어야함. 그럼에도 불구하고, 이 값을 샘플링할 필요가 없으므로, 렌더 버퍼 객체를 사용하는것은 적합함. 샘플링하지 않을 때는 렌더링 버퍼 객체가 일반적으로 더 최적하므로 더 선호됨. Depth, Stencil renderbuffer객체 생성은 glRenderbufferStorage 함수를 호출하여 수행된다. GL_DEPTH24_STENCIL8을 설정하여 24/8 비트로 나눔 glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600); 첨부는 다음과 같이 한다.glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); Renderbuffer 객체는 framebuffer 프로젝트에 최적화를 제공해준다. 주의: 샘플링할 필요가 없다면 그 특정 버퍼에 render buffer를 사용하는것이 현명하다. 하지만, buffer로부터 color 값이나 깊이 값 처럼 데이터를 sample 해야 한다면, 텍스처를 사용해야한다. Rendering to a texture 생성한 framebuffer 객체에 첨부된 color 텍스처에 scene 을 렌더링할 것이다. 그런 다음 이 텍스처를 화면을 가득채운 간단한 사각형에 그릴 것이다. 시각적 출력은 앞에서와 동일하다 하지만 모든것이 하나의 사각형 위에 그려진다. 먼저 framebuffer 객체를 생성하고 바인딩하자. unsigned int framebuffer;glGenFramebuffers(1, &amp;amp;framebuffer);glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); 그 다음, framebuffer에 color 첨부물로 텍스처 이미지를 첨부할것이다. 데이터 지정 x, 윈도우 창과 크기 같음 // generate textureunsigned int textureColorbuffer;glGenTextures(1, &amp;amp;textureColorbuffer);glBindTexture(GL_TEXTURE_2D, textureColorbuffer);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 800, 600, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);glBindTexture(GL_TEXTURE_2D, 0);// attach it to currently bound framebuffer objectglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0); 또한 OpenGL이 depth testing(또는 stencil testing)을 할 수 있도록 depth와 stencil을 추가할 것이다. 이는 renderbuffer로 생성할 것이다. unsigned int rbo;glGenRenderbuffers(1, &amp;amp;rbo);glBindRenderbuffer(GL_RENDERBUFFER, rbo);glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 800, 600);glBindRenderbuffer(GL_RENDERBUFFER, 0); 이 renderbuffer 객체에 충분한 메모리가 할당되면, renderbuffer를 언바운딩하자 그 후, 이 객체를 첨부하자 glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); 그런 다음, 완성됬는지 확인하자if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout &amp;lt;&amp;lt; &quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot; &amp;lt;&amp;lt; std::endl;glBindFramebuffer(GL_FRAMEBUFFER, 0); 마지막으로 framebuffer를 언바운딩하여, 우연히 잘못된 framebuffer에 렌더링되는일이 발생하는것을 방지하자. 이제 framebuffer가 완성됬으므로, 기본 framebuffer 대신 이 객체를 바운딩하면된다. 그러면, 이 후의 모든 명령은 현재 바운딩된 framebuffer에 영향을 미친다. 모든 depth, stencil 작업들은 현재 바인딩된 framebuffer의 depth, stencil 첨부물로부터 값을 읽는다.(이용가능할 경우) 만약 depth 버퍼를 첨부하지 않았다면, depth testing 작업들은 동작하지 않는다. 하나의 텍스처에 scene을 그리기 위해 다음과 같은 단계를 거친다. 활성화된 framebuffer로서 바인딩된 새로운 framebuffer에 평상시대로 scene을 렌더링한다.. 기본 framebuffer를 바인딩한다. 새 프레임 버퍼의 색상 버퍼를 텍스처로 사용하여 전체 화면에 걸쳐있는 사각형(quad)을 그린다. depth testing 강좌에서 사용했던 것과 동일한 scene을 그릴 것이다. 이번에는 이 컨테이너 텍스처를 사용한다. 사각형을 그리기 위해 간단한 shader 세트를 작성할 것이다. 행렬 변환을 포함시키지 않을 것이며, vertex 좌표만을 제공할 것이다. vertex shader는 다음과 같다. #version 330 corelayout (location = 0) in vec2 aPos;layout (location = 1) in vec2 aTexCoords; out vec2 TexCoords; void main() { gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); TexCoords = aTexCoords; } fragment shader는 다음과 같다.(오직 텍스처를 sample 함) #version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D screenTexture;void main(){ FragColor = texture(screenTexture, TexCoords);} 그런 다음 화면 쿼드에 대한 VAO를 만들고 구성하는 것은 사용자 몫이다. 프레임 버퍼 과정의 단일 렌더링은 다음과 같은 구조이다.// first passglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);glClearColor(0.1f, 0.1f, 0.1f, 1.0f);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // we&#39;re not using the stencil buffer nowglEnable(GL_DEPTH_TEST);DrawScene();// second passglBindFramebuffer(GL_FRAMEBUFFER, 0); // back to defaultglClearColor(1.0f, 1.0f, 1.0f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);screenShader.use();glBindVertexArray(quadVAO);glDisable(GL_DEPTH_TEST);glBindTexture(GL_TEXTURE_2D, textureColorbuffer);glDrawArrays(GL_TRIANGLES, 0, 6); 주의 각 framebuffer들은 그들만의 버퍼를 가지고 있으므로, glClear로 각 버퍼를 비워주어야한다. 사각형을 그릴때 간단한 사각형을 그리므로 depth testing 을 신경쓰지 않아도 된다.(비활성화, 그리고 일반적인 scene을 그릴때 다시 활성화) 결과는 다음과 같다. 왼쪽은 동일한 결과.(하지만 이는 그저 사각형(quad)) 이 scene을 wireframe으로 렌더링 한다면, 오른쪽 처럼 하나의 사각형만 그려진다. 전체 소스 이는 하나의 텍스처 이미지로서 완전히 렌더링 된 scene을 자유롭게 접근할 수 있기 때문에 fragment shader에서 흥미로운 효과들을 생성할 수 있다. 이런 효과를 post-processing(전처리)효과라고 부른다. Post-processing scene texture를 조작해보자.Inversion(반전) Fragment shader에서 렌더링 출력의 각 컬러들에 접근하여 컬러를 반전해보자 단순히 컬러에 1을 빼서 이 효과를 얻을 수 있다. void main(){ FragColor = vec4(vec3(1.0 - texture(screenTexture, TexCoords)), 1.0);} frag shader 한줄에 의해 모두 반전된 컬러를 가지고 있다.Grayscale 단순히 색을 평균내어 이 효과를 얻을 수 있다.void main(){ FragColor = texture(screenTexture, TexCoords); float average = (FragColor.r + FragColor.g + FragColor.b) / 3.0; FragColor = vec4(average, average, average, 1.0);} 정확한 그레이 스케일은 아래와 같이 가중치를 둔다. 사람의 눈은 녹색에 예민, 파란색에 덜 예민 void main(){ FragColor = texture(screenTexture, TexCoords); float average = 0.2126 * FragColor.r + 0.7152 * FragColor.g + 0.0722 * FragColor.b; FragColor = vec4(average, average, average, 1.0);}Kernel effects 텍스처 이미지로 scene을 그리는 것의 또 다른 장점 해당 fragment에 국한되지 않은 텍스처의 다른 부분에서 색상 값을 샘플링 할 수 있다는 것이다. Kernel(convolution matrix)은 주변 픽셀 값에 커널 값을 곱한 후, 현재 값을 모두 더하여, 하나의 값을 형성하는 현재 픽셀을 중심으로하는 작은 행렬이다. 현재 픽셀의 주변 방향의 텍스처 좌표에 작은 오프셋을 추가하고 커널을 기반으로 결과를 결합한다. 커널은 아래와 같은 행렬이다. \\[\\begin{bmatrix}2 &amp;amp; 2 &amp;amp; 2 \\\\ 2 &amp;amp; -15 &amp;amp; 2 \\\\ 2 &amp;amp; 2 &amp;amp; 2 \\end{bmatrix}\\] 이 커널은 8개의 둘러싸인 픽셀 값들을 취하고, 이들을 2와 곱한다. 그리고 현재 픽셀에 -15를 곱한다. 이 예제 커널은 주변 픽셀에 커널에서 결정된 여러 가중치를 곱하고 현재 픽셀에 큰 음수 가중치를 곱하여 결과의 ​​균형을 맞춥니다. 대부분 커널은 합이 1로 되게한다. 그렇지 않으면 결과 텍스처가 원래보다 밝거나 어둡게된다. 이 커널은 post-processing에 대해 아주 유용한 도구이다. kernel을 지원하기 위해서는 fragment를 약간 수정해야한다. 우리가 사용할 각 kernel은 3x3 kernel이라고가정한다.(대부분 그럼) const float offset = 1.0 / 300.0;void main(){ vec2 offsets[9] = vec2[]( vec2(-offset, offset), // top-left vec2( 0.0f, offset), // top-center vec2( offset, offset), // top-right vec2(-offset, 0.0f), // center-left vec2( 0.0f, 0.0f), // center-center vec2( offset, 0.0f), // center-right vec2(-offset, -offset), // bottom-left vec2( 0.0f, -offset), // bottom-center vec2( offset, -offset) // bottom-right ); float kernel[9] = float[]( -1, -1, -1, -1, 9, -1, -1, -1, -1 ); vec3 sampleTex[9]; for(int i = 0; i &amp;lt; 9; i++) { sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i])); } vec3 col = vec3(0.0); for(int i = 0; i &amp;lt; 9; i++) col += sampleTex[i] * kernel[i]; FragColor = vec4(col, 1.0);} 먼저 각 텍스처 좌표에 대한 9 개의 vec2 offset 배열을 생성한다. 이 offset은 간단히, 원하는대로 정할 수 있는 상수 값이다. 그런다음 커널을 정의한다. 이런 패턴의 커널을 sharpen kernel 이라고 한다. 효과는 다음과 같다Blur blur 효과를 내는 커널은 아래와 같다.\\[\\begin{bmatrix} 1 &amp;amp; 2 &amp;amp; 1 \\\\ 2 &amp;amp; 4 &amp;amp; 2 \\\\ 1 &amp;amp; 2 &amp;amp; 1 \\end{bmatrix} / 16\\] 모든 값의 합이 16이므로, 결과는 매우 밝을을 것이므로, 16으로 나눠야한다. 커널 배열을 다음과 같이 설정하자 float kernel[9] = float[]( 1.0 / 16, 2.0 / 16, 1.0 / 16, 2.0 / 16, 4.0 / 16, 2.0 / 16, 1.0 / 16, 2.0 / 16, 1.0 / 16); 이제 아래와 같이 보인다. 이런 효과는 주인공이 안경을 쓰지 않을 때 혹은 술취했을 때 연출할 때 쓰기 좋다. 또한 블러는 색을 부드럽게하는데 유용한 도구가 될 수 있다. 이러한 작은 kernel을 구현함으로써 손쉽게 post-processing 효과를 낼 수 있다. Edge detection 커널은 다음과 같다.\\(\\begin{bmatrix} 1 &amp;amp; 1 &amp;amp; 1 \\\\ 1 &amp;amp; -8 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 \\end{bmatrix}\\) 이 커널은 모든 모서리를 강조하고, 나머지를 어둡게한다. 우리가 이미지의 모서리를 신경써야 할 때 유용하게 사용할 수 있다. 이와 같은 커널들이 포토샵같은 툴에서 이미지 조작 툴/필터로 사용된다. 병렬 기능으로 fragment들을 쉽게 처리할 수 있는 그래픽카드 덕분에, 실시간으로 픽셀마다 이미지를 조작할 수 있다. 그러므로 이미지 편집 도구들은 이미지 처리에 대해 그래픽 카드를 더 자주 사용하는 경향이 있다. 출처FramebuffersFramebuffers" }, { "title": "[learn-opengl] Advanced OpenGL: Face culling", "url": "/posts/2022/03/18/07/23/opengl21/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-18 07:23:40 +0900", "snippet": "Face culling 큐브를 생각해보자 어느 방향에서 볼 수 있는 최대 면들의 개수는 3개이다. 다른 면들은 보이지 않는다. 이들을 폐기하면, 50%이상 비용을 절약할 수 있다. 문제는 view 입장에서 보이지 않는 면인지 어떻게 알 수 있는가이다. 닫힌 하나의 도형(closed shape)를 생각해보자 각 면들은 2개의 양쪽면을 가지고 있다. 한쪽은 사용자와 대면하고 있고, 다른 한쪽은 사용자와 등지고 있다. Face Culling: viewer와 대면하고 있는 면들만 렌더링하는 것 OpenGL은 모든 면들을 확인하여, front facing 한 면은 렌더링하고 back facing한 모든 면들은 폐기하여 fragment shader 호출을 많이 줄여준다. (fragment shader 호출은 비용이 많이든다) OpenGL은 이에 대해 vertex 데이터의 winding 순서를 분석하는 똑똑한 방법을 사용한다. Winding order 삼각형 vertex들을 정의할 때 시계방향 혹은 반시계방향으로 특정 순서를 정의한다. 3개의 vertex들을 삼각형의 중앙을 바라보았을 때의 winding 순서로 지정한다. 아래 코드가 위 이미지를 설명한다. float vertices[] = { // clockwise vertices[0], // vertex 1 vertices[1], // vertex 2 vertices[2], // vertex 3 // counter-clockwise vertices[0], // vertex 1 vertices[2], // vertex 3 vertices[1] // vertex 2 }; 이처럼 3개의 vertex들은 winding 순서를 가진다. 이 정보를 사용하여 OpenGL은 front-facing, back-facing인지를 결정한다. 기본값으로 반시계 방향으로 정의된 삼각형들이 front-facing 으로 처리됨 실제 winding 순서는 vertex shader가 실행되고 난 후의 rasterization 단계에서 계산된다는것. 그러므로 vertex들은 viewer 관점에서 보이게된다. viewer가 대면하고 있는 모든 삼각형 vertex들은 확실히 정확한 winding 순서로 이루어져 있다. 하지만 다른 면의 삼각형 vertex들은 winding 순서가 반대로 된채로 렌더링된다.(반시계 방향으로 정점을 지정했음에도 불구하고) 그 결과 대면하고 있는 삼각형들은 front-facing 삼각형으로 보이게 되고 뒤에 있는 삼각형들은 back-facing 삼각형으로 보이게 된다. 뒤에 있는 우리한테 보이지 않는 삼각형은 폐기된다. Face culling 기본적으로 비활성화되어 있는 OpenGL의 face culling 옵션을 사용해보자 반시계방향으로 winding 순서로 수정해야한다. 수정된 vertex data glEnable GL_CULL_FACE 옵션을 활성화 시켜주자glEnable(GL_CULL_FACE); 이 시점부터 front face 가 아닌 모든 면들은 폐기된다. fragment 렌더링하는데 50% 이상의 성능을 절약했다. 하지만 이는 큐브같은 닫힌 도형에서만 동작한다. blend 에서 다루었던 잔디를 그릴 때에는 face culling을 비활성화 해야한다. 이들은 앞, 뒤가 전부 보여야하기 때문이다. glCullFace 다음 함수로 폐기하고 싶은 유형을 변경할 수 있다.glCullFace(GL_FRONT); glCullFace 함수는 3가지 가능한 옵션들을 가짐. GL_FRONT GL_BACK GL_FRONT_AND_BACK 기본값은 BACK glFrontFace 이 함수로 face 방향을 설정할 수 있다.glFrontFace(GL_CW); 기본값은 GL_CCW, 시계방향으로 변경하여 winding 순서를 반대로 해보자 glEnable(GL_CULL_FACE);glCullFace(GL_BACK);glFrontFace(GL_CW); 결과는 후면들만 렌더링됨 아래 코드는 동일한 결과를 내놓는다. 전면을 폐기 glEnable(GL_CULL_FACE);glCullFace(GL_FRONT); 이처럼 face culling 은 적은 비용으로 성능을 증가시킬 수 있다. 어떠한 오브젝트를 face culling 해야하는지 알아야하며, 어떠한 오브젝트가 수행하면 안되는지 알아야한다(전후면 둘다 렌더링 필요할 경우). 출처Face cullingFace culling" }, { "title": "[learn-opengl] Advanced OpenGL: Blending", "url": "/posts/2022/03/18/04/12/opengl20/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-18 04:12:05 +0900", "snippet": "Blending OpenGL에서 블렌딩은 오브젝트 내의 투명도(transparency)를 구현하는 기술로 알려져 있음. 투명도: 단색(solid color)를 가지지 않는 오브젝트에 관한것이지만, 오브젝트 자체와 그 뒤에 있는 오브젝트의 색상을 다양한 강도로 조합한것. 유리에는 자체 색상이 있지만, 결과적으로는 유리 뒤에 있는 모든 오브젝트의 색상이포함된다. 여러 색상(다른 오브젝트들)을 단일 색상으로 혼합하기 때문에 Blending 으로 부름. 투명도는 통과해서 볼 수 있게 한다. 투명한 오브젝트(Transparent objects)는 완전히 투명(모든 색상 통과)하거나 부분적으로 투명(일부 자신의 색상또한 보여줌)하다. 투명도는 색상의 alpha 값으로 정의된다. 색상 벡터의 4번째 요소 ex) a = 0.5는 50%의 투명도 일부 텍스처는 텍셀당 알파 값이 포함된 알파 채널이 포함되어 있음. - 이 알파 값은 텍스처의 어느 부분이 투명성을 갖고 있는지, 얼마만큼의 텍스처가 있는지 정확히 알려줌. - 아래 창에서 유리는 0.25, 바깥쪽 코너는 0.0이다. - 유리부분은 75%의 투명도이므로, 이를 통해 본 배경은 더 빨간색으로 보임 완전히 투명(fully transparent) 또는 완전히 불투명(fully opaque)에 대해 다룬다. Discarding fragments 일부 effects는 부분 투명도를 신경쓰지 않지만, 텍스처의 색상 값을 기준으로 무언가를 표시하거나 전혀 표시하지 않으려는 경우도 았다. 잔디 같은것을 만들려고하면, 2d quad 에 잔디 텍스처를 붙이고, 그 quad를 장면에 배치한다. 잔디는 실제로 이와같은 모양이 아니므로, 잔디 텍스처의 일부분만 표시하고, 나머지는 무시해야한다. 아래의 잔디 텍스처는 완전 불투명과 완전 투명이 섞여 있다. 투명한 배경/ 불투명한 잔디 이 텍스처를 불투명한 부분만 보여줘야한다. 따라서 투명한 부분을 나타내는 fragment를 폐기해야한다. 알파 채널 텍스처 로드 stb_image는 알파채널이 있는 경우 알아서 설정한다. OpenGL은 다음과 같이 텍스처 생성할 때 알려줘야한다.glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); 이제 셰이더도 다음과 같이 vec4로 수정해야함void main(){ // FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0); FragColor = texture(texture1, TexCoords);}잔디 추가 예제는 depth testing의 예제에서 코드를 추가할것이다. 잔디들의 위치 벡터들을 선언하자 vector&amp;lt;glm::vec3&amp;gt; vegetation;vegetation.push_back(glm::vec3(-1.5f, 0.0f, -0.48f));vegetation.push_back(glm::vec3( 1.5f, 0.0f, 0.51f));vegetation.push_back(glm::vec3( 0.0f, 0.0f, 0.7f));vegetation.push_back(glm::vec3(-0.3f, 0.0f, -2.3f));vegetation.push_back(glm::vec3( 0.5f, 0.0f, -0.6f)); 잔디는 단일 쿼드로, 복잡한 모델인 3D로 표현하는 것보다 효율적이다. 여러 개의 회전된 잔디 쿼드를 추가하면 비슷하게 보인다. 잔디 텍스처가 쿼드 객체에 추가되므로, 다른 VAO를 다시 작성해야함. 적절한 정점 속성 포인터를 설정 glBindVertexArray(vegetationVAO);glBindTexture(GL_TEXTURE_2D, grassTexture);for(unsigned int i = 0; i &amp;lt; vegetation.size(); i++){ model = glm::mat4(1.0f); model = glm::translate(model, vegetation[i]); shader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 6);} 이제 실행하면 다음과 같다. 문제: OpenGL이 기본적으로 알파 값을 처리할 것인지, 버릴 것인지 모르기 때문에 발생 셰이더를 사용하여, fragment를 폐기하자 discard: fragment 를 폐기함. 특정 임계값보다 작으면 폐기하도록할 수 있음. #version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main(){ vec4 texColor = texture(texture1, TexCoords); if(texColor.a &amp;lt; 0.1) discard; FragColor = texColor;} 위 셰이더는 거의 투명하지 않은 fragment 만 렌더링하게 해준다.(아래 이미지 참고) GL_REAPEAT로 텍스처 래핑 방식을 설정하면, 다음 repeat 값으로 border를 보간한다. 만약 투명한 값이 있을 경우, 투명한 값과 단색 값으로 보간된 투명값을 가져올 수 있다. 그려면 약간 반투명한 색 테두리가 텍스처 쿼드에 래핑될 수 있다. 이를 방지하기 위해 래핑 방식을 GL_CLAMP_TO_EDGE로 설정해야한다.```cppglTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);```Blending 위처럼 폐기하는것은 반 투명 이미지를 렌더링할 때 유연성을 주지 못한다. 서로 다른 투명도로 이미지를 렌더링하려면 블렌딩을 활성화해야한다. GL_BLEND를 활성화해 블렌딩을 활성화 할 수 있다. glEnable(GL_BLEND); 블렌딩을 활성화 했으므로, 혼합되어야 하는 방법을 알려줄 필요가 있다. OpenGL은 다음 방정식으로 블렌딩을 수행한다. $\\bar{\\color{green}C}_{source}$: 소스 색상 벡터, 텍스처에서 온 색 벡터 $\\bar{\\color{red}C}_{destination}$: 목적지 색상 벡터, 현재 컬러 버퍼에 저장된 색상 벡터 $\\color{green}F_{source}$: 소스 factor 값, 소스 색상에 대한 알파 값의 영향을 설정 $\\color{red}F_{destination}$: 대상 factor 값, 알파 값이 대상 색상에 미치는 영향을 설정한다. \\[\\begin{equation}\\bar{C}_{result} = \\bar{\\color{green}C}_{source} * \\color{green}F_{source} + \\bar{\\color{red}C}_{destination} * \\color{red}F_{destination}\\end{equation}\\] fragment shader가 실행되고 모든 테스트가 통과된 후, 이 혼합 방정식이 프래그먼트의 색상 출력과 현재 색상 버퍼에 있는 것들에 영향을 미친다.예시 붉은 square에 반투명한 녹색 사격형을 그려보자. 빨간색 사각형은 대상 색상이 됨(칼라 버퍼의 첫번째) 녹색의 알파가 60%라고 하면 기여도는 알파값과 동일한 기여도를 부여하는것이 좋으므로 식은 다음과 같다.\\[\\begin{equation}\\bar{C}_{result} = \\begin{pmatrix} \\color{red}{0.0} \\\\ \\color{green}{1.0} \\\\ \\color{blue}{0.0} \\\\ \\color{purple}{0.6} \\end{pmatrix} * \\color{green}{0.6} + \\begin{pmatrix} \\color{red}{1.0} \\\\ \\color{green}{0.0} \\\\ \\color{blue}{0.0} \\\\ \\color{purple}{1.0} \\end{pmatrix} * (\\color{red}{1 - 0.6}) \\end{equation}\\] 결과는 다음과 같다.glBlendFunc glBlendFunc(GLenum sfactor, GLenum dfactor) 두 매개변수로 소스 및 대상 factor에 대한 옵션을 설정할 수 있다. 소스 factor와 대상 factor는 다음과 같은 값을 가질 수 있다. GL_ZERO: 0 GL_ONE: 1 GL_SRC_COLOR: 소스 색상 GL_ONE_MINUS_SRC_COLOR: 1- 소스 색상 GL_DST_COLOR: 대상 색상 GL_ONE_MINUS_DST_COLOR: 1- 대상 색상 GL_SRC_ALPHA: 소스 알파 GL_ONE_MINUS_SRC_ALPHA: 1 - 소스 알파 GL_DST_ALPHA: 대상 알파 GL_ONE_MINUS_DST_ALPHA: 1 - 대상 알파 GL_CONSTANT_COLOR: 상수 색상 GL_ONE_MINUS_CONSTANT_COLOR: 1- 상수 색상 GL_CONSTANT_ALPHA: 상수 알파 GL_ONE_MINUS_CONSTANT_ALPHA: 1 - 상수 알파 GL_SRC_ALPHA_SATURATE: 소스 알파 채도(i,i,i,1) 위 사각형 예제를 다음과 같이 glBlendFunc 함수로 나타낼 수 있다. glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);glBlendFuncSeperate glBlendFuncSeperate 를 사용해 RGB 및 알파 채널에 대해 다른 옵션을 개별적으로 설정할 수 있다. 아래는 RGB는 이전과 같지만, 알파는 원본 값의 영향을 받도록 하는 코드이다. glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);glBlendEquation 방정식 연산자에 더 많은 유연성을 줌. GL*FUNC_ADD: the default, adds both colors to each other:\\(\\bar{C}*{result} = \\color{green}{Src} + \\color{red}{Dst}\\) GL*FUNC_SUBTRACT: subtracts both colors from each other:\\(\\bar{C}*{result} = \\color{green}{Src} - \\color{red}{Dst}\\) GL*FUNC_REVERSE_SUBTRACT: subtracts both colors, but reverses order:\\(\\bar{C}*{result} = \\color{red}{Dst} - \\color{green}{Src}\\) GL*MIN: takes the component-wise minimum of both colors:\\(\\bar{C}*{result} = min(\\color{red}{Dst}, \\color{green}{Src})\\) GL*MAX: takes the component-wise maximum of both colors:\\(\\bar{C}*{result} = max(\\color{red}{Dst}, \\color{green}{Src})\\) 보통 기본값인 ADD 사용한다.(가장 선호됨.)Rendering semi-transparent textures 반투명 윈도우를 여러개 추가할것이다. 잔디 대신 투명 창 텍스처를 사용할 것임. 먼저 초기화하는 동안 블렌딩을 활성화하고, 적절한 블렌딩 함수를 설정한다.glEnable(GL_BLEND);glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 블렌딩을 활성화했으므로, frag를 폐기할 필요가 없어서 fragment shader를 다음과 같이 되돌린다.#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main(){ FragColor = texture(texture1, TexCoords);} 현재 fragment 색상과 알파 값에 따라 현재 칼라 버퍼에 결합된다. 이제 다음과 같은 결과가 나온다. 여기서 문제가 하나 생긴다. 앞에있는 창에서 뒷부분을 볼 수 없는것. 이는 깊이테스트 때문에 일어난다. 깊이 테스트는 frag가 투명도를 신경쓰지 않아, 투명부분이 다른 값으로 깊이 버퍼에 덮어씌워진다. 그 결과, 투명도에 관계없이 창의 투명도를 무시하고, 다른 불투명 오브젝트와 마찬가지로 깊이테스트가 수행된다. 해결방법 가장 먼 곳에서 가장 가까운 곳으로 수종으로 정렬하고 따라 그려야한다. 잔디 잎같은것은 단순히 폐기하여 이런 문제를 신경쓰지 않게 할 수 있다.Don’t break the order 여러 투명도를 가진 오브젝트를 그리려면, 가장 먼 객체를 먼저 그리고, 가까운 객체를 마지막에 그려야한다. 그리고, 투명 오브젝트를 드로잉하기전에 일반 오브젝트를 먼저 그려야한다. 일반적인 개요는 다음과 같다. 모든 불투명 오브젝트를 먼저 그림 투명 오브젝트를 모두 정렬 정렬된 이 오브젝트들을 순서대로 그림 정렬 방법 뷰어의 관점에서 거리를 검색 카메라의 위치 벡터와 객체의 위치 벡터 사이의 거리를 취함 이 거리를 해당 위치 벡터와 함께 map에 저장.(key값을 기반으로 자동 정렬) std::map&amp;lt;float, glm::vec3&amp;gt; sorted;for (unsigned int i = 0; i &amp;lt; windows.size(); i++){ float distance = glm::length(camera.Position - windows[i]); sorted[distance] = windows[i];} 렌더링은 역순으로 가져온다. for(std::map&amp;lt;float,glm::vec3&amp;gt;::reverse_iterator it = sorted.rbegin(); it != sorted.rend(); ++it) { model = glm::mat4(1.0f); model = glm::translate(model, it-&amp;gt;second); shader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 6); } 이제 다음과 같이 제대로 렌더링된다. 이러한 정렬은 회전, 크기 조정 등의 다른 변환을 고려하지 않는다. 일반적인 모양의 객체는 단순히 위치 벡터와 다른 측정 기준이 필요하다. 장면에서 오브젝트를 정렬하는 것은 장면에 따라 크게 달라진다. 비용이 많이 소요. 완벽하고 투명한 오브젝트로 장면을 완전히 렌더링하는것은 어려움. 순서 독립적 투명성(order independent transparency)과 같은 고급 기술이 있음. 출처Blendingblend test 사이트" }, { "title": "[백준][C++] 2206: 벽부수고 이동하기 (Floyd Warshall)", "url": "/posts/2022/03/18/01/53/1504/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-18 01:53:52 +0900", "snippet": "문제1504번: 특정한 최단 경로풀이 들려야하는 두 점 을 지나면서 최단 경로를 구하는 문제. 두 점을 A, B라고 하면 최단 경로는 대략 다음과 같다. 1 - A - B - N 1 - B - A - N 그러므로 정점에서 정점까지의 최단경로를 전부 구하여 더하면 된다. 이를 위해 모든 쌍에서의 최단 경로를 구하는 알고리즘인 Floyd Warshall을 사용했다. long long ans = min(adj[s][A] + adj[A][B] + adj[B][V - 1], adj[s][B] + adj[B][A] + adj[A][V - 1]); if (ans &amp;gt;= INT32_MAX) { cout &amp;lt;&amp;lt; -1; } else { cout &amp;lt;&amp;lt; ans; }증명 이에 관한 증명은 Floyd Warshall 증명과 비슷하다. 최단경로가 x를 경유할 때, 이 경로가 u에서 x로 가는 구간과 x에서 v로 가는 구간으로 나눌 수 있다. 이 두 부분 경로들은 최단 경로여야한다. 그렇지 않으면 최단경로라는 가정이 무너진다. 코드int V, E;int A, B;long long adj[801][801];void FD(int s){ for (int i = 0; i &amp;lt; V; i++) adj[i][i] = 0; for (int k = 0; k &amp;lt; V; k++) { for (int i = 0; i &amp;lt; V; i++) { for (int j = 0; j &amp;lt; V; j++) { adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]); } } } long long ans = min(adj[s][A] + adj[A][B] + adj[B][V - 1], adj[s][B] + adj[B][A] + adj[A][V - 1]); if (ans &amp;gt;= INT32_MAX) { cout &amp;lt;&amp;lt; -1; } else { cout &amp;lt;&amp;lt; ans; }}int main(){ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E; for (int i = 0; i &amp;lt; V; i++) { for (int j = 0; j &amp;lt; V; j++) { adj[i][j] = INT32_MAX; } } for (int i = 0; i &amp;lt; E; i++) { int a, b, c; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c; adj[a - 1][b - 1] = c; adj[b - 1][a - 1] = c; } cin &amp;gt;&amp;gt; A &amp;gt;&amp;gt; B; A--; B--; FD(0);}" }, { "title": "[learn-opengl] Advanced OpenGL: Stencil testing", "url": "/posts/2022/03/17/09/21/opengl19/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-17 09:21:06 +0900", "snippet": "Stencil testing Fragment shader가 fragment를 처리하고 나면, depth test와 비슷한 stencil test라고 불리는 것이 수행된다. fragment가 폐기될지 안될지 테스트하는 것이다. 이를 수행한 후 depth test로 또한번 폐기되는지 테스트한다. stencil buffer라는 버퍼에 의해 수행된다. 이 버퍼는 렌더링 동안에 수정할 수 있다. stencil buffer는 일반적으로 8 비트의 stencil value를 가지고 있음. 이 값은 pixel/fragment마다 256개의 값으로 나타내어진다. 이 stencil 값을 가지고 있는 특정 fragment를 테스트할 수 있다. 각 windowing library들은 stencil buffer를 세팅해야만 작동한다. GLFW는 이를 자동적으로 해준다. 하지만 다른 라이브러리들은 기본적으로 생성하지 않을 수 있으니, 문서를 확인하자 간단한 예제는 아래와 같다. (pixels not-to-scale): 이 stencil buffer는 먼저 0으로 채워지고나서 속이 비어있는 사각형 모양의 1을 설정한다. 이 scene의 fragment 중에서 stencil 값이 1인 fragment들만 렌더링된다.(다른 것들은 폐기된다.) stencil buffer는 fragment를 렌더링할 때마다 버퍼를 특정 값으로 설정할 수 있도록 허용한다. 같은 프레임에서 이러한 값을 읽어 특정 frag를 폐기하거나 전달할 수 있다. 스텐실 버퍼를 마음대로 사용할 수 있지만, 일반적인 아웃라인은 다음과 같다. 스텐실 버퍼 쓰기 활성화 스텐실 버퍼의 내용을 업데이트하여 오브젝트 렌더링. 스텐실 버퍼에 쓰기 비활성화 스텐실 버퍼를 기반으로 특정 fragment를 폐기하여 (other)오브젝트 렌더링 stencil buffer를 사용함으로써 scene에 그려진 다른 오브젝트의 fragment들을 기반으로하여 특정 fragment를 폐기할 수 있음. GL_STENCIL_TEST를 활성화하여 stencil testing을 활성화시킬 수 있다. 이 시점부터 호출되는 모든 렌더링 호출은 어떤 방식으로든 stencil buffer에 영향을 미친다. glEnable(GL_STENCIL_TEST); 또한 color, depth buffer와 마찬가지로, 매 렌더링 루프마다 stencil buffer를 비워주어야 한다.glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT); glStencilMask glDepthMask 함수처럼 동일한 기능을 수행함. 곧 버퍼에 작성될 stencil 값에 AND 연산을 시킬 bitmask를 설정함 기본적으로 bitmask는 모두 1로 설정됨, 출력에 영향주지 않음 이것을 0x00으로 설정하면 buffer에 작성되는 모든 stencil 값들은 0이 된다. 이는 depth testing의 glDepthMask(GL_FALSE) 함수와 비슷하다. glStencilMask(0xFF); // each bit is written to the stencil buffer as isglStencilMask(0x00); // each bit ends up as 0 in the stencil buffer (disabling writes) 대부분 위처럼 0x00 이나 0xFF로 설정한다. 다른 커스텀 비트마스크 옵션들도 존재하긴 함. Stencil functions stencil test를 통과시킬지 말지에 대한 기준을 설정한다. 2개의 함수가 있음 glStencilFunc glStencilOp 두 함스를 사용하면, 언제 어떻게 버퍼를 수정해야하는지를 정확히 지정할 수 있고, 언제 테스트가 통과하거나 실패할지도 지정할 수 있다. glStencilFunc glStencilFunc(GLenum func, GLint ref, GLuint mask) 함수는 3개의 파라미터를 가지고 있다. func: stencil test 함수 설정, 이 test 함수는 저장된 stencil 값과 glStencilFunc함수의 ref 값에 적용된다. 가능한 옵션은 GL_NEVER, GL_LESS, GL_LEQUAL, GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, GL_ALWAYS ref: stencil test에 대한 레퍼런스 값을 지정 stencil buffer의 내용은 이 값과 비교됨. mask: 비교하기 전에 참조 값과 저장된 스텐실 값 모두에 AND 연산이 수행되어질 마스크를 지정한다. 초기값은 모두 1. glStencilFunc(GL_EQUAL, 1, 0xFF) 위 코드는, OpenGL에게 fragment의 stencil값이 레퍼런스 값인 1과 동일 하다면, stencil test를 통과시킨 후 그리고, 그렇지 않으면 폐기한다. 하지만 이 함수는 오직 OpenGL이 stencil buffer의 내용물읠 기반으로 fragment들이 폐기될지 패스될지만 기술한다. 실제로 buffer를 수정할 수 있는 방법에 대한 기술은 없음. glStencilOp ` glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)` 3개의 옵션 sfail: stencil test가 실패하였을 때 취할 행동 dpfail: stencil test가 통과했지만 depth test는 실패했을 때 취할 행동 dppass: stencil, depth test 모두 통과했을 때 취할 행동 각 옵션들에 대해 다음을 설정할 수 있다. GL_KEEP: 기존 값(현재 저장된 stencil)을 그대로 유지 GL_ZERO: stencil 값을 0으로 설정 GL_REPLACE: stencil 값을 glStencilFunc 함수에서 지정한 ref 값으로 설정 GL_INCR: 최댓값보다 작다면, stencil값을 1만큼 증가시킴 GL_INCR_WRAP: GL_INCR와 같고, 최댓값을 초과하면 0으로 돌아옴 GL_DECR: 최솟값보다 크다면, stencil 값을 1만큼 감소시킴 GL_DECR_WRAP: GL_DECR와 같고, 0보다 작으면 최댓값으로 설정 GL_INVERT: 현재 stencil buffer 값의 비트를 뒤집음 기본값 == (GL_KEEP, GL_KEEP, GL_KEEP) 결과가 어떻든 버퍼의 값 유지됨 기본 행동 == 버퍼를 수정하지 않는것. 버퍼를 덮어쓰고 싶다면 이 옵션을 변경해야함 Object outlining 스텐실 테스트로 구현될 수 있는 유용한 기능중 하나. 각 오브젝트에 대해 색이 입혀진 작은 외곽선을 생성한다. 유닛을 선택했을 때 해당 유닛이 선택됬는지 보여주는 기능을 구현할 때 유용하다. 과정은 다음과 같다. stencil 쓰기 활성화 외곽선이 그려질 오브젝트를 그리기 전에 stencil 함수를 GL_ALWAYS로 설정, 오브젝트의 fragment가 렌더링될때마다 stencil buffer를 1로 업데이트 오브젝트 렌더링 stencil 쓰기와 depth testing을 비활성화 각 오브젝트들을 약간 확대 하나의 (외곽선) 컬러를 출력하는 별도의 fragment shader를 사용. 오브젝트를 다시 그리고, stencil 값이 1과 같지 않은 fragment들만 그립니다. 다시 stencil 작성과 depth testing을 활성화합니다. 이 과정은 각 오브젝트의 fragment들에 대해 버퍼의 내용을 1로 설정하고, 외곽선을 그리고 싶을 때, 오브젝트의 확대된 버전을 stencil test가 통과된 부분만 그린다. 확대된 버전은 오브젝트의 외곽선으로 그려진다. stencil buffer를 사용하여 겹치는 부분의 fragment는 폐기한다. 예제 먼저 외곽선 컬러 fragment shader를 작성해야한다. (간단히 하드코딩)void main(){ FragColor = vec4(0.04, 0.28, 0.26, 1.0);} depth test의 앞선 예제를 사용하여, 두 컨테이너에 외곽선을 추가할것이다. 먼저 바닥을 그린후 stencil을 쓰면서 두 컨테이너를 그린다. 그리고 스케일업된 두 컨테이너를 그린다.(곂치는 부분의 frag를 폐기하면서) 먼저 stencil test를 활성화하자 glEnable(GL_STENCIL_TEST); 그다음에 각 프레임마다 수행하기를 원하는 행동을 정의하자. 모든 테스트가 성공할 때, 지정된 ref값으로 수정하게 설정 stencil buffer를 0으로 비우고 컨테이너들을 위해 각 그려진 fragment들에 대해 stencil buffer를 1로 업데이트한다. glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);glStencilFunc(GL_ALWAYS, 1, 0xFF); // all fragments should pass the stencil testglStencilMask(0xFF); // enable writing to the stencil buffernormalShader.use();DrawTwoContainers(); GL_ALWAYS로 각 fragment들이 버퍼를 수정하여 stencil 값을 1로 만든다. 항상 통과, 그려지는곳에 버퍼가 ref값 즉 1로 수정 그 후, 확대된 컨테이너를 그려야함. 이번에는 버퍼 쓰기를 비활성화한다. 그리고 1과 같지않은 부분만 그리도록한다.(NOTEQUAL) =&amp;gt; 외곽선 그리고 depth test를 비활성화하여, 바닥에 의해 덮어쓰여지지 않도록했다.(?) glStencilFunc(GL_NOTEQUAL, 1, 0xFF);glStencilMask(0x00); // disable writing to the stencil bufferglDisable(GL_DEPTH_TEST);shaderSingleColor.use();DrawTwoScaledUpContainers(); 전체 과정은 다음과 같다.glEnable(GL_DEPTH_TEST);glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);glStencilMask(0x00); // make sure we don&#39;t update the stencil buffer while drawing the floornormalShader.use();DrawFloor()glStencilFunc(GL_ALWAYS, 1, 0xFF);glStencilMask(0xFF);DrawTwoContainers();glStencilFunc(GL_NOTEQUAL, 1, 0xFF);glStencilMask(0x00);glDisable(GL_DEPTH_TEST);shaderSingleColor.use();DrawTwoScaledUpContainers();glStencilMask(0xFF);glStencilFunc(GL_ALWAYS, 1, 0xFF);glEnable(GL_DEPTH_TEST); 이 outlining 알고리즘의 결과는 다음과 같다.전체 코드 두 컨테이너의 외곽선이 겹쳐짐. 이처럼 합치는것은 일반적으로 작은 유닛을 선택할 때 유용하다. 완벽한 외곽선을 원한다면, 오브젝트마다 stencil buffer를 비우고, 약간 창의적으로 depth buffer를 사용해야한다. 이런 외곽선은 여러 게임(특히 전략게임)에서 오브젝트를 선택을 시각화할 때 흔히 사용된다. 이러한 알고리즘은 model 클래스와 함께 쉽게 구현 가능하다. 간단히 외곽선을 그릴지 말지를 결정하는 boolean flag를 model 클래스에 생성할 수 있다. 좀 더 창의적이게 자연스러운 효롸를 넣고 싶다면, Gaussian Blur와 같은 전처리 필터를 사용할 수 있다. stencil testing은 다른 목적으로 사용가능하다. 백미러의 텍스처를 그릴 때, 거울의 모양에 맞게 그리거나 실시간 그림자를 렌더링할 때 shadow volumes라는 stencil buffer 기술이 쓰임. 출처stencil-testing: 원문stencil-testing: 번역본" }, { "title": "[learn-opengl] Advanced OpenGL: Depth testing", "url": "/posts/2022/03/17/06/21/opengl18/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-17 06:21:52 +0900", "snippet": "Depth testing 앞에서(좌표시스템) depth buffer를 사용하여 뒤에있는 면들이 앞에 그려지지 않도록 했다. 이번에는 depth values를 다룰것이며, 이는 이 버퍼를 더 강력하게 만들 것이다. 또한 특정 fragment가 다른 fragment들의 뒤에 있는지 판별하는 방법에 대해서 다룰 것이다. depth-buffer color buffer와 마찬가지로, 버퍼의 한 종류 fragment 정보를 저장, color buffer와 동일한크기를 가짐. 윈도우 시스템에 의해(by the windowing system) 자동적으로 생성되고, depth values들을 16, 24, 32 비트 실수형으로 저장한다. 대부분은 24비트를 사용한다. depth testing을 활성화 OpenGL은 depth buffer의 내용에 따라 fragment의 깊이 값을 테스트한다. 통과되면, 버퍼는 새로운 깊이 값으로 수정된다. 실패하면, 해당 fragment 는 폐기된다. depth testing은 fragment shader가 수행된 후(그리고 stencil testing이 수행된 후)에 screen space에서 수행된다. screen space 좌표는 OpenGL의 glViewport 함수에서 정의한 viewport와 관련이 있다. GLSL에서 gl_FragCoord 변수를 통해 접근할 수 있다. gl_FragCoord 변수의 x, y 요소는 fragment의 screenspace 좌표를 나타낸다. ((0,0)이 화면의 좌측 하단) 이 변수는 fragment의 실제 깊이 값을 가지고 있는 z요소 또한 포함한다. 이 z값이 depth buffer의 내용과 비교할 값이다. 최근 대부분의 GPU들은 early depth testing이라고 불리는 기능을 지원한다. 이는 fragment shader를 실행하기 전, depth test를 수행하도록한다. fragment가 보여지지 않게될 때(뒤에 위치할 때)마다 미리 fragment 를 폐기할 수 있다. fragment shader는 일반적으로 비용을 꽤 많이 차지하므로, 실행하는 것을 최소한으로 피할 수 있으면 피해야한다. early depth testing을 위해서는 fragment shader에서 깊이 값을 wirte하지 말아야한다. (작성하려고 하면, early depth testing 은 불가능, OpenGL은 depth value를 미리 알아낼 수 없다) depth testing은 기본으로 비활성화 상태 활성화는 GL_DEPTH_TEST 옵션을 사용해야한다. glEnable(GL_DEPTH_TEST); 활성화 되면, OpenGL은 자동으로 depth test를 통과한 경우에만 fragment의 z 값을 depth buffer에 저장한다. 활성화되면 GL_DEPTH_BUFFER_BIT 를 사용하여 버퍼를 비워주어야 한다. 그렇지 않으면 마지막 렌더링 루프에서 작성된 값들이 그대로 유지 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); depth buffer를 수정하는 것을 원치 않을 경우 read-only depth buffer를 사용해야함. depth mask를 GL_FALSE로 설정하여 덮어쓰기 비활성화 glDepthMask(GL_FALSE);Depth test function OpenGL은 depth test에서 사용하는 비교 연산을 조정할 수 있도록 해준다. 이는 fragment를 어떨 때에 통과 혹은 폐기시켜야할 지를 조정할 수 있도록 하고, 또한 depth buffer를 언제 수정해야하는 지에 대해서도 조정할 수 있도록 해준다. glDepthFunc 함수를 사용하여 비교연산자(혹은 depth 함수)를 설정할 수 있다. glDepthFunc(GL_LESS); Function Description GL_ALWAYS The depth test always passes. GL_NEVER The depth test never passes. GL_LESS Passes if the fragment’s depth value is less than the stored depth value. GL_EQUAL Passes if the fragment’s depth value is equal to the stored depth value. GL_LEQUAL Passes if the fragment’s depth value is less than or equal to the stored depth value. GL_GREATER Passes if the fragment’s depth value is greater than the stored depth value. GL_NOTEQUAL Passes if the fragment’s depth value is not equal to the stored depth value. GL_GEQUAL Passes if the fragment’s depth value is greater than or equal to the stored depth value. 기본값은 GL_LESS이다. 현재 depth buffer의 값과 동일하거나 큰 fragment를 폐기한다 depth 함수 예제 depth 함수를 수정해보자 텍스처를 입힌 바닥 위에 텍스처를 입힌 2개의 큐브가 존재하고 조명이 없는 기본적인 scene을 렌더링하는 코드를 사용할 것이다. 소스 코드 depth 함수를 GL_ALWAYS로 바꾸어보자glEnable(GL_DEPTH_TEST);glDepthFunc(GL_ALWAYS); 이는 depth testing 을 비활성화한 것과 같은 효과이다. - 항상 통과 =&amp;gt; 마지막에 그려진 fragment가 렌더링 - 바닥을 마지막에 그리면, 바닥이 다음과 같이 보이게됨. 다시 GL_LESS로 설정하면, 우리가 사용해왔던 유형의 scene을 볼 수 있다. Depth value precision Depth buffer는 0.0 과 1.0 사이의 깊이 값을 가진다. viewr의 관점에서 scene의 모든 오브젝트들의 z값과 비교됨. view space의 z값들은 projection 절두체의 near와 far 사이의 어떠한 값이 될 수 있음. view space의 z값들은 0.0과 1.0 사이의 값으로 변환해야함. 이는 1차원적으로 변환할 수 있다. 다음 일차 방정식은 z값을 0.0와 1.0사이의 값으로 변환시킨다. near, far는 projection 행렬에 설정했던 값들 \\[\\begin{equation} F_{depth} = \\frac{z - near}{far - near} \\end{equation}\\] 이 방정식은 절두체 내부의 깊이 값 z의 범위를 변환한다. z 그래프는 다음과 같다. 하지만, 이런 방정식은 사용되지 않음. 올바른 투영 특성을 위해, 비선형 depth 방정식이 사용된다. 비선형 방정식 1/z와 비례 기본적으로 z 값이 작을 때 큰 정밀도를 가지고, z 값이 멀리 있을 때 정밀도가 떨어지게 한다. 1000단위 뒤의 오브젝트와 1단위 오브젝트가 동일한 값의 정밀도를 가지는것은 좋지않다. 비선형 함수는 1/z에 비례하고, 1.0와 2.0 사이의 z값을 0.5, 1.0 사이의 깊이 값으로 변환한다. 이는 작은 z값에 대해 큰 정밀도를 가지게 한다. 비선형 방정식은 아래와 같다.\\[\\begin{equation} F_{depth} = \\frac{1/z - 1/near}{1/far - 1/near} \\end{equation}\\] 이 방정식은 screen-space에서 비선형이다. projection 행렬이 적용되기 전의 view-space에서는 선형적 위 그래프에서 볼 수 있듯이 깊이값들은 작은 z값에서 큰 정밀도를 가진다. z값을 변환시키는 이 방정식은 projection 행렬에 포함되어 있으므로 vertex 좌표를 view에서 clip 변환하여 screen-space로 이동할 때 이 비선형 방정식이 적용된다. projection 행렬 수행 원리에 관한 내용 멀어질수록 간격이 좁아진다 가능한 전방 절단면을 시점에서 멀리 =&amp;gt; 물체 간격이 상대적으로 보존 =&amp;gt; 깊이테스트 올바르게 가능 전방절단면의 위치를 시점 쪽으로 바짝 잡아당기면 =&amp;gt; 물체가 전방절단면의 훨씬 뒤쪽에 분포해, 촘촘한 간격의 깊이로 사상되어 버린다. 전방절단면을 오히려 시점에 떨어뜨려 물체에 최대한 근접시켜야함 =&amp;gt; 물체의 간격이 상대적으로 보존됨 깊이 버퍼의 비트수의 제한으로인해 정밀도 문제Visualizing the depth buffer fragment shader의 gl_FragCoord 의 z값을 컬러로 출력하면, 모든 fragment의 깊이 값들을 scene에 출력할 수 있다. fragment의 깊이 값을 기반으로 컬러 벡터를 리턴 void main(){ FragColor = vec4(vec3(gl_FragCoord.z), 1.0);} 프로그램을 실행한다면, 모든것이 하얀색으로 보일 것 모든 깊이 값들이 1.0인것처럼 screenspace 에서는 깊이 값들은 비선형이다. 작은 z 값 =&amp;gt; 큰 정밀도 큰 z 값 =&amp;gt; 작은 정밀도 깊이 값은 거리에 따라 급격히 증가하므로, 대부분의 모든 vertex들은 1.0에 가까운 값을 가지게 됨. 오브젝트에 가까이 가면 결국 어두워짐.(z값이 점점 작아져서) 가까운 오브젝트들은 멀리있는 오브젝트들보다 더 큰 효과를 가짐. 이런 비선형 깊이 값을 다시 선형으로 변환할 수 있다. 깊이 값을 위한 projection 과정을 반대로 해야함. [0,1] 범위의 깊이 값들을 [-1,1] 범위의 NDC 좌표로 변환해야한다는 것을 의미. projection 행렬에서 수행된 비선형 방정식의 역함수를 구하여 깊이 값에 적용해야함. 그 결과로 선형 깊이 값이 도출됨. NDC 좌표로 변환float ndc = depth * 2.0 - 1.0; 이 z 값에 역변환을 적용 시켜 선형 깊이 값을 얻는다.float linearDepth = (2.0 * near * far) / (far + near - ndc * (far - near)); 위 방정식은 projection 행렬로부터 얻은것 screen-space에서의 비선형 깊이 값을 선형 깊이 값으로 변환하는 최종 fragment shader는 다음과 같다. #version 330 coreout vec4 FragColor;float near = 0.1;float far = 100.0;float LinearizeDepth(float depth){ float z = depth * 2.0 - 1.0; // back to NDC return (2.0 * near * far) / (far + near - z * (far - near));}void main(){ float depth = LinearizeDepth(gl_FragCoord.z) / far; // divide by far for demonstration FragColor = vec4(vec3(depth), 1.0);} 변환된선형 깊이 값들은 near 와 far 사이의 값이기 때문에 대부분의 값들은 1.0 보다 높다. 그러므로 far로 나눔으로써 선형 깊이 값을 대략 [0,1] 범위로 변환시킬 수 있다. 이제 프로그램을 실행시켜보면, 실제로 거리에 따라 선형적인 깊이 값을 얻을 수 있다. 0.1에 위치한 near평면과 100에 위치한 far 평면 사이에 선형적으로 존재하는 깊이값을 얻을 수 있다. 결과는 근거리 평면에 상대적으로 가깝기 때문에 더 낮은(어두운) 깊이 값을 던는다. Z-fighting 시각적 결함 두개의 평면이나 삼각형들이 아주 가깝게 서로 나란히 위치할 때 발생 이 경우 depth buffer는 두 개의 도형 중 어떠한 것이 앞에 있는지 알아내기 위한 충분한 정밀도를 가지지 못한다. 결과적으로 두 도형이 계속해서 순서가 바뀌는 것과 같은 패턴이 보임. 이 현상을 z-fighting이라고 한다.(보여지기위해 싸우는 것과 같이 보이기 때문에) 예 컨테이너들은 바닥이 위치한 정확한 높이에 위치해있다. 즉, 컨테이너의 밑면이 바닥 평면과 바닥이 동일한 위치에 있음. depth test에서 문제 생김 카메라를 내부로 이동하여 보면 이 현상이 보일 것이다.(아래 이미지에서 지그재그 패턴을 볼 수 있음) 이는 depth buffer에서 흔히 발생하는 문제이다. 멀리 있는 오브젝트에서 더 많이 발생한다.(더 촘촘하므로, 정밀도 문제 발생) 이런 문제는 완전히 해결 불가능하지만, 완화시키거나, 이처럼 안보이게하는 트릭이 존재한다. Prevent z-fighting 가장 중요한 트릭은 삼각형들이 겹치지 않을 정도로 가깝게 두지 않는것이다. 엄청 작은 offset 값을 설정한다. 이는 수작업으로 조정해야한다. 두번째 트릭은, near 평면을 가능한 멀리 설정하는 것이다. near 평면에 가까울 수록 정밀도는 커짐 near 평면을 시점으로부터 멀리 이동시킨다면, 전체 절두체 범위에 걸쳐 큰 정밀도를 가질 수 있다. 하지만, 시점 가까이에 있는 오브젝트들을 폐기할 수 있으므로 일반적으로 최적의 near 거리를 찾아야한다, 세번째 트릭은, 높은 정밀도의 depth buffer를 사용하는 것이다. 대부분 24 비트의 정밀도 요즘 그래픽 카드들은 32 비트도 지원함 이는 정밀도를 크게 증가시켜준다. 일부 성능을 희생하면, depth testing에 대한 정밀도를 높여 z-fighting을 줄일 수 있다. Z-fighting은 흔한 문제이지만, 적절히 이런 트릭들을 조합하면 크게 걱정할 필요는 없다.출처Depth-testingDepth-testing: 번역" }, { "title": "[백준][C++] 2206: 벽부수고 이동하기 (bfs)", "url": "/posts/2022/03/17/03/39/2206/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-17 03:39:42 +0900", "snippet": "문제2206풀이 최단거리를 구하는 문제 보통 이런 문제는 상태가 2가지이다. 방문 o 방문 x 하지만 이 문제에는 상태가 더 추가되었다. 벽부수지 않고 방문 o 벽부수고 방문 o 방문 x 그러므로 이를 처리해야한다. 3가지 상태를 다루기 위해 그리드에 상태를 기록하였다. 여기서 중요한것은 최단거리를 구하는 것이다. 최단거리=&amp;gt; 만약 앞에서 먼저 방문한것이라면, 굳이 들릴 필요없다.(이미 지금 해는 가능성이 없음) 하지만, 만약 먼저 방문한게 벽을 부수고 방문할 경우, 이 경우 다른 벽을 파서 최적의해를 만들 수 있기 때문에, 들려야한다. char &amp;amp;item = box[yy][xx]; // 벽부수고 이동가능한 경우 if (item == &#39;1&#39; &amp;amp;&amp;amp; !isBreaked) { q.push({xx, yy, cost + 1, true}); } // 방문하지 않은 곳에 방문할 경우 else if (item == &#39;0&#39;) { item = static_cast&amp;lt;char&amp;gt;(isBreaked); q.push({xx, yy, cost + 1, isBreaked}); } // 먼저 벽부수고 방문한길에 방문할 경우 else if (item == static_cast&amp;lt;char&amp;gt;(true) &amp;amp;&amp;amp; !isBreaked) { item = &#39;9&#39;; q.push({xx, yy, cost + 1, isBreaked}); }코드int dx[] = {1, -1, 0, 0};int dy[] = {0, 0, -1, 1};int m, n;queue&amp;lt;tuple&amp;lt;int, int, int, bool&amp;gt;&amp;gt; q;char box[1001][1001];void bfs(){ int count = q.size(); int ret = 0; box[0][0] = &#39;2&#39;; q.push({0, 0, 1, false}); while (!q.empty()) { auto [x, y, cost, isBreaked] = q.front(); q.pop(); for (int i = 0; i &amp;lt; 4; i++) { int xx = dx[i] + x; int yy = dy[i] + y; if (xx &amp;lt; 0 || xx &amp;gt;= m || yy &amp;lt; 0 || yy &amp;gt;= n) { continue; } if (xx == m - 1 &amp;amp;&amp;amp; yy == n - 1) { cout &amp;lt;&amp;lt; cost + 1; return; } char &amp;amp;item = box[yy][xx]; if (item == &#39;1&#39; &amp;amp;&amp;amp; !isBreaked) { q.push({xx, yy, cost + 1, true}); } else if (item == &#39;0&#39;) { item = static_cast&amp;lt;char&amp;gt;(isBreaked); q.push({xx, yy, cost + 1, isBreaked}); } else if (item == static_cast&amp;lt;char&amp;gt;(true) &amp;amp;&amp;amp; !isBreaked) { item = &#39;9&#39;; q.push({xx, yy, cost + 1, isBreaked}); } } } if (m == 1 &amp;amp;&amp;amp; n == 1) { cout &amp;lt;&amp;lt; 1; } else { cout &amp;lt;&amp;lt; -1; }}int main(){ cin.tie(0)-&amp;gt;sync_with_stdio(0); cout.tie(0); cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; box[i][j]; } } bfs();}" }, { "title": "[learn-opengl] Model Loading: Model", "url": "/posts/2022/03/15/13/27/opengl17/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-15 13:27:38 +0900", "snippet": "Model 이제 Assimp를 사용해야한다. 실제 로딩, 변환 코드를 생성할 것이다. 여러 메시를 가지는 전체적인 모델을 나타내는 클래스를 만들것이다.class Model{ public: Model(char *path) { loadModel(path); } void Draw(Shader &amp;amp;shader); private: // model data vector&amp;lt;Mesh&amp;gt; meshes; string directory; void loadModel(string path); void processNode(aiNode *node, const aiScene *scene); Mesh processMesh(aiMesh *mesh, const aiScene *scene); vector&amp;lt;Texture&amp;gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName);}; 이 Model 클래스는 Mesh객체들의 vector를 가지고 있고, 생성자에서 파일의 위치를 요구한다. 그런 다음, loadModel함수를 생성자에서 호출하여 파일을 불러온다. private함수들은 Assimp의 import루틴의 일부분을 처리한다. 나중에 텍스처를 로드할 때를 위해 directory 변수가 있음을 주의해라 Draw함수는 특별한 것은 없고, 기본적으로 반복문을 이용하여 mesh들의 Draw함수를 호출시킨다. void Draw(Shader &amp;amp;shader){ for(unsigned int i = 0; i &amp;lt; meshes.size(); i++) meshes[i].Draw(shader);}Importing a 3D model into OpenGL 모델을 가져와서 우리 자신의 구조로 변환하기 위해서는, 적절히 Assimp의 헤더를 포함시켜야한다.#include &amp;lt;assimp/Importer.hpp&amp;gt;#include &amp;lt;assimp/scene.h&amp;gt;#include &amp;lt;assimp/postprocess.h&amp;gt; 먼저 우리가 호출하는 첫 함수는 생성자에서 직접 호출되는 loadModel이다. 이 함수내부에서는 scene 객체라는 Assimp의 데이터 구조에 모델을 로드해야한다. 이 객체는 Assimp 데이터 인터페이스의 루트 객체이다. scene 객체를 통해 원하는 모든 데이터를 얻을 수 있다. Assimp는 다양한 파일 포멧들을 불러올 수 있게 추상화한 라이브러리이다. Assimp::Importer importer;const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); 먼저 Importer 객체를 선언해야한다. 이객체의 ReadFile 함수를 호출한다. 이 함수를 호출할 때 파일의 경로, 전처리 옵션들을 지정할 수 있다. 전처리 옵션 볼러온 데에터에 추가적인 계산/연산 aiProcess_Triangulate: Assimp에게 모델이 삼각형으로만 이루어지지 않았다면, 모든 primitive 도형들을 삼각형으로 변환하라고 말해준다. aiProcess-FlipUVs: 텍스처 좌표를 y축으로 뒤집어준다.(OpenGL에서 대부분의 이미지들은 y축을 중심으로 거꾸로되어 있음.) aiProcess_GenNormals: 모델이 법선 벡터들을 가지고 있지 않다면, 각 vertex에 대한 법선을 생성 aiProcess_SplitLargeMeshes: 큰 메쉬를 더 작은 하위 메시로 나눔. 렌더링에 최대 정점이 허용되고 더 작은 메쉬만 처리할 수 있는 경우에 유용. aiProcess_OptimizeMeshes: 여러 메시들을 하나의 큰 메시로 합침. 최적화를 위해 드로잉 호출을 줄임. Assimp는 많은 훌륭한 전처리 옵션을 제공함. 어려운 작업은 반환된 scene객체를 사용하여 불러온 데이터를 Mesh객체들의 배열로 변환하는것. 완성된 loadModel함수는 다음과 같다. void loadModel(string path){ Assimp::Importer import; const aiScene *scene = import.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs); if(!scene || scene-&amp;gt;mFlags &amp;amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&amp;gt;mRootNode) { cout &amp;lt;&amp;lt; &quot;ERROR::ASSIMP::&quot; &amp;lt;&amp;lt; import.GetErrorString() &amp;lt;&amp;lt; endl; return; } directory = path.substr(0, path.find_last_of(&#39;/&#39;)); processNode(scene-&amp;gt;mRootNode, scene);} 위 코드는 모델을 불러온 후에 제대로 모델이 로드됬는지 확인한다. 또한 주어진 파일 경로의 디렉터리 경로를 얻는다. scene의 노드들을 처리하기 위해, 첫 번째 노드(루트노드)를 재귀함수인 processNode로 전달한다. 각 노드는 자식들을 가지고 있기 때문에, 먼저 노드를 처리하고, 그런 다음 모든 자식들을 처리한다. 이는 재귀적인 구조에 적합하므로, 재귀함수로 정의한것. 종료조건은 모든 노드들을 처리되었을 때 만족한다. 각 노드는 mesh index들의 모음을 가지고 있다. 각 index는 scene객체 내부의 특정한 mesh를 가리킨다. 이러한 인덱스들을 얻고 각 mesh들을 얻고 그 후 각 mesh들을 처리한다. 그리고 나서 자식들도 이러한 작업을 반복한다. processNode함수의 내용은 다음과 같다. void processNode(aiNode *node, const aiScene *scene){ // process all the node&#39;s meshes (if any) for(unsigned int i = 0; i &amp;lt; node-&amp;gt;mNumMeshes; i++) { aiMesh *mesh = scene-&amp;gt;mMeshes[node-&amp;gt;mMeshes[i]]; meshes.push_back(processMesh(mesh, scene)); } // then do the same for each of its children for(unsigned int i = 0; i &amp;lt; node-&amp;gt;mNumChildren; i++) { processNode(node-&amp;gt;mChildren[i], scene); }} mesh 인덱스를 확인하고, scene의 mMeshes 배열에 접근하여, mesh들을 얻는다. 반환된 mesh는 processMesh 함수로 전달된다. 이 함수는 meshes vector에 저장할 수 있는 Mesh객체를 리턴한다. 모든 mesh들이 처리되면, 자식노드들을 처리한다. 지금 당장은 이런 시스템을 사용하지는 않지만, 일반적으로 mesh 데이터들에 관한 추가적인 관리를 위해서 권장된다. 이러한 노드 관계는 모델을 만든 아티스트들에 의해 정의된다. 다음 단계는 Assimp 데이터를 처리하여, Mesh클래스 형태로 변환하는 것Assimp to Mesh 각 mesh들의 관련된 속성들에 접근하여 자신만의 객체에 저장하는 것. processMesh함수의 일반적인 구조는 다음과 같다. Mesh processMesh(aiMesh *mesh, const aiScene *scene){ vector&amp;lt;Vertex&amp;gt; vertices; vector&amp;lt;unsigned int&amp;gt; indices; vector&amp;lt;Texture&amp;gt; textures; for(unsigned int i = 0; i &amp;lt; mesh-&amp;gt;mNumVertices; i++) { Vertex vertex; // process vertex positions, normals and texture coordinates // [...] vertices.push_back(vertex); } // process indices // [...] // process material if(mesh-&amp;gt;mMaterialIndex &amp;gt;= 0) { // [...] } return Mesh(vertices, indices, textures);} Mesh를 처리하는 것은 기본적으로 3부분. 모든 vertex 데이터를 얻고. mesh의 indices를 얻고 마지막으로 연관된 material 데이터를 얻는것. Vertex 데이터 얻기 각 루프를 돌때마다 vertices 배열에 삽입할 Vertex struct를 정의한다. mesh에 존재하는 vertex의 갯수만큼 반복문을 실행한다. 그런 다음 반복문 내부에서 모든 관련된 데이터로 이 struct를 채워넣어야한다. glm::vec3 vector;vector.x = mesh-&amp;gt;mVertices[i].x;vector.y = mesh-&amp;gt;mVertices[i].y;vector.z = mesh-&amp;gt;mVertices[i].z;vertex.Position = vector; Assimp 데이터 변환을 위해, vec3 변수를 정의한다.(Assimp만의 데이터 타입과 호환 안될 가능성이 크므로) 법선은 다음과같다. vector.x = mesh-&amp;gt;mNormals[i].x;vector.y = mesh-&amp;gt;mNormals[i].y;vector.z = mesh-&amp;gt;mNormals[i].z;vertex.Normal = vector; 텍스처 좌표는 다음과 같다. Assimp는 모델이 꼭지점당 최대 8개의 다른 텍스처 좌표를 허용한다. 지금은 하나의 텍스처만 사용하기 때문에, 첫 번째만 신경쓰면됨. mesh가 실제로 텍스처 좌표를 가지고 있는지 확인해야한다.(항상 가지고 있는것이 아니므로) if(mesh-&amp;gt;mTextureCoords[0]) // does the mesh contain texture coordinates?{ glm::vec2 vec; vec.x = mesh-&amp;gt;mTextureCoords[0][i].x; vec.y = mesh-&amp;gt;mTextureCoords[0][i].y; vertex.TexCoords = vec;}else vertex.TexCoords = glm::vec2(0.0f, 0.0f); vertex struct는 이제 필요한 vertex 속성들로 완전히 채워졌다. 이 것을 vertices vector의 삽입한다. 이는 mesh의 각 vertex 마다 수행된다. Indices Assimp의 인터페이스는 각 mesh들이 face의 배열을 가지고 있도록 정의한다. 각 face들은 하나의 primitive를 나타낸다. aiProcess_Triangulate 옵션에 의하여 항상 삼각형이 된다. face는 어떠한 순서로 vertex들을 그려야하는지를 정의하는 indices를 가지고 있다. 그래서 우리는 모든 face에 대해 반복문을 돌려, 모든 face의 indices를 indices vector에 저장해야한다. for(unsigned int i = 0; i &amp;lt; mesh-&amp;gt;mNumFaces; i++){ aiFace face = mesh-&amp;gt;mFaces[i]; for(unsigned int j = 0; j &amp;lt; face.mNumIndices; j++) indices.push_back(face.mIndices[j]);} 이제, glDrawElements 함수로 그릴 수 있지만, material 또한 처리해야한다.Material 노드와 마찬가지로 mesh는 오직 material 객체의 index만 가지고 있다. 앞에서처럼 mMaterial 배열을 인덱싱해야한다. mesh의 material index는 mMaterialIndex 속성에 설정되어 있다. 이 속성으로 mesh가 실제로 material을 가지고 있는지 아닌지 확인 가능. if(mesh-&amp;gt;mMaterialIndex &amp;gt;= 0){ aiMaterial *material = scene-&amp;gt;mMaterials[mesh-&amp;gt;mMaterialIndex]; vector&amp;lt;Texture&amp;gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, &quot;texture_diffuse&quot;); textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end()); vector&amp;lt;Texture&amp;gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, &quot;texture_specular&quot;); textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());} 궁금점: 퐁모델이 아닌경우에도 셰이더에 diffuse 와 specular? scene의 mMaterials 배열로부터 aiMaterial 객체를 얻는다. 그리고, mesh의 diffuse, specular 텍스처들을 로드한다. material 객체는 내부적으로 각 텍스처 타입에 대한 texture location 배열을 저장한다. 여러 텍스처 타입들은 aiTexture Type_ 접두사로 분류된다. loadMaterialTextures: 이 함수는 material에서 텍스처를 얻는다. texture struct의 vector를 리턴하고, 이 것을 model의 textures vector의 끝에 저장한다. 주어진 텍스처 타입의 모든 texture location을 순회하며, 텍스처 파일의 위치를 얻은 다음 로드하고 텍스처를 생성하며, 이 정보를 Vertex struct에 저장한다. GetTextureCount함수를 통해 이 material에 저장된 해당하는 텍스처의 타입의 수를 확인한다. GetTexture 함수를 통해 각 텍스처 파일의 위치를 얻는다. TextureFromFile 함수로 텍스처를 불러오고 텍스처 아이디를 얻는다. unsigned int TextureFromFile(const char *path, const string &amp;amp;directory, bool gamma = false);vector&amp;lt;Texture&amp;gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName){ vector&amp;lt;Texture&amp;gt; textures; for(unsigned int i = 0; i &amp;lt; mat-&amp;gt;GetTextureCount(type); i++) { aiString str; mat-&amp;gt;GetTexture(type, i, &amp;amp;str); Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str; textures.push_back(texture); } return textures;} TextureFromFile은 다음과 같다.unsigned int TextureFromFile(const char *path, const string &amp;amp;directory, bool gamma){ string filename = string(path); filename = directory + &#39;/&#39; + filename; unsigned int textureID; glGenTextures(1, &amp;amp;textureID); int width, height, nrComponents; unsigned char *data = stbi_load(filename.c_str(), &amp;amp;width, &amp;amp;height, &amp;amp;nrComponents, 0); if (data) { GLenum format; if (nrComponents == 1) format = GL_RED; else if (nrComponents == 3) format = GL_RGB; else if (nrComponents == 4) format = GL_RGBA; glBindTexture(GL_TEXTURE_2D, textureID); glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, format, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); stbi_image_free(data); } else { std::cout &amp;lt;&amp;lt; &quot;Texture failed to load at path: &quot; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; std::endl; stbi_image_free(data); } return textureID;} model 파일의 텍스처 파일 경로가 model 파일과 동일하다고 가정했다. 간단히 텍스처 위치 문자열과(loadModel 함수로 얻은) 디렉터리 문자열을 결합하여 완전한 텍스처 경로를 얻을 수 있다. (GetTexture함수에 디렉터리 문자열이 필요한 이유) 그러므로 만약 텍스처 위치에 대해서 절대 경로를 사용하는 모델일 경우, 위 코드는 일부 기기에서 작동하지 않을 수 있다.(로컬 경로를 사용하기 위해 파일을 수정해야함)An optimization 대부분의 scene들은 여러 mesh들에 여러가지 텍스처들을 재사용한다. 집같은 경우 벽, 바닥, 천장, 계단, 테이블 등에 같은 텍스처를 사용할 수 있음. 텍스처를 로드하는것은 비용이 많이 드는 연산이다. 현재 구현한 상태로는 각 mesh마다 새로운 텍스처가 로드되고 생성된다. 즉, 같은 텍스처가 여러번 로드 =&amp;gt; 병목현상이 쉽게 발생할 수 있다. 따라서 불러온 모든 텍스처들을 전역으로 저장하고, 텍스처를 불러오고 싶을때마다 그 텍스처가 이미 로드됬는지 확인한다. 이를 위해 경로 또한 저장해야한다. struct Texture { unsigned int id; string type; string path; // we store the path of the texture to compare with other textures}; 그다음, 모델 클래스의 맨 위에 private 변수로 텍스처 vector를 선언하자vector&amp;lt;Texture&amp;gt; textures_loaded; 그다음, loadMaterialTextures함수에서 텍스처 경로를 textures_loaded vector에 있는 모든 텍스처의 경로롸 비교하여 현재 텍스처 경로가 다른 것들과 같은지 확인한다. 같으면 텍스처 로드 생성 생략하고 기존꺼 넣는다. vector&amp;lt;Texture&amp;gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, string typeName){ vector&amp;lt;Texture&amp;gt; textures; for(unsigned int i = 0; i &amp;lt; mat-&amp;gt;GetTextureCount(type); i++) { aiString str; mat-&amp;gt;GetTexture(type, i, &amp;amp;str); bool skip = false; for(unsigned int j = 0; j &amp;lt; textures_loaded.size(); j++) { if(std::strcmp(textures_loaded[j].path.data(), str.C_Str()) == 0) { textures.push_back(textures_loaded[j]); skip = true; break; } } if(!skip) { // if texture hasn&#39;t been loaded already, load it Texture texture; texture.id = TextureFromFile(str.C_Str(), directory); texture.type = typeName; texture.path = str.C_Str(); textures.push_back(texture); textures_loaded.push_back(texture); // add to loaded textures } } return textures;} Assimp의 일부 버전들은 IDE 디버그 버전이나 모드를 사용할 때 model을 꽤 느리게 로드하는 경향이 있다. 그러므로 로딩하는 시간이 느리다면, 릴리즈 버전으로 테스트해보자.전체 코드No more containers! 이제 실제 모델을 사용해보자. 이 모델을 사용할 것임.(다운) free3d 에서 다양한 모델들을 얻을 수 있음. 주의: 절대경로인 경우 상대 경로로 텍스처 파일들을 수정해야함. 이때 모든 텍스처 파일들과 모델 파일들은 동일한 디렉터리에 있어야한다. 이 모델은 diffuse, specular, normal maps이 연결된 .mtl과 함께 .obj 파일로 export된 것이다. 이제 코드에서 Model 객체를 선언하고, 모델 파일의 경로를 전달한다. 그런 다음, 이 모델은 로드되고, 게임 루프에서 Draw함수를 사용하여 오브젝트를 그려야한다. 더 이상의 버퍼 할당과 속성 포인터 및 렌더링 명령이 필요하지는 않다. fragment shader가 diffuse texture 컬러만 출력하면 결과는 다음과 같다. 전체 코드 이제 두 개의 point light와 specular map 들을 사용하면 다음과 같은 결과를 얻을 수 있다. Assimp를 사용하여 많은 모델들을 로드할 수 있다. 일부 모델들은 잘 로드되지 않을 수 있는데, 이 경우 텍스처 경로가 잘못되었거나 Assimp가 불러오지 못하는 파일 포멧으로 추출된것.출처ModelModelHow To Texture Wavefront (.obj)Models for OpengGL" }, { "title": "[learn-opengl] Model Loading: Mesh", "url": "/posts/2022/03/15/00/39/opengl16/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-15 00:39:07 +0900", "snippet": "Mesh Assimp로 불러온 모델의 데이터를 OpenGL이 이해할 수 있는 포맷으로 변환시켜 오브젝트를 렌더링할 수 있도록 해야한다. mesh는 그려질 수 있는 하나의 독립체 Mesh가 최소한 어떠한 데이터들을 가지고 있어햐는지 정해야한다. 위치벡터, 법선 벡터, 텍스처 좌표 벡터를 포함하고 있는 vertex들의 모음이 필요하다. 또한 mesh는 인덱스를 사용하여 그리기 위한 index들을 포함할 수 있으며, 텍스처 형태(diffuse/specular map)의 material 데이터도 포함가능 아래와 같이 OpenGL에 vertex를 정의할 수 있다. struct Vertex { glm::vec3 Position; glm::vec3 Normal; glm::vec2 TexCoords;}; vertex attribute들을 찾는데 사용할 수 있는 벡터들을 위의 구조체에 저장한다. 텍스처 데이터는 아래와 같은 구조체에 저장한다. 텍스처의 id와 타입을 저장 ex. diffuse 텍스처, specular 텍스처 struct Texture { unsigned int id; string type;}; vertex와 텍스처에 대해 실제 이해했다면, 이제 mesh 클래스 의 구조를 정의할 수 있다.class Mesh { public: // mesh data vector&amp;lt;Vertex&amp;gt; vertices; vector&amp;lt;unsigned int&amp;gt; indices; vector&amp;lt;Texture&amp;gt; textures; Mesh(vector&amp;lt;Vertex&amp;gt; vertices, vector&amp;lt;unsigned int&amp;gt; indices, vector&amp;lt;Texture&amp;gt; textures); void Draw(Shader &amp;amp;shader); private: // render data unsigned int VAO, VBO, EBO; void setupMesh();}; mesh 클래스 생성자에게 mesh의 필수적인 모든 데이터를 준다. setupMesh함수: 버퍼들을 초기화하고, 마지막으로 Draw함수를 통해 mesh를 그린다. Draw함수에 shader를 준다: shader를 전해줌으로써 그리기 전에 여러가지 uniform들을 설정할 수 있다.(sampler들을 텍스처 유닛에 연결하는 것과 같은) 생성자 함수는 다음과 같다. 내부에서 setupMesh함수를 호출한다. Mesh(vector&amp;lt;Vertex&amp;gt; vertices, vector&amp;lt;unsigned int&amp;gt; indices, vector&amp;lt;Texture&amp;gt; textures){ this-&amp;gt;vertices = vertices; this-&amp;gt;indices = indices; this-&amp;gt;textures = textures; setupMesh();}Initialization 이 setupMesh() 덕분에 우리는 렌더링에 사용할 수 있는 mesh 데이터의 목록을 가질 수 있다. 적절한 버퍼들을 설정하고, vertex attribute pointer를 통해 vertex shader layout을 지정해주어야한다. void setupMesh(){ glGenVertexArrays(1, &amp;amp;VAO); glGenBuffers(1, &amp;amp;VBO); glGenBuffers(1, &amp;amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &amp;amp;vertices[0], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), &amp;amp;indices[0], GL_STATIC_DRAW); // vertex positions glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); glBindVertexArray(0);} 이제까지와 다르지 않다. Vertex struct의 도움을 받는다는 점만 빼면. C++에서의 Struct의 속성들은 메모리의 위치가 순차적으로 저장된다. 즉, struct 배열을 생성하면 순차적으로 변수들이 정렬되어, array buffer에 필요한 float(실제로는 byte)배열로 변환한다. Vertex struct 를 채워넣으면 이 메모리 레이아웃은 다음과 같음. Vertex vertex;vertex.Position = glm::vec3(0.2f, 0.4f, 0.6f);vertex.Normal = glm::vec3(0.0f, 1.0f, 0.0f);vertex.TexCoords = glm::vec2(1.0f, 0.0f);// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f]; 이러한 특성 덕분에 Vertex struct들을 buffer데이터로 전달할 수 있다. 이것들은 glBufferData함수에 파라미터로 들어갈 값들로 완벽하게 변환될 수 있다. glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices[0], GL_STATIC_DRAW); sizeof Vertex: 적절한 바이트 크기 32바이트(8floats*4바이트) Struct의 또다른 사용법 offsetof(s, m): 전처리기 지시문 파라미터1: struct 타입 파라미터2: 해당 struct 타입의 멤버 변수 이름 이 매크로는 struct에서 입력된 변수의 시작점 바이트 offset을 리턴한다 glVertexAttribPointer함수의 offset 파라미터를 정의하기에 좋다. 아래의 경우 법선 벡터의 바이트 offset은 12바이트(3floats * 4 바이트)로 설정된다. stride 파라미터는 Vertex struct의 크기로 설정하여 해당 속성만 알려줌 glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));Rendering Mesh 클래스를 완성하기 위해 Draw함수를 정의해야한다. mesh를 렌더링하기전, glDrawElements 함수를 호출하기 전에 적절한 텍스처를 바인딩해야한다. 하지만, 텍스처이 개수를 모르며, 어떤 타입인지 모르기 때문에 어려움 이 문제를 해결하기 위해 특별한 네이밍 관습을 적용할 것이다. 각, diffuse 텍스처는 texture_diffuseN 이라 이름을 붙이고 각, specular 텍스처는 texture_specularN 이라 이름을 붙인다. N은 1부터 텍스처 sampler에 허용되는 최댓값 사이의 어떠한 숫자이다. 3개의 diffuse와 2개의 specular 텍스처를 가지고 있다고 해보자 이들 sampler는 다음과 같다. uniform sampler2D texture_diffuse1;uniform sampler2D texture_diffuse2;uniform sampler2D texture_diffuse3;uniform sampler2D texture_specular1;uniform sampler2D texture_specular2; 이 네이밍 관습으로 인해 shader에서 텍스처 sampler를 있는만큼 모두 정의할 수 있다. 최종 드로잉 코드는 다음과 같다.void Draw(Shader &amp;amp;shader){ unsigned int diffuseNr = 1; unsigned int specularNr = 1; for(unsigned int i = 0; i &amp;lt; textures.size(); i++) { glActiveTexture(GL_TEXTURE0 + i); // activate proper texture unit before binding // retrieve texture number (the N in diffuse_textureN) string number; string name = textures[i].type; if(name == &quot;texture_diffuse&quot;) number = std::to_string(diffuseNr++); else if(name == &quot;texture_specular&quot;) number = std::to_string(specularNr++); shader.setFloat((&quot;material.&quot; + name + number).c_str(), i); glBindTexture(GL_TEXTURE_2D, textures[i].id); } glActiveTexture(GL_TEXTURE0); // draw mesh glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0);} 코드 설명 텍스처 타입마다 N 값을 계산, 적절한 uniform 이름을 얻기위해 텍스처 타입 문자열에 결합 적절한 sampler를 위치 시킴, 현재 활성화된 텍스처 유닛에 부합되는 위치값을 주고, 텍스처를 바인딩(Shader 를 파라미터로 받는 이유) 전체 코드출처Mesh" }, { "title": "[learn-opengl] Model Loading: Assimp", "url": "/posts/2022/03/14/21/05/opengl15/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-14 21:05:42 +0900", "snippet": "Assimp 이때까지는 단순한 정육면체를 가지고 놀았다.(정적인 컨테이너) 실제는 더 복잡한 모델들이 존재한다. 우리는 이 모델들을 import할 수 있다. 이 모델들은 Blender, 3DS Max, Maya 같은 툴을 사용하여 디자인한 것들이다. 이 툴들은 복잡한 도형을 만들 수 있도록 도와주고 여기에 uv-mapping라고 불리는 처리를 통해 텍스처를 적용시킨다. 이 툴들은 model파일 포멧으로 추출하면 모든 vertex 좌표들과 법선, 텍스처 좌표들을 자동으로 생성한다. 그래픽 프로그래머로서 이러한 기술적인 상세부분들을 신경써야한다 이러한 모델 파일들을 분석, 모든 관련된 정보들을 추출해야한다. 다양한 포맷들이 존재함. Wavefront와 같은 모델 포멧들: 모델 컬러, diffuse/specular map들과 같은 작은 material정보들과 함께 모델 데이터를 가지고 있다. Collada 파일 포멧과 같은 모델 포멧들: 모델, light, 다양한 종류의 material들, 애니메이션 데이터, 카메라, 완전한 scene 정보등을 아주 광범위하게 가지고 있다. 이런 다양한 포맷을 지원하려면, importer를 작성해야한다. 이는 라이브러리를 사용할 수 있다. A model loading library 가장 많이 사용하는 모델 importing 라이브러리는 Assimp라고 불리며 Open Asset Import Library를 의미한다. Assimp는 모든 모델의 데이터들을 Assimp가 생성한 데이터 구조로 불러옴 많은 종류의 모델 파일 포멧을 import(그리고 추출하는 것 또한 가능)할 수 있다. Assimp가 모델을 로드하기만 하면 Assimp의 데이터구조에서 우리가 원하는 모든 데이터를 얻을 수 있다 Assimp의 데이터구조가 import된 파일 포멧의 유형과 관계없이 동일하게 유지되기 때문에 모든 다른 파일 포멧들을 추상화해준다. Assimp를 통해 모델을 Import할 때 전체적인 모델을 import된 모든 모델/scene을 포함하고 있는 scene 객체에 불러온다. Assimp는 노드의 모듬을 가지게 되는데 각 노드는 자신의 자식 모드들을 인덱싱할 index들을 가지고 있다. (간단하게) Assimp의 구조 모델은 다음과 같다. Scene/model의 모든 데이터는 모든 material, mesh들과 마찬가지로 Scene 객체에 포함된다. 또한 이는 scene의 루트 노드에 대한 참조를 가지고 있다. Scene의 루트 노드는 자식 노드들을 포함(다른 모든 노드들과 마찬가지로)할 수 있고, Scene 객체의 mMeshes 배열 안의 데이터를 가리키는 인덱스들의 모음을 가지고 있다. 이 루트 노드의 mMeshes 배열은 실제 Mesh객체들을 가지고 있고, 일반노드의 mMeshesM 배열에 들어있는 값은 오직 scene의 mesh 배열에 대한 index들만 가지고 있다. Mesh객체는 렌더링하는 데에 필요한 모든 관련 데이터들을 포함한다. 오브젝트의 vertex 위치, 법선 벡터, 텍스처 좌표, 면, material 등 Mesh는 여러 개의 면들을 가진다. 면(Face)은 렌더링 primitive(삼각형, 사각형, 점)를 나타낸다. 면은 primitive를 형성하기 위한 vertex들의 index를 가지고 있다. vertex들과 index들이 분리되어있기 때문에 index버퍼를 통해 렌더링하는 것을 쉽게 만들어 준다. 마지막으로 mesh는 Material객체도 가지고 있다. - 이 객체는 오브젝트의 material 속성들을 얻기위한 여러 함수들을 관리한다. - texture map(diffuse map, specular map)과 컬러같은 것 먼저 해야할 일은 Scene객체에 오브젝트를 불러오는 것이다. 각 노드들의 해당 Mesh객체들을 재귀적(각 노드의 자식들을 재귀적으로 검색)으로 얻고, vertex 데이터와 index, material 속성들을 얻기 위해 각 Mesh객체를 처리한다. 그 결과는 하나의 Model 객체에 포함시킬 mesh 데이터의 모음이된다. Mesh: 모델링 툴에서 오브젝트를 모델링할 때 일반적으로 각 모델은 여러개의 서브 모델/도형을 가지고 있다. 하나의 모델을 이루는 각각의 서브 모델/도형들은 mesh라고 불린다. 이러한 mesh들을 결합하여 결과물을 만든다. 하나의 mesh는 OpenGL에서 오브젝트를 그리기위해 필요힌 최소한의 것을 나타낸다.(vertex 데이터, index, material 속성들), 모델은 일반적으로 여러 mesh들로 이루어짐. 앞에서는 Model 과 Mesh 클래스를 생성할 것이다. 이 클래스들은 import된 모델들을 우리가 설명한 구조를 사용하여 불러오고 저장한다. 그런 다음 이 모델을 그리기 원한다면, 이 모델 전체를 렌더링하지 않고 이 모델을 이루고 있는 각각의 모든 mesh들을 렌더링한다. 하지만 모델들을 import하기 전에 먼저 프로젝트에 Assimp를 추가해야한다. Building Assimp Assimp는 여기서 다운받을 수 있다. 스스로 라이브러리를 컴파일하는것이 좋다. 미리 컴파일된 라이브러리는 대부분의 시스템에서 제대로 동작하지 않기 때문. 출처Assimp" }, { "title": "[learn-opengl] Lighting: Multiple lights", "url": "/posts/2022/03/14/08/46/opengl14/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-14 08:46:44 +0900", "snippet": "Multiple lights 이번에는 6개의 광원들을 생성한다. directional light로 태양과 같은 빛을 시뮬레이션 4개의 point light를 사용하여 scene 전체에 빛을 산란 flashlight 추가 하나 이상의 광원을 scene에 사용하기 위해, lighting 계산을 GLSL의 함수로 작성할 것이다. main에 다 계산하면 코드 읽기 불편하다. glsl의 함수는 C와 비슷(프로토타입, 리턴, 이름 등) 여러가지 light를 사용할 때 접근 방식은 일반적으로 다음과 같이 한다. fragment의 출력 칼라를 나타내는 하나의 컬러 벡터. 각 light들을 위해 이 fragment에 light가 기여하는 컬러를 이 fragment의 출력 컬러에 더함. scene의 각 light는 fragment에 미치는 효과를 계산하고 최종 출력 컬러에 기여하게됨. out vec4 FragColor;void main(){ // define an output color value vec3 output = vec3(0.0); // add the directional light&#39;s contribution to the output output += someFunctionToCalculateDirectionalLight(); // do the same for all point lights for(int i = 0; i &amp;lt; nr_of_point_lights; i++) output += someFunctionToCalculatePointLight(); // and add others lights as well (like spotlights) output += someFunctionToCalculateSpotLight(); FragColor = vec4(output, 1.0);} 실제 코드는 구현에 따라 다르지만 일반적인 구조는 동일함 광원에 대한 효과를 계산하는 여러가지 함수들을 정의하고, 그 결과 컬러를 출력 컬러 벡터에 더한다. Directional light fragment shader에 함수를 정의하는 것 이 함수는 해당 fragment에 대한 directional light의 기여도를 계산한다. 몇 가지의 파라미터를 받고 계산된 directional lighting를 리턴함 먼저 필요한 변수들을 설정 DirLight 구조체에 필요한 변수들을 담고, uniform으로 선언 struct DirLight { vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;};uniform DirLight dirLight; 그런다음 dirLight 를 함수에 넘겨준다.vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir); C언어처럼 프로토타입을 main 함수 위에 두고 main 밑에 함수 작성 가능 이 함수는 DirLight 타입과 두개의 벡터를 필요로한다. 이 함수의 내용은 다음과 같다. vec3 CalcDirLight(DirLight light, vec3 normal, vec3 viewDir){ vec3 lightDir = normalize(-light.direction); // diffuse shading float diff = max(dot(normal, lightDir), 0.0); // specular shading vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); // combine results vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); return (ambient + diffuse + specular);} 이전에 작성한 코드를 복사한것. 하나의 컬러 벡터로 리턴 Point light 마찬가지로 attenuation과 함께 함수로 정의struct PointLight { vec3 position; float constant; float linear; float quadratic; vec3 ambient; vec3 diffuse; vec3 specular;};#define NR_POINT_LIGHTS 4uniform PointLight pointLights[NR_POINT_LIGHTS]; scene에 배치할 point light의 갯수를 GLSL에서 전처리기로 선언한 것을 볼 수 있다. 프로토 타입은 다음과 같다. 이 함수는 필요한 모든 데이터를 파라미터로 받고, fragment에 대한 특정한 point light의 기여 컬러를 나타내는 vec3을 리턴한다. vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir); 아래와 같은 함수를 생성할 수 있다.vec3 CalcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir){ vec3 lightDir = normalize(light.position - fragPos); // diffuse shading float diff = max(dot(normal, lightDir), 0.0); // specular shading vec3 reflectDir = reflect(-lightDir, normal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); // attenuation float distance = length(light.position - fragPos); float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); // combine results vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords)); ambient *= attenuation; diffuse *= attenuation; specular *= attenuation; return (ambient + diffuse + specular);} 이 함수를 반복문으로 호출하여 여러개의 point light를 계산할 수 있다.Putting it all together 이제 다음과 같이 계산할 수 있다.void main(){ // properties vec3 norm = normalize(Normal); vec3 viewDir = normalize(viewPos - FragPos); // phase 1: Directional lighting vec3 result = CalcDirLight(dirLight, norm, viewDir); // phase 2: Point lights for(int i = 0; i &amp;lt; NR_POINT_LIGHTS; i++) result += CalcPointLight(pointLights[i], norm, FragPos, viewDir); // phase 3: Spot light //result += CalcSpotLight(spotLight, norm, FragPos, viewDir); FragColor = vec4(result, 1.0);} 여기서 함수안에 많은 중복된 계산들이 있다.(reflect vecto, specular, diffuse, sampling the material textures). 이런 코드들이 최적화할 수 있는 부분이다. 모든 광원이 처리될 때까지 각 light 타입은 그들의 기여도를 최종 출력 컬러에 더한다. 최종 컬러는 scene의 모든 광원들의 컬러 효과를 포함하고 있다. point light uniform 은 배열이기 때문에 여기서 잠깐 설명한다. 하나의 struct uniform을 설정하는 것과 비슷하다. lightingShader.setFloat(&quot;pointLights[0].constant&quot;, 1.0f); 하지만 이렇게 하면 코드가 길어지니 추상화할 수 있지만, 결국에는 모든 light들의 uniform을 설정해야함. 또한 point light들의 위치 벡터를 정의해서 scene에 배치할 수 있다. glm::vec3 pointLightPositions[] = { glm::vec3( 0.7f, 0.2f, 2.0f), glm::vec3( 2.3f, -3.3f, -4.0f), glm::vec3(-4.0f, 2.0f, -12.0f), glm::vec3( 0.0f, 0.0f, -3.0f)}; 이제 잡다한 코드들을 작성하면 다음과 같은 결과가 나온다. 전체적으로 밝은것을 볼 수 있고, 빛을 산란하는 4개의 light, flashlight는 플레이어 시점을 기준으로 보이는것을 볼 수 있다.전체 코드출처Multiple-lightsMultiple-lights" }, { "title": "[shader] 노트", "url": "/posts/2022/03/14/07/32/shader0/", "categories": "graphics, graphics-shader", "tags": "shader", "date": "2022-03-14 07:32:09 +0900", "snippet": "learn-opengl에 나온 계산들vsFrag 위치FragPos = vec3(model * vec4(aPos, 1.0));Normal 행렬Normal = mat3(transpose(inverse(model))) * aNormal;fsfrag에서 광원까지의 방향vec3 lightDir = normalize(light.position - FragPos);" }, { "title": "[learn-opengl] Lighting: Light casters", "url": "/posts/2022/03/14/02/30/opengl13/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-14 02:30:27 +0900", "snippet": "Light casters 여러 유형의 빛들이 존재. 오브젝트에 빛을 캐스트하는 광원을 light caster라고 한다. Directional Light 멀리 있는 광원에서 나오는 광선은 거의 서로 평행하다. 광원이 무한히 멀리 있으면 모두 동일한 방향에서 온다. 이를 directional light라고 부른다 모든 광선들은 평행함 =&amp;gt; 광원의 위치 정보 필요 없음 대신 방향벡터가 필요. light.direction 벡터를 추가. 일반적으로 directional light를 광원으로부터 fragment로 향하는 방향으로 나타내는것을 선 그러므로 부호를 바꾸어 반대 방향으로 설정해야함 즉, 광원을 향하는 벡터 추가적으로 정규화도 해줘야한다. struct Light { // vec3 position; // no longer necessary when using directional lights. vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular;};//[...]void main(){ vec3 lightDir = normalize(-light.direction); //[...]} lightDir벡터는 diffuse, specular 계산에 사용된다. 좌표시스템의 예제인 여러 박스가 있는 씬을 사용할것이다. 10개의 다른 박스의 위치를 정의했었고. 적절한 변환을 가지고 있는 model 행렬을 생성했음. for(unsigned int i = 0; i &amp;lt; 10; i++){ glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); lightingShader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 36);} 또한 광원의 방향을 지정해야함. 지금은 광원으로부터 나오는 아래쪽 방향. lightingShader.setVec3(&quot;light.direction&quot;, -0.2f, -1.0f, -0.3f); vec4 타입으로 정의할 수 있다. 이 때 위치 벡터는 ‘w’ 요소를 1.0 으로 설정하여 변환이 올바르게 적용되도록 해야하지만, 방향 벡터는 이동변환이 영향을 미치지 않아야하기 때문에 w요소를 0.0으로 정의해야한다. (아핀변환 점과 벡터의 차이) 방향벡터들은 vec4(-0.2f, -1.0f, -0.3f, 0.0f) 과 같이 표현된다. 이는 빛의 유형을 쉽게 판단할 수 있게해준다. w 요소가 1.0이면 빛의 위치벡터이고, 0.0이면 방향벡터이므로 이를 아래와 같이 사용할 수 있다.if(lightVector.w == 0.0) // note: be careful for floating point errors // do directional light calculationselse if(lightVector.w == 1.0) // do light calculations using the light&#39;s position (as in previous chapters) 이는 실제로 광원이 directional light인지 positional light인지 판단하기위해 OpenGL 구버전에서 사용된적이 있었음.전체 코드Point Lights Directional light들은 전체 Scene을 밝히는 전반적인 빛에 사용되는 것이 좋다. 일반적으로 Scene 전체에 산란되는 여러 point light들도 사용한다. world의 어딘가에 주어진 위치를 갖는 광원 모든 방향으로 빛을 밝힘. 거리에 따라 광선은 희미 전구나 횃불같음 이전의 내용들이 바로 point light의 간단한 버전 이전의 것은 거리 상관없이 구현했음. 보통 이와 같이 구현하지 않고, 광원과 가까이에 있는 특정 영역만 밝힘. 거리에 따른 공식을 사용해야한다. 광원과 가까이 있는 컨테이너들과 비교해서 멀리 떨어진 컨테이너는 약간의 빛만 받기를 원한다. Attenuation 광선이 지나가는 거리에 따라 빛의 세기를 줄이는 것. 다음 공식은 광원과 fragment 사이의 거리를 기반으로 하는 감쇠값을 계산한다. 이 값을 나중에 빛의 세기 벡터에 곱할 것이다. \\[\\begin{equation} F_{att} = \\frac{1.0}{K_c + K_l * d + K_q * d^2} \\end{equation}\\] d: fragment에서 광원까지의 거리 설정가능한 상수항 K_c, linear(1차)항인 K_l, quadratic(2차)항인 K_q 상수항은 일반적으로 1.0을 유지. 최종 결과의 분모를 1보다 작게 만들지 않도록하기위해 존재. 그렇지 않으면 특정 거리에서 빛의 세기를 증폭시켜 원하는 효과를 낼 수 없다. 1차항: 거리 값과 곱해짐. 1차원 방법으로 세기를 감소시킴 2차항: 거리의 사분면과 곱해짐. 2차원적으로 광원의 세기를 감소. 거리가 가까울 때 이 2차항은 1차항에 비해 덜 중요해짐. 거리가 멀때는 1차항보다 중요해짐. 2차항 때문에 거리가 충분히 커질 때까지 빛의 세기는 1차원적인 방법으로 빠르게 감소됨. 빛이 가까운 범위내에 있을 때 상당히 밝고, 거리에따라 빠르게 어두워지며, 결국에는 점점 느린 속도로 어두워지게 되는 효과이다. 다음 그래프는 이러한 감쇠효과를 보여준다. 이 빛은 거리가 작을 때 높은 세기를 가지고, 거리가 커질수록 세기가 상당히 많이 줄어, 느리게 0으로 다가간다.Choosing the right values 3가지 항에대해 올바른 값을 설정해야한다. 케이스마다 다르며, 경험이 필요하다. 아래의 표는 특정한 반지름(거리)를 커버하는 현실적인 광원을 시뮬레이션하기 위해 가질 수 있는 항들의 값을 보여준다. Distance Constant Linear Quadratic 7 1.0 0.7 1.8 13 1.0 0.35 0.44 20 1.0 0.22 0.20 32 1.0 0.14 0.07 50 1.0 0.09 0.032 65 1.0 0.07 0.017 100 1.0 0.045 0.0075 160 1.0 0.027 0.0028 200 1.0 0.022 0.0019 325 1.0 0.014 0.0007 600 1.0 0.007 0.0002 3250 1.0 0.0014 0.000007 위에서 볼수 있는 정보 상수항은 항상 1.0이다. 1차항, 2차항은 거리가 클수록 꽤 작은 값을 가짐 Implementing attenuation 위의 항들을 이제 코드에 넣어보자 constant, linear, quadratic struct Light { vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; float constant; float linear; float quadratic;}; 그다음 값을 설정한다.lightingShader.setFloat(&quot;light.constant&quot;, 1.0f);lightingShader.setFloat(&quot;light.linear&quot;, 0.09f);lightingShader.setFloat(&quot;light.quadratic&quot;, 0.032f); fragment shader에서 attenuation을 구현해야한다. 공식을 그대로 사용하여 계산 거리는 간단히 벡터 뺄셈으로 얻는다. float distance = length(light.position - FragPos);float attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance)); 그런다음 이 감쇄값을 컬러에 곱하여 lighting 계산에 포함시킨다. Ambient요소를 건드리지 않고, ambient lighting이 거리에 따라 어두워지지 않게 할 수 있음. 하지만 한 개 이상의 광원을 사용하게된다면, ambient 컴포넌트들은 쌓이게됨. 이 경우 ambient lighting에도 attenuation을 적용해야함. 환경에 따라 최적의 조건으로 설정해야함. ambient *= attenuation;diffuse *= attenuation;specular *= attenuation; 이제 다음과 같은 결과가 나온다.전체소스 Point light: lighting 계산에 적용되는 위치와 attenuation을 설정할 수 있는 광원Spot light 이는 환경의 어딘가에 위치한 광원이다. 모든 방향으로 광선을 쏘지 않고, 특정 방향으로만 씀. 결과적으로 spotlight 방향의 특정 반지름 내부에 있는 오브젝트만 밝아지고 나머지는 어두워짐. OpenGL의 spotlight는 world-space에서의 위치, 방향, cutoff 각도로 나타낸다. 각 fragment에 대해 spotlight의 cutoff방향 사이(원뿔 내부)에 있는지 계산한다. 그리고 사이에 있으면 밝힌다.(아래 그림 참고) LightDir: frag에서 광원까지의 방향 벡터 SpotDir: spotlight가 겨누고 있는 방향 벡터 Phi ϕ:: spotlight의 반지름 지정하는 cutoff각도, 이 각 외부에 있는 모든것들은 빛을 받지 못함. Theta θ: LightDir 벡터와 SpotDir 벡터 사이의 각도. spotlight의 내부에 있기 때문에 이는 Phi 값보다 작아야함. 계산에서 먼저, LightDir벡터와 SpotDir벡터를 내적하여 이를 cutoff 각 과 비교해야한다. Flash Light Flashlight는 viewer의 위치에 있고, 플레이어의 관점을 향해 똑바로 겨누고 있는 spotlight이다. 위치와 방향이 플레이어의 위치와 방향에 따라 계속해서 업데이트된다. 이를 위해 필요한 값들은 spotlight의 위치 벡터(빛 방향 계산용), 방향 벡터, cutoff 각도이다. struct Light { vec3 position; vec3 direction; float cutOff; //...}; 그다음 코드에서 값을 넘겨주자lightingShader.setVec3(&quot;light.position&quot;, camera.Position);lightingShader.setVec3(&quot;light.direction&quot;, camera.Front);lightingShader.setFloat(&quot;light.cutOff&quot;, glm::cos(glm::radians(12.5f))); Cutoff 값에서 cos 값으로 넘겨준것을 주의해야한다. LightDir 와 spotDir 벡터의 내적을 계산, 내적은 각이 아닌 cos 값을 반환하므로. cos값끼리 직접 비교하기 위함. 역연산을 통해 각을 구하는것은 비싼 연산이다. 그래서 cos값으로 전달함. 남은 것은 theta θ값을 계산하고, 이를 cutoff 값과 비교하여 spotlight의 내부에 있는지 판단한다. float theta = dot(lightDir, normalize(-light.direction));if(theta &amp;gt; light.cutOff){ // do lighting calculations}else{ // else, use ambient light so scene isn&#39;t completely dark outside the spotlight. color = vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0);} 먼저 lightDir 벡터와 부호를 바꾼 direction 벡터의 내적을 계산한다. 부호 바꾼이유: 광원을 향하는 벡터가 필요하기 때문. 주의: 관련 벡터들이 정규화되어 있어야한다. cosine 값으로 비교하므로 theta가 cutoff값보다 커야한다. 위에서 설정한 각도가 12.5 이므로 0~12.5 의 범위 안에 들어와야한다. 아래 코사인 그래프를 보면, 이는 0.9979 와 1.0 내부에 들어와야 하기 때문. 이제 다음과 같은 결과가 나온다. 전체 코드 spotlight의 외곽선을 좀 더 부드럽게 해야한다. spotlight는 외곽선에서 점차적으로 빛을 감소시킨다. Smooth/Soft edges 부드러운 외곽선을 가진 spotlight를 생성하기 위해, inner 원뿔과 outer 원뿔을 가지도록 해야한다. inner: 앞서 정의한 원뿔 outer: 좀 더 큰 원뿔로, 점점 빛이 어두워지는 원뿔 outer 원뿔 생성 spotlight의 방향 벡터와 외부 원뿔의 벡터(반지름)사이의 각에 대한 cosine 값을 정의하면된다. fragment가 inner과 outer 사이에 있으면 빛의 세기 값을 0.0 ~ 1.0 사이로 계산한다. inner에 있으면 빛의 세기는 1.0 outer 밖에 있으면, 0.0 다음 공식을 사용하여 빛의 세기를 계산할 수 있다. ϵ (epsilon): inner (ϕ)원뿔과 outer (γ) 원뿔의 차이 (ϵ=ϕ−γ) 최종 결과인 I 값은 현재 fragment의 spotlight 빛의 세기이다. \\[\\begin{equation} I = \\frac{\\theta - \\gamma}{\\epsilon} \\end{equation}%\\] 이 공식에 관한 표는 다음과 같다. θ θ in degrees ϕ (inner cutoff) ϕ in degrees γ (outer cutoff) γ in degrees ϵ I 0.87 30 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.87 - 0.82 / 0.09 = 0.56 0.9 26 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.9 - 0.82 / 0.09 = 0.89 0.97 14 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.97 - 0.82 / 0.09 = 1.67 0.83 34 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.83 - 0.82 / 0.09 = 0.11 0.64 50 0.91 25 0.82 35 0.91 - 0.82 = 0.09 0.64 - 0.82 / 0.09 = -2.0 0.966 15 0.9978 12.5 0.953 17.5 0.9978 - 0.953 = 0.0448 0.966 - 0.953 / 0.0448 = 0.29 위 식에서 볼 수 있듯이, inner cosine outer cosine 사이를 theta 값을 기반으로 보간하고 있다. 이제 우리는 빛의 세기 값을 가지고 있지만, 이 값은 spotlight outer에 있으면 음수 값을 가지고 inner에 있을 때 1.0보다 큰 값을 가지게 된다. 이 값을 적절하게 고정시킨다면 fragment shader에 if문을 제거할 수 있다. 그후, 계산된 세기 값을 light 컴포넌트들에 곱해야함. float theta = dot(lightDir, normalize(-light.direction));float epsilon = light.cutOff - light.outerCutOff;float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);...// we&#39;ll leave ambient unaffected so we always have a little light.diffuse *= intensity;specular *= intensity;... 여기에서는 보여주지는 않았지만, outerCutOff 값을 추가하고 uniform 값을 설정하고,inner cutoff를 12.5, outer cutoff을 17.5로 설정했다.전체 코드 이러한 flashlight/spotlight 타입의 램프는 공포게임에 사용하기 좋다. directional light와 point light를 조합하면 환하게 만들 수있다. 출처Light-castersLight-casters" }, { "title": "[learn-opengl] Lighting: Lighting maps", "url": "/posts/2022/03/13/00/11/opengl12/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-13 00:11:08 +0900", "snippet": "Lighting maps 실제 사물들은 여러 material로 이루어져 있다. 좀더 정확하게 묘사하도록 오브젝트의 시각적 출력에대해 유연성을 줘보자Diffuse maps 오브젝트에 대한 각각의 fragment들의 diffuse 컬러를 설정해야한다. 이는 텍스처와 같다. 빛이 존재하는 scene에서는 이 텍스처 이미지가 오브젝트의 모든 diffuse 컬러들을 나타내기 때문에 일반적으로 diffuse map 이라고 부른다. 아래 이미지를 사용하여 작업을 할것이다. 셰이더에서 diffuse map을 사용하는것은 정확히 텍스처와 동일. 추가적으로, material struct내부에 sampler2D로 저장한다.(vec3 을 sampler2D로) 또한 ambient 컬러는 대부분 diffuse 컬러와 동일하므로, 제거한다. 그리고 fragment 셰이더에 텍스처 좌표가 필요하므로 입력 변수 선언 sampler2D는 오직 uniform으로만 정의할 수 있는 opaque type이라고 불린다. 만약 uniform이 아닌 다른 형태로 인스턴스화(함수 파라미터 등) 한다면 오류, 이는 opaque type을 가지고 있는 모든 struct 에 동일하게 적용됨struct Material { sampler2D diffuse; vec3 specular; float shininess;};in vec2 TexCoords; fragment 셰이더에 diffuse 컬러 값을 얻기 위해 텍스처를 간단히 샘플링한다.vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords)); 또한, ambient material 도 diffuse matterial 컬러와 똑같게한다.vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords)); 이제 vertex 데이터에 텍스처 좌표를 업데이트하고, vertex attribute로서 fragment shader로 전달해야한다. 텍스처를 로드하고 적절한 텍스처 유닛에 바인딩 수정된 vertex data 이 vertex 데이터는 지금 큐브의 각 vertex에 대해 vertex 위치, 법선 벡터, 텍스처 좌표를 포함한다, 수정된 fragment 셰이더는 다음과 같다. #version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;layout (location = 2) in vec2 aTexCoords;...out vec2 TexCoords;void main(){ ... TexCoords = aTexCoords;} VAO 역시 수정해야한다.lightingShader.setInt(&quot;material.diffuse&quot;, 0);...glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, diffuseMap); 이제 아래와 같이 보일것이다. 전체 코드Specular maps 위의 이미지에서 나무부분에 specular 하이라이트를 제거해보자. 이를 위해 텍스처 맵하나를 사용한다.(아래 이미지) specular 하이라이트의 세기는 위 이미지의 각 픽셀의 밝기로 얻을 수 있다. 검정색 =&amp;gt; vec3(0.0) =&amp;gt; 어두워짐 fragment shader에서 해당 컬러 값을 샘플링하고, light의 specular 세기와 곱한다. Sampling specular maps Specular map은 다른 텍스처들과 비슷 diffuse map코드와 비슷 아래와 같이 다른 채널 1에 바인딩 lightingShader.setInt(&quot;material.specular&quot;, 1);...glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, specularMap); sampler2D로 변경struct Material { sampler2D diffuse; sampler2D specular; float shininess;}; 샘플링vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoords));vec3 diffuse = light.diffuse * diff * vec3(texture(material.diffuse, TexCoords));vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));FragColor = vec4(ambient + diffuse + specular, 1.0); 흑백 이미지를 사용하여 오직 세기만을 얻는다.전체 코드 이런 매핑을 통해, 디테일을 살릴 수 있음. Normal/Bump map 이나 reflection maps 같은 다른 텍스처 맵을 사용하여 디테일을 좀 더 살릴 수 있다.출처Lighting maps" }, { "title": "[learn-opengl] Lighting: Materials", "url": "/posts/2022/03/12/21/27/opengl11/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-12 21:27:00 +0900", "snippet": "Materials 실제 세계에서 사물들은 빛에 각자 다르게 반응한다. 철로된 사물과 너무로된 사물은 빛에 반응 정도가 다르다. 이에따라 specular 하이라이트도 다르게 반응한다. 이를 시뮬레이션하기위해 필요한게 material 속성 material에 3가지 lighting 요소인 ambient, diffuse, specular를 정의할 수 있다. 각 요소에 컬러를 지정하여, 객체의 컬러 출력을 세부적으로 제어할 수 있음. shininess 컴포넌트를 추가하면, 지금 필요한 모든 속성을 가지게된다. #version 330 corestruct Material { vec3 ambient; vec3 diffuse; vec3 specular; float shininess;};uniform Material material; material의 속성을 위와 같이 struct로 저장할 수 있다. 그리고 uniform 변수로 접근한다. Phong 모델의 요소들에 대한 컬러 벡터 정의 ambient: 주변광에 대해 어떤 컬러를 반사할지 정의(보통 오브젝트의 컬러와 동일) diffuse: 분산광에 대한 컬러 설정, 원하는 오브젝트의 컬러 specular: 반사광에 영향을 받아 생성되는 컬러 설정 shininess: 객체의 반사는 아무런 영향을 받지 않는다. 오브젝트의 material을 정의하하면, 실세계의 재질을 시뮬레이션할 수 있다. 테이블 &amp;lt;-이를 사용하여 시뮬레이션할 수 있음. 이런 material속성을 설정하여 보기좋게 만드는것은 어려움.Setting materials 이제 새로운 material 속성을 사용하여 lighting 계산을 해야한다. 각 속성들은 lightingColor와 곱해진다. void main(){ // ambient vec3 ambient = lightColor * material.ambient; // diffuse vec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos); float diff = max(dot(norm, lightDir), 0.0); vec3 diffuse = lightColor * (diff * material.diffuse); // specular vec3 viewDir = normalize(viewPos - FragPos); vec3 reflectDir = reflect(-lightDir, norm); float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess); vec3 specular = lightColor * (spec * material.specular); vec3 result = ambient + diffuse + specular; FragColor = vec4(result, 1.0);} glsl의 struct를 cpp코드에서 설정할 때, 아래 코드처럼 struct 이름의 접두사가 붙은 uniform 변수를 사용해야함lightingShader.setVec3(&quot;material.ambient&quot;, 1.0f, 0.5f, 0.31f);lightingShader.setVec3(&quot;material.diffuse&quot;, 1.0f, 0.5f, 0.31f);lightingShader.setVec3(&quot;material.specular&quot;, 0.5f, 0.5f, 0.5f);lightingShader.setFloat(&quot;material.shininess&quot;, 32.0f); 이제 코드를 실행해보면 아래와 같을 것이다.Light properties 위 이미지에서 오브젝트는 너무 밝음. 모든 요소의 컬러들이 모든 광원으로부터 완전하게 반사되기 때문. 광원은 ambient, diffuse, specular 컴포넌트마다 각각 세기가 다르다. 각 lighting 요소를 조절하는 세기 벡터를 선언해야한다. 빛의 속성을 위해 material struct와 비슷한 것을 만들어야한다. struct Light { vec3 position; vec3 ambient; vec3 diffuse; vec3 specular;};uniform Light light; 광원은 ambient, diffuse, specular 빛에 대해 다른 세기를 가진다. ambient: 일반적으로 작은 세기 diffuse: 일반적으로 우리가 원하는 정확한 컬러로 설정(밝은 흰색) specular: 일반적으로 최대 vec3(1.0) 추가적으로 빛의 위치벡터 material uniform과 마찬가지로 fragment shader를 수정해야한다. vec3 ambient = light.ambient * material.ambient;vec3 diffuse = light.diffuse * (diff * material.diffuse);vec3 specular = light.specular * (spec * material.specular); 그런다음 응용프로그램에서 빛의 세기를 설정한다.lightingShader.setVec3(&quot;light.ambient&quot;, 0.2f, 0.2f, 0.2f);lightingShader.setVec3(&quot;light.diffuse&quot;, 0.5f, 0.5f, 0.5f); // darken diffuse light a bitlightingShader.setVec3(&quot;light.specular&quot;, 1.0f, 1.0f, 1.0f); 이제 다음과 같이 약간 어두워졌다.Different light colors 이제 빛의 속성에 쉽게 접근할 수 있으며, 컬러를 변경할 수있다. sin, glfwGetTime 함수를 통해 빛의 ambient, diffuse 컬러를 수정하여, 시간이 지남에 따라 빛의 컬러를 쉽게 수정할 수 있다.glm::vec3 lightColor;lightColor.x = sin(glfwGetTime() * 2.0f);lightColor.y = sin(glfwGetTime() * 0.7f);lightColor.z = sin(glfwGetTime() * 1.3f);glm::vec3 diffuseColor = lightColor * glm::vec3(0.5f);glm::vec3 ambientColor = diffuseColor * glm::vec3(0.2f);lightingShader.setVec3(&quot;light.ambient&quot;, ambientColor);lightingShader.setVec3(&quot;light.diffuse&quot;, diffuseColor);전체 코드출처Materials" }, { "title": "[learn-opengl] Lighting: Basic Lighting", "url": "/posts/2022/03/12/06/08/opengl10/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-12 06:08:50 +0900", "snippet": "Basic Lighting 실생활의 조명: 매우 복잡 OpenGL의 조명: 처리되기 쉽고, 실세계의 사물과 비슷하게 보이는 모델을 사용, 실세계에 대한 근사치 기반 Phong Lighting model이 그 중 하나. Phong 모델은 3가지의 요소로 이루어짐 ambient lighting(주변광): 조명이 어딘가에 있으면, 오브젝트는 완전히 어두워지지 않음. 이를 시뮬레이션하기 위해 항상 객체에 약간의 색상을 주는 주변 조명 상수가 필요 diffuse lighting(분산광): 밝은 물체가 물체에 미치는 방향 충돌을 시뮬레이션한다. 조명 모델에서 가장 시각적으로 중요한 구성요소. 물체의 일부가 광원을 향할수록 밝아진다. specular lighting(반사광): 반짝이는 물체에 나타나는 빛의 밝은 부분을 시뮬레이션한다. 반사 하이라이트=&amp;gt; 객체의 색상보다 빛의 색상에 가깝 Phong모델 이 3가지 요소들을 시뮬레이션해야함Ambient lighting 빛은 하나의 광원이 아니라, 많은 광원들로부터 온다. 빛의 특성 중 하나: 어떠한 지점에 도달하기 위해 여러 방향으로 퍼지고 산란 빛 == 면에서 반사되어 어떠한 물체의 간접적인 영향을 준다. 이를 고려한 알고리즘: global ilumination알고리즘 이 알고리즘은 비용이 비싸며 매우 복잡함. global ilumination 알고리즘보다 간단한 모델을 사용할것임. 이를 ambient lighting라고 부름 ambient lighting 추가 빛의 컬러 정함 작은 상수 ambient 요소와 곱함. 이를 오브젝트의 컬러와 곱하여 fragment의 컬러로 사용 void main(){ float ambientStrength = 0.1; vec3 ambient = ambientStrength * lightColor; vec3 result = ambient * objectColor; FragColor = vec4(result, 1.0);} 이제 프로그램을 실행시키면, 조명의 첫 번째 단계가 적용된것을 확인 가능 이 오브젝트는 거의 안보이지만, 완전히 안보이지는 않다.(조명램프는 다른 shader 사용하기 때문에 영향없음) Diffuse Lighting 분산광은 광원에서 오는 광선에 오브젝트의 fragment가 더 가깝게 위치할수록 오브젝트의 밝기가 높아진다. 오브젝트 하나의 fragment에 광선과 fragment 사이의 각이 필요하다. 광선이 오브젝트의 면에 수직으로 향한다면 빛은 아주 많이 영향을 끼칠것이다. 광선과 fragment 사이의 각을 측정하기 위해서는 법선 벡터(normal vector)라고 불리는 것을 사용한다. 법선 벡터: fragment 면에 대해 수직인 벡터이다.(위 이미지에서 노란 화살표) 사이각은 내적을 통해 얻을 수 있다. 두 벡터 사이의 각이 90일 경우, 내적은 0이된다. 두 벡터 사이의 각 theta의 값이 크면, 빛의 영향을 더 적게 받게됨. 두 벡터 사이의 코사인을 얻기 위해 정규화된 벡터를 사용해야한다. 내적 결과값(스칼라)을 fragment의 색상에 미치는 빛의 영향을 게산하는데 사용할 수 있다. 즉, diffuse lighting을 계산하기 위해 Normal vector, The directed light ray 가 필요하다. 레이를 계산하기 위해 빛의 위치 벡터와 fragment의 위치 벡터가 필요하다. Normal vectors 법선벡터 vertex는 단지 점 vertex의 면을 알아내기 위해 주변의 vertex들을 사용하여 벡터를 구해야한다. 간단한 큐브이므로, 수작업으로 추가 가능하다. 외적을 사용할 수 있다고한다. 수정된 vertex data vertex 배열에 데이터를 추가했으므로 lighting vertex shader를 수정해야함.#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aNormal;//... 램프는 같은 vertex data를 사용하지만, 추가된 법선 벡터를 사용하지 않음. 그냥 vertex atribute pointer에 vertex 배열 크기를 반영해야함.(3개의 데이터만 사용함, 그러므로 노멀벡터는 뛰어넘기위해 6을 stride에 곱해줌) 이런 vertex 데이터는 이미 GPU메모리 안에 저장되어 있기 때문에, GPU 메모리에 새로운 데이터를 저장할 필요가 없다. (새로운 VBO 할당보다 효율적) glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 모든 빛 계산은 fragment shader에서 완료되므로, 법선벡터를 전달해야함 out vec3 Normal;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0); Normal = aNormal;} fragment shader에 Normal을 입력변수로 선언해야함.in vec3 Normal;Caculating the diffuse color fragment 위치 벡터와 광원의 위치벡터가 필요하다. 광원의 위치 == 하나의 정적인 변수 =&amp;gt; uniform으로 간단히 선언 가능. uniform vec3 lightPos; 게임 루프 안에서 uniform을 업데이트(또는 밖에서 광원위치 고정) lightingShader.setVec3(&quot;lightPos&quot;, lightPos); 그 다음은 fragment의 위치를 얻어야한다. 모든 빛에 대한 계산을 world space에서 할것이므로 world space에서의 vertex 위치가 필요하다. vertex 위치는 model 행렬과 곱하여 world space 좌표로 변환하는 것으로 얻을 수 있음 이는 vertex shader에서 쉽게 수행가능, 출력 변수를 선언하고, world space 좌표를 계산해야한다. out vec3 FragPos;out vec3 Normal;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0); FragPos = vec3(model * vec4(aPos, 1.0)); Normal = aNormal;} 그리고 마지막으로 해당 값을 입력변수로 fragment shader에 추가해야한다.in vec3 FragPos; 이제 fragment shader에서 빛에 대한 계산을 시작해야한다. 먼저 광원과 fragment의 위치 사이의 방향 벡터가 필요 벡터 뺄셈으로 계산 그리고 모든 벡터들이 단위 벡터로 정규화해야한다. vec3 norm = normalize(Normal);vec3 lightDir = normalize(lightPos - FragPos); 빛계산은 일반적으로 벡터의 크기에 대해 생각하지 않음. 방향만 생각(단위 벡터) 계산 간단해짐 norm, lightDir 를 내적 =&amp;gt; diffuse 효과를 계산 diffuse : 내적의 결과값과 lightColor 사이각이 클수록 diffuse 요소는 어두워짐 float diff = max(dot(norm, lightDir), 0.0);vec3 diffuse = diff * lightColor; 음의 값을 가진 컬러가 되는것을 방지하기 위해 max 함수를 사용한다. 이제 ambient와 diffuse 두 색상을 모두 더한 다음 결과에 객체의 색상을 곱해 결과로 생성된 fragment의 출력색상을 얻는다.vec3 result = (ambient + diffuse) * objectColor;FragColor = vec4(result, 1.0); 결과는 다음과 같다. 사이 각이 클수록 fragment는 어두워진다.전체 코드One last thing 법선 벡터를 그대로 shader에 보내기만 했음. fragment shader에서 수행한 계산들 모두 world space에서 수행되므로 법선 또한 world space에서 수행되어어야 하는게 맞음 하지만, model 행렬과 곱하는 것만큼 간단하지 않다. 간단하지 않은 이유 법선 벡터는 그냥 방향벡터이다. 특정한 위치를 나타내지 않음. 또한 동차좌표(위치 벡터의 w요소)를 가지고 있지 않는다. =&amp;gt; 변환행렬과 곱하기 힘듬. model 행렬을 곱하려면 일부분 제거해 좌측상단의 3x3행렬을 취해야함 즉 변환행렬에서 유효한것은 회전 및 스케일 변환이다. model 행렬이 불균일 스케일을 수행하면, vertex들이 수정되어 법선 벡터가 더이상 해당 면과 수직이 되지 않는다. - 그러므로 이 model행렬로 법선 벡터를 변환하지 못함. (균일 스케일은 단지 크기만 변하기 때문에 법선에 영향안준다) 불균일 스케일을 적용 =&amp;gt; 수직이 틀어짐 =&amp;gt; 빛을 왜곡하게됨 해결방법은 법선 벡터에 맞춰서 만들어진 다른 model 행렬을 사용하는것. 이 행렬은 법선 행렬이라고 부른다. The Normal Matrix 법선 행렬: model 행렬의 좌측 상단 모서리의 역행렬에 대한 전치행렬 대부분 자료들은 법선 행렬을 model-view 행렬에서 파생된것으로 사용하지만, 지금은 world space에서만 작업하기 때문에 model 행렬에서 파생시킨것을 사용해야한다. vertex shader에서 inverse, transpose함수를 사용하여 법선 행렬을 만들 수 있다. 법선벡터와 곱하기위해 3x3행렬로 변환하므로 translation 속성을 잃는것을 주의하자. Normal = mat3(transpose(inverse(model))) * aNormal; 스케일 연산을 수행하지 않으므로, 실제로는 법선 행렬을 사용할 필요가 없고, 법선을 모델행렬과 곱하기만하면됨. 역행렬 변환 == 비용이 비쌈. scene의 각각의 vertex에 대해 수행해야하므로 이 연산은 피하는게 좋음 보통 CPU에서 법선 행렬을 계산하고 uniform을 통해 shader에 전달함.Specular Lighting 반사광은 분산광처럼 조명의 방향 벡터 및 대상의 법선 벡터를 기반으로함. 하지만, 추가적으로 플레이어가 fragment를 보고 있는 방향에 대한 view 방향도 관여한다. 반사광은 빛의 반사 특성 기반임. 만약, 거울면에서 반사되어진 빛 즉, 반사광은 가장 밝은 빛일것이다.(아래 그림 참고) 먼저, 반사 벡터를 계산해야함. 그리고 반사벡터와 view 방향 사이의 각도를 계산해야함 각이 가까움: 반사광의 강도는 강해짐 그다음에, View 벡터 계산해야함. viewer의 world sapce 위치와 fragment들의 위치를 사용하여 이 변수를 계산할 수 있다. 마지막으로, specular 세기를 계산하고, 빛의 색과 곱하고, 이를 ambient, diffuse 에 추가한다. 이때까지 world space에서 lighthing 계산을 했음. 하지만 대부분 view space 에서 lighting 을 수행함. view space에서 계산을 하면, viewer 위치가 항상 (0, 0, 0)이므로, 항상 뷰어의 위치를 쉽게 알 수 있음. 여기서는 학습목적으로 worldspace에서 계산할것임. view space에서 계산하려면 관련된 모든 벡터를 view 행렬을 사용하여 변환해야함.(법선 행렬 포함) viewer의 world space 좌표를 얻기 위해 카메라 객체의 위치 벡터를 사용함. uniform 으로 추가하여 fragment shader에 전달 uniform vec3 viewPos;lightingShader.setVec3(&quot;viewPos&quot;, camera.Position); 이제 specular를 계산할 수 있다. 먼저 specular 강조 값을 중간으로 정의하여, 하이라이트를 적절히 조절한다.(1.0f이면 아주 밝음) float specularStrength = 0.5; 그 다음, view 방향 벡터와 해당 반사 벡터를 계산한다. lightDir 벡터의 부호가 -로 바뀐것 주의 reflect 함수 파라미터1: 광원으로부터 fragment 위치로 향하는 벡터 lightDir는 그 반대 방향의 벡터이다. (lightDir 벡터 계산할 때 뺠셈 순서 때문) 파라미터2: 정규화된 법선벡터 vec3 viewDir = normalize(viewPos - FragPos);vec3 reflectDir = reflect(-lightDir, norm); 그런 다음, 공식을 사용하여 specular 컴포넌트를 계산해야한다. 내적: view 방향과 reflect 방향 음수 방지 32제곱: 32값은 하이라이트의 shininess 값(낮을수록 빛을 퍼지게, 높을수록 빛을 퍼지게하지않고, 적절히 반사, 하이라이트가 작아짐, 아래 이미지 참고) float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);vec3 specular = specularStrength * spec * lightColor; 마지막으로, ambient와 diffuse 와 함께 계산하는것이다.vec3 result = (ambient + diffuse + specular) * objectColor;FragColor = vec4(result, 1.0); 이제 이 코드를 실행하면 아래와 같이 보일것이다. 초기의 lighting shader들은 vertex shader에서 Phong 모델을 구현했다. 이를 vertex shader에서 구현하는 것은 vertex의 수가 fragment 보다 적기 때문에 계산량이 적어 효율적이었음. 하지만 vertex shader의 최종 컬러 값은 오직 vertex만의 lighting 컬러이므로, fragment에서는 보간된 컬러가 보여진다. 이와 같이 vertex에 구현된 모델을 Gouraud shading이라고 부름. 셰이더는 이처럼 강력하다. 약간의 정보와 함께 shader는 모든 오브젝트에 대해 영향을 끼친다. 출처learnopengl-basic lighting" }, { "title": "[백준][C++] 11066: 파일 합치기 (dp)", "url": "/posts/2022/03/12/00/19/11066/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-12 00:19:55 +0900", "snippet": "문제11066: 파일합치기;풀이 이 문제는 행렬곱 최적화 문제랑 비슷하다. 문제를 분할하여 작은 문제들로 나누고, 그 작은 문제들의 최적해를 합치면서 최적의 결과를 얻는다.기저조건 기저조건은 파일이 하나있는 경우와, 파일이 두개있는 경우로 생각할 수 있다.분할정복 분할은 간단하다. 왼쪽에서부터 분할하면된다. 그리고 이 비용을 합치고, 이 구간의 길이를 더해준다.(복사비용) for (int mid = lo; mid &amp;lt; hi; mid++) { int cost = dp(v, lo, mid) + dp(v, mid + 1, hi); ret = min(cost + len[lo][hi], ret);최적화하기 가장 간단하게 생각할 수 있는 최적화는 길이를 누적합을 통해 미리 계산하는 것이다.(아래 코드에서 길이는 그냥 비용과 같이 업데이트했음) iterative 방식을 사용하여 재귀호출 제거 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;utility&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;int cost[502][502];int len[502][502];int dp(vector&amp;lt;int&amp;gt; &amp;amp;v, int lo, int hi){ if (lo + 1 == hi) { len[lo][hi] = v[lo] + v[hi]; return cost[lo][hi] = len[lo][hi]; } if (lo == hi) { len[lo][hi] = v[lo]; return cost[lo][hi] = 0; } int &amp;amp;ret = cost[lo][hi]; if (ret != 0) { return ret; } ret = 1e9; for (int mid = lo; mid &amp;lt; hi; mid++) { int cost = dp(v, lo, mid) + dp(v, mid + 1, hi); len[lo][hi] = len[lo][mid] + len[mid + 1][hi]; ret = min(cost + len[lo][hi], ret); } return ret;}int main(){ cin.tie(0)-&amp;gt;sync_with_stdio(0); cout.tie(0); int T; cin &amp;gt;&amp;gt; T; while (T--) { memset(cost, 0, sizeof cost); memset(len, 0, sizeof len); int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt; v; for (int i = 0; i &amp;lt; n; i++) { int a; cin &amp;gt;&amp;gt; a; v.push_back(a); } cout &amp;lt;&amp;lt; dp(v, 0, v.size() - 1) &amp;lt;&amp;lt; &quot;\\n&quot;; }}" }, { "title": "[learn-opengl] Lighting: Colors", "url": "/posts/2022/03/11/03/10/opengl9/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-11 03:10:33 +0900", "snippet": "Colors 색상이 무엇인가?에 대해 설명한다. 색상 =&amp;gt; 무엇인지를 광범위하게 논의 디지털 세계 =&amp;gt; 실제 색상을 디지털 값으로 매핑해야함 색상: RGB 값의 조합으로 벡터로 정의 가능 glm::vec3 coral(1.0f, 0.5f, 0.31f); 실생활에서 보는 색 == 물체에서 흡수되고 나머지가 반사되어 생기는 색. OpenGL 또한 이러한 반사 규칙이 적용된다. 광원을 정의할 때 이 광원에 컬러를 설정할 수 있음. 광원의 컬러 값과 오브젝트의 컬러 값을 곱한 결과 =&amp;gt; 오브젝트에 반사된 컬러 두 개의 컬러 벡터를 요소마다 곱하여 최종 컬러 벡터를 얻는다.glm::vec3 lightColor(1.0f, 1.0f, 1.0f);glm::vec3 toyColor(1.0f, 0.5f, 0.31f);glm::vec3 result = lightColor * toyColor; // = (1.0f, 0.5f, 0.31f); 녹색 광원을 사용해보자glm::vec3 lightColor(0.0f, 1.0f, 0.0f);glm::vec3 toyColor(1.0f, 0.5f, 0.31f);glm::vec3 result = lightColor * toyColor; // = (0.0f, 0.5f, 0.0f); 이제 이 장난감은 R, B 빛을 가지고 있지 않는다. 빛의 G값의 반을 흡수하고 반을 반사함 그러므로 어두운 녹색이 됨. 빛이 있는 Scene 실제 시뮬레이션해볼것임. 조명: 빛을 만드는 오브젝트 간단히 이 광원을 정육면체로 표현할 것임. 먼저 vertex shader가 필요하다.#version 330 corelayout (location = 0) in vec3 aPos;uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main(){ gl_Position = projection * view * model * vec4(aPos, 1.0);} 그다음, 램프 큐브를 만들기 위해, 새로운 VAO를 생성해야한다.unsigned int lightVAO;glGenVertexArrays(1, &amp;amp;lightVAO);glBindVertexArray(lightVAO);// we only need to bind to the VBO, the container&#39;s VBO&#39;s data already contains the data.glBindBuffer(GL_ARRAY_BUFFER, VBO);// set the vertex attributeglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 그다음, fragment shader를 작성해보자 오브젝트 컬러와 조명 컬러를 uniform으로 받아야한다. 조명 컬러와 오브젝트 컬러를 곱한다. #version 330 coreout vec4 FragColor;uniform vec3 objectColor;uniform vec3 lightColor;void main(){ FragColor = vec4(lightColor * objectColor, 1.0);} 이제 오브젝트와 조명에 벡터를 넘기자// don&#39;t forget to use the corresponding shader program first (to set the uniform)lightingShader.use();lightingShader.setVec3(&quot;objectColor&quot;, 1.0f, 0.5f, 0.31f);lightingShader.setVec3(&quot;lightColor&quot;, 1.0f, 1.0f, 1.0f); 마지막으로 조명 램프의 컬러가 다른 조명 계산에 영향을 안받도록 해야한다. 램프를 나머지와 분리시켜야한다. 이를 위해 전용 셰이더를 작성해야한다. vertex shader 코드는 동일하게, 복붙하면된다. fragment shader를 다음과 같이 수정할 수 없는 흰색 컬러로 정의할 수 있다. #version 330 coreout vec4 FragColor;void main(){ FragColor = vec4(1.0); // set all 4 vector values to 1.0} 튜토리얼에서 이 쉐이더들을 점차 업데이트하여 사실적인 결과를 얻을 것이다. 램프 큐브의 주 목적: 빛이 어디에서 오는가를 알려주기 위함 실제 램프를 표시하기 위해 광원의 동일한 위치에 램프 큐브를 그린다. 램프 셰이더로 램프 개체를 그리면, 씬의 조명 상태에 관계없이 램프 큐브가 항상 흰색으로 유지된다. 월드 좌표계에서 광원의 위치를 나타내는 vec3 타입 전역변수를 다음과 같이 설정할 수 있다.glm::vec3 lightPos(1.2f, 1.0f, 2.0f); 그리고 이 램프를 그리기 전에 업데이트 시켜준다.(그리고 스케일을 줄임)model = glm::mat4(1.0f);model = glm::translate(model, lightPos);model = glm::scale(model, glm::vec3(0.2f)); 램프를 위한 최종 드로잉 코드는 다음과 같다.lightCubeShader.use();// set the model, view and projection matrix uniforms//[...]// draw the light cube objectglBindVertexArray(lightCubeVAO);glDrawArrays(GL_TRIANGLES, 0, 36); 이제 코드를 실행해보면, 다음과 같을 화면이 나올 것이다.링크colors: 전체 코드colors: 원문" }, { "title": "[백준][C++] 1300: K번째 수 (bisearch)", "url": "/posts/2022/03/10/01/34/1300/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-10 01:34:09 +0900", "snippet": "문제1300: K번째 수풀이 K번째 수를 구하기 위해 배열에 숫자를 저장하고 정렬하려 했지만, 입력의 크기가 크기 때문에 다른 방법으로 문제를 해결해야한다. 문제에서 주어진 이차원 배열은 특정한 규칙이 있으므로, 이를 활용하여 따로 저장하지 않고 문제를 풀 수 있어 보인다. 이차원 배열에서 하나의 값이 몇번째 위치에 있는지 알려면, 그 값보다 작은 것의 개수와 큰 것의 개수를 세면된다. 그러면 그 값이 속한 범위를 구할 수 있다. 이차원 배열이 생성되는 규칙에 의해여 i열에 속한 값들 중에서 우리는 어떠한 값보다 작은 값들의 개수를 알 수 있다. 어떠한 값을 i로 나누면, i와 곱해서 생성되는 어떠한 값보다 작은 수의 개수를 구할 수 잇다. 이제 우리는 1~N까지 순회하면, O(N) 시간에 하나의 값의 위치를 파악할 수 있다. 여기서 이진 탐색을 사용하면, O(NlogN) 시간에 모든 값의 범위에서 특정한 위치에 있는 값을 찾을 수 있다. 이진 탐색 값의 범위는 1~N*N 이므로 하한, 상한을 이로 설정할 수 있다. 하지만 잘 생각해보면 K + 1 보다 항상 작은 값이 나온다. 이제 중간값 mid를 구하여 이 값의 최소 위치가 K 와 같거나 작은지 확인한다. 만약 작거나 같으면 더 큰 값이 올 수있기 때문에, 하한인 lo에 mid를 대입한다. ll lo = 1; ll hi = K+ 1L; while (lo + 1L != hi) { ll mid = (lo + hi) / 2; if (isOkay(mid, N, K)) { lo = mid; } else { hi = mid; } }작은 값들의 개수 구하기 한 열 i 에서 작은값들의 개수는 mid/i로 구할 수 있다. 여기서 mid 가 i의 배수가 된다면 그 값은 카운트에서 제외해야한다.(작은 값들만 카운트) 그리고 배열의 크기는 NxN이므로, N보다 클 수 없다.bool isOkay(ll mid, ll N, ll K){ ll count = 1L; for (ll i = 1; i &amp;lt;= N; i++) { ll smallCount = mid / i; if (mid%i == 0 &amp;amp;&amp;amp; N &amp;gt;= smallCount) { smallCount--; } count += min(N, smallCount); } return count &amp;lt;= K;}주의할점 카운트 시작은 1이다. 어떠한 값의 위치이므로, 작은것들의 개수 + 1 이 해당 값의 최소 위치가 된다. 코드using ll = long long;bool isOkay(ll mid, ll N, ll K){ ll count = 1L; for (ll i = 1; i &amp;lt;= N; i++) { ll smallCount = mid / i; if (mid%i == 0 &amp;amp;&amp;amp; N &amp;gt;= smallCount) { smallCount--; } count += min(N, smallCount); } return count &amp;lt;= K;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); ll N; ll K; cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K; ll lo = 1; ll hi = K+ 1L; while (lo + 1L != hi) { ll mid = (lo + hi) / 2; if (isOkay(mid, N, K)) { lo = mid; } else { hi = mid; } } cout &amp;lt;&amp;lt; lo;}" }, { "title": "[백준][C++] 1629: 곱셈 (d-q)", "url": "/posts/2022/03/08/22/26/1629/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-08 22:26:12 +0900", "snippet": "문제1629: 곱셈풀이 유명한 분할 정복을 이용한 거듭제곱문제 $a^4 = a^2 * a^2$ $a^3 = a^2 * a$ 위 식을 토대로 코드를 짜면된다. 코드#include &amp;lt;iostream&amp;gt;using namespace std;long long fast(int a, int n, int c) { if(n == 0) { return 1; } if(n%2 == 0) { long long tmp = fast(a, n/2, c)%c; return (tmp*tmp)%c; } else { return (fast(a, n-1, c)*a)%c; }}int main() { int a, b, c; cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c; cout&amp;lt;&amp;lt;fast(a,b,c);}반성 기저조건 n == 0일 경우를 깜빡하였다. 기저조건을 항상 먼저 체크하자 " }, { "title": "[백준][C++] 12869: 뮤탈리스크 (dp)", "url": "/posts/2022/03/05/00/05/12869/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-03-05 00:05:18 +0900", "snippet": "문제뮤탈리스크풀이 처음엔 그리디 문제인줄 알았다. 하지만 가장 체력이 큰 scv한테 공격력이 높은 공격만 하면 문제가 해결되는 문제가 아니였다. 첫 번째 예제가 그리디 문제가 아님을 알려주고 있었다. 동적 계획법 이 문제는 모든 경우의 수를 구하여 문제를 해결할 수 있다. 하지만 이러면 시간이 많이 걸린다. 그러므로 중복된 계산을 피하도록 캐시에 값을 저장하여 문제를 해결해야한다. 캐시에 저장 캐시에 저장해야하는 값은 SCV의 체력이다. 똑같은 체력의 조합을 가지면, 똑같은 계산을 하기 때문이다. 이 조합이 같고, 순서가 다를 경우도 결과는 같으므로 정렬을 하여 이를 피하도록 할 수 있다. 모든 조합 SCV는 최대 3마리이므로, 문제를 쉽게하기 위해 항상 SCV는 3마리로 설정했다. 조합의 경우의 수는 next_permutation을 이용하여 쉽게 구할 수 있다. 코드using namespace std;int N;int dmg[] = {9, 3, 1};int cache[61][61][61];int dp(const vector&amp;lt;int&amp;gt; &amp;amp;scv){ int &amp;amp;ret = cache[scv[0]][scv[1]][scv[2]]; if (accumulate(scv.begin(), scv.end(), (int)0) &amp;lt;= 0) return 0; if (ret == -1) { ret = 1e9; vector&amp;lt;int&amp;gt; v = {0, 1, 2}; do { vector&amp;lt;int&amp;gt; tmp(3, 0); for (int i = 0; i &amp;lt; v.size(); i++) { int hp = scv[v[i]] - dmg[i]; tmp[i] = (hp &amp;lt; 0) ? 0 : hp; } sort(tmp.begin(), tmp.end()); ret = min(dp(tmp) + 1, ret); } while (next_permutation(v.begin(), v.end())); return ret; } return ret;}int main(){ memset(cache, -1, sizeof cache); ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &amp;gt;&amp;gt; N; vector&amp;lt;int&amp;gt; v(3, 0); for (int i = 0; i &amp;lt; N; i++) cin &amp;gt;&amp;gt; v[i]; cout &amp;lt;&amp;lt; dp(v);}" }, { "title": "[learn-opengl] Camera", "url": "/posts/2022/03/04/07/07/opengl8/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-03-04 07:07:47 +0900", "snippet": "Camera OpenGL 자체는 카메라 개념에 익숙하지 않다. 장면의 모든 객체를 반대 방향으로 이동 =&amp;gt; 움직이는 것처럼 시뮬레이션 이번 장에서는 키보드 및 마우스 입력, 그리고 사용자 정의 카메라 클래스를 다룬다. Camera/View space 뷰행렬은 카메라의 위치와 방향에 따라 월드 좌표를 뷰 좌표로 변환한다. 카메라를 정의하기 위해 카메라의 위치, 바라보고 있는 방향, 카메라의 오른쪽을 가리키는 벡터, 카메라의 위쪽을 바라보는 벡터가 필요하다. 즉, 카메라의 위치를 원점으로 하고 3개의 수직인 축을 가지고 있는 좌표계를 만들 것. Camera position 위치는 기본적으로 world space의 벡터이다. 이 벡터는 카메라의 위치를 가리킨다. glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); z축의 양의 방향은 화면에서 사용자쪽으로 가리킨다. 그러므로 카메라의 위치를 뒤로 옮기려면 z축의 양의 방향쪽으로 이동 시켜야함. Camera direction 카메라가 가리키는 방향 우선 카메라가 scene의 원점 (0,0,0)을 가리키게 한다. 카메라의 위치 벡터 그리고 이 원점 벡터, 두 벡터를 빼면 방향벡터를 얻을 수 있다. 카메라: z축의 음의 방향을 가리키고 있음, 방향 벡터를 카메라로부터 z축 양의 방향을 가리키게 할것임 뺄셈의 순서를 바꾼다면 카메라로부터 z축의 양의 방향을 가리키는 벡터를 얻을 수 있다. glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget); 사실 방향 벡터라기보다는 카메라가 보고있는 방향의 반대 방향이다.Right axis space에서 x축의 양의 방향을 나타내는 오른쪽 벡터. right 벡터를 얻기위해 먼저 world space에서 up을 가리키는 up 벡터를 지정하여 약간의 트릭을 사용. 그런 다음 up 벡터와 위에서 구했던 방향 벡터를 외적한다. 외적 결과는 두 벡터와 수직인 벡터이므로, x축에 대해 양의 방향을 가리키는 벡터를 얻을 것이다. glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));Up axis x축 벡터와 z축 벡터를 얻었으므로, 카메라에 대해 y축의 양의 방향을 가리키는 벡터를 찾는 것은 쉽다. 오른쪽 벡터와 방향 벡터를 외적하면 얻을 수 있다. glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);정리 외적과 약간의 트릭을 이용하여 뷰/카메라 공간을 형성하는 모든 벡터들을 생성할 수 있다. 이런 과정을 그람-슈미트 과정이라고 한다. 이 카메라 벡터들을 사용하여 이제 카메라를 생성하는데 유용한 LookAt행렬을 생성할 수 있다. Look At 행렬의 좋은점: 3개의 직각(또는 비선형)인 축을 사용하여 좌표 공간을 만들면, 3개의 축과 이동 벡터와 함께 행렬을 만들 수 있다. 이를 통해 벡터와 곱하여 이 좌표 공간으로 변환할 수 있다. 이것이 LookAt행렬이 수행하는 것이다. 그리고 위에서 만든 벡터로 아래와 같이 행렬을 만들 수 있다. \\[LookAt = \\begin{bmatrix} \\color{red}{R_x} &amp;amp; \\color{red}{R_y} &amp;amp; \\color{red}{R_z} &amp;amp; 0 \\\\ \\color{green}{U_x} &amp;amp; \\color{green}{U_y} &amp;amp; \\color{green}{U_z} &amp;amp; 0 \\\\ \\color{blue}{D_x} &amp;amp; \\color{blue}{D_y} &amp;amp; \\color{blue}{D_z} &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{bmatrix} * \\begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; -\\color{purple}{P_x} \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -\\color{purple}{P_y} \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; -\\color{purple}{P_z} \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{bmatrix}\\] 위 식에서 중요한 점은, 위치 벡터가 반대로 되어 있다는 것. 결국 월드를 이동할 곳의 반대 방향으로 이동시키기 위함 이 LookAt행렬은 정확히 주어진 타겟을 바라보고(look)있는 view 행렬을 생성한다.glm::lookAt glm을 사용하면 그냥 카메라 위치, 타겟 위치, 월드 공간의 위쪽을 나타내는 벡터(오른쪽 벡터를 계산하기 위해..사용됨)를 지정해주기만 하면됨. GLM이 그러면 view 행렬로서 사용할 수 있는 LookAt행렬을 생성해준다. glm::mat4 view;view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));scene 주위를 카메라가 회전하게 만들기 scene의 타겟은 (0,0,0)으로 고정 삼각함수를 이용하여 원을 그리는 x, z 좌표를 생성 이 좌표를 카메라 위치로 사용 x, z 좌표를 재계산 =&amp;gt; 원에대한 모든 지점을 가로질러 카메라가 scene 주위를 돌 수 있다. float radius = 10.0f;float camX = sin(glfwGetTime()) * radius;float camZ = cos(glfwGetTime()) * radius;glm::mat4 view;view = glm::lookAt(glm::vec3(camX, 0.0, camZ), glm::vec3(0.0, 0.0, 0.0), glm::vec3(0.0, 1.0, 0.0));전체 코드Walk around 카메라를 직접 움직이도록 수정 일단 변수들을 정의해보자 glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f); LookAt 함수는 아래와 같다.view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp); cameraPos로 카메라 위치를 설정, 방향: 현재 위치 + 방향 백터 =&amp;gt; 움직이더라도 카메라는 타겟 방향을 바라보도록 유지함.입력 입력 =&amp;gt; GLFW 사용, processInput 함수 정의void processInput(GLFWwindow *window){ ... float cameraSpeed = 0.05f; // adjust accordingly if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront; if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;} 좌우는 외적을 사용하여 오른쪽 벡터를 생성하여 계산한다. 정규화 필수 cameraSpeed를 통해 카메라 이동 속도 구할 수 있다.Movement speed 사용자들은 각자 다른 hw 환경에서 프로그램을 실행한다 그 결과 프레임 속도가 달라짐(processInput함수를 더 자주 호출) 그러므로 모든 종류의 hw에서 동일하게 실행되도록 해야함 deltaTime: 마지막 프레임을 렌더링하는 데 걸리는 시간 모든 속도들에 이것을 곱해줌 긴 deltaTime: 프레임에서의 속도는 균형을 맞추기 위해 약간 증가 아래와 같이 전역변수로 선언 float deltaTime = 0.0f; // Time between current frame and last framefloat lastFrame = 0.0f; // Time of last frame 각 프레임마다 새로운 deltaTime 계산 가능float currentFrame = glfwGetTime();deltaTime = currentFrame - lastFrame;lastFrame = currentFrame;void processInput(GLFWwindow *window){ float cameraSpeed = 2.5f * deltaTime; [...]}코드 동작전체 코드Look around 키보드를 움직이기만 하는것은 움직임이 다소 제한적이므로 마우스 추가 cameraFront 벡터를 수정해야함. 약간 복잡, 삼각법 사용 Euler angles 오일러 각: 3D 상에서의 모든 회전을 나타낼 수 있는 3개의 값. pitch, yaw, roll pitch: 위 아래 yaw: 왼쪽 오른쪽 roll: 카메라 회전삼각법: yaw, pitch 빗변의 길이가 1 이라면, 삼각법에 의해 인접한 변의 길이가 위 이미지처럼됨. 이는 각도로 x 방향과 y방향의 길이 즉, 방향 벡터의 요소들을 계산할 수 있다. 위 이미지와 같이 yaw가 주어지면 방향 벡터의 x, z를 구할 수 있다.glm::vec3 direction;direction.x = cos(glm::radians(yaw)); // Note that we convert the angle to radians firstdirection.z = sin(glm::radians(yaw)); 그리고 pitch가 주어지면 방향벡터의 y를 구할 수 있다.direction.y = sin(glm::radians(pitch)); pitch 이미지에서 x, z 요소가 영향을 받는것을 알 수 있다. 빗변의 크기가 cos(pitch)가 됨. 따라서 다음과 같이 방향벡터가 완성된다.direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));direction.y = sin(glm::radians(pitch));direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch)); 음의 z축 방향으로 배치되도록 월드의 scene을 설정했다. theta = 0 이면 x축의 양의방향을 가리킴 카메라의 방향이 기본적으로 음의 z축을 가리키도록 하기위해 yaw 값을 기본값으로 -90으로 설정할 수 있다. Positive degrees rotate counter-clockwiseyaw = -90.0f;Mouse input yaw, pitch 값은 마우스 등 입력기기에서 얻을 수 있음. 수평 =&amp;gt; yaw, 수직 =&amp;gt; pitch 마지막 프레임 의 마우스 위치를 저장하고, 현재 프레임에서 위치 비교를 통해 값을 업데이트한다. GLFW에서 제공하는 glfwSetInputMode를 통해 마우스 커서를 숨기고 캡쳐할 수 있다.(포커스되면, 창안에 마우스를 가두는것)glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); pitch와 yaw값을 계산 하기위해 움직임을 감지하는 이벤트가 발생하면 호출되는 함수를 작성해야함.void mouse_callback(GLFWwindow* window, double xpos, double ypos);glfwSetCursorPosCallback(window, mouse_callback); 단계는 다음과 같다. 마지막 프레임의 마우스 offset 계산 카메라의 yaw와 pitch값에 offset 값을 더함 pitch값에 최댓값/최솟값 설정 방향 벡터를 계산 먼저 마우스 offset의 초기값은 화면 중앙으로 설정한다. float lastX = 400, lastY = 300; 콜백함수에서 다음과 같이 움직임 offset을 계산한다. 주의점: yoffset 계산할 때, glfw 좌표계는 vulkan 과 같이 원점이 좌상단이다. float xoffset = xpos - lastX;float yoffset = lastY - ypos; // reversed since y-coordinates range from bottom to toplastX = xpos;lastY = ypos;const float sensitivity = 0.1f;xoffset *= sensitivity;yoffset *= sensitivity; 이제 yaw와 pitch에 더한다.yaw += xoffset;pitch += yoffset; 아래와 같이 pitch를 제한하여 이상한 카메라 움직임을 방지한다. 90도에서 시점이 반대로 돌아 갈 수 있다. (그러므로 89도)if(pitch &amp;gt; 89.0f) pitch = 89.0f;if(pitch &amp;lt; -89.0f) pitch = -89.0f; 마지막으로 실제 방향벡터를 계산한다.glm::vec3 direction;direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));direction.y = sin(glm::radians(pitch));direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));cameraFront = glm::normalize(direction); 이대로 코드를 실행하면 처음에 카메라가 튄다. 커서가 윈도우 창에 들어가자맛자 화면에서의 마우스 위치가 콜벡 함수의 파라미터로 들어가기 때문. 정 중앙과 멀리 떨어진 위치이기 때문 해결: 마우스 입력이 처음인지 아닌지 확인하는것. if (firstMouse) // initially set to true{ lastX = xpos; lastY = ypos; firstMouse = false;} 최종 코드는 다음과 같다.void mouse_callback(GLFWwindow* window, double xpos, double ypos){ if (firstMouse) { lastX = xpos; lastY = ypos; firstMouse = false; } float xoffset = xpos - lastX; float yoffset = lastY - ypos; lastX = xpos; lastY = ypos; float sensitivity = 0.1f; xoffset *= sensitivity; yoffset *= sensitivity; yaw += xoffset; pitch += yoffset; if(pitch &amp;gt; 89.0f) pitch = 89.0f; if(pitch &amp;lt; -89.0f) pitch = -89.0f; glm::vec3 direction; direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch)); direction.y = sin(glm::radians(pitch)); direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch)); cameraFront = glm::normalize(direction);}Zoom Fov(Field of view): scene에서 우리가 얼마나 볼 수 있는지 정의하는것. 작으면: scene projected space는 작아지기 때문에 zoom in 마우스 휠에 이를 설정할 것임. void scroll_callback(GLFWwindow* window, double xoffset, double yoffset){ fov -= (float)yoffset; if (fov &amp;lt; 1.0f) fov = 1.0f; if (fov &amp;gt; 45.0f) fov = 45.0f;} 이제 루프가 돌때마다 GPU에 perspective projection행렬을 업로드 해야한다.projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f); 콜백함수를 등록하면 끝.glfwSetScrollCallback(window, scroll_callback);원문의 실행 영상전체 소스 오일러 각을 사용하는 카메라 시스템은 완벽하지 않다. =&amp;gt; Gimbal lock 문제 야기 최고의 카메라 시스템은 사원수(quaternions)를 사용하는것Camera class 세부사항을 추상화 여기서 다루는 카메라 시스템은 FPS의 카메라 시스템과 비슷 대부분 오일러 각이 통한다. 하지만, 비행기 시뮬레이션과 같은 다른 카메라 시스템일 경우 주의해야한다. 카메라 시스템은 그들만의 트릭과 별난 점을 가지고 있음.(FPS카메라: pitch 값을 90도 이상 허용하지 않음, roll값을 고려할 때 정적 상향 벡터(0,1,0)가 작동하지 않음) 카메라 클래스 코드출처Camera" }, { "title": "[게임 프로그래밍 패턴] Optimization Patterns: Spatial Partition", "url": "/posts/2022/03/03/01/04/pattern20/", "categories": "pattern", "tags": "", "date": "2022-03-03 01:04:05 +0900", "snippet": "Spatial Partition 객체를 효과적으로 찾기 위해 객체 위치에 따라 구성되는 자료구조에 저장한다.Motivation 현실감을 제공하는 요소 중 하나: 위치(location) 공간(space) 개념: 객체는 공간 어딘가의 위치에 존재하게 된다. 위치(location) 개념: 여러 형태로 확인 가능 물리 충돌 or 오디오(거리에 따른 소리조절) 이를 위해 ‘주변에 어떤 객체들이 있는지’ 알아야한다. 매 프레임마다 이를 확인 == 성능 병목 전장 위의 유닛들 RTS 게임을 만든다고 해보자. 전장에는 수백이 넘는 유닛들이 싸운다. 근접 유닛은 공격하기 전에 적이 어디에 있는지를 알아야 한다. 이를 단순하게 구현해보면 다음과 같다.(이중 포문)void handleMelee(Unit* units[], int numUnits){ for (int a = 0; a &amp;lt; numUnits - 1; a++) { for (int b = a + 1; b &amp;lt; numUnits; b++) { if (units[a]-&amp;gt;position() == units[b]-&amp;gt;position()) { handleAttack(units[a], units[b]); } } }} 이러면 유닛 수가 많아질 때 검사 횟수가 엄청아네 많아진다. 매 프레임마다 유닛 개수의 제곱만큼 검사하게됨. 1차원 전장 문제는 배열에 들어 있는 유닛이 따로 정렬되어 있지 않다는 것. 유닛을 찾으려면 전체 배열 다 순회해야함. 문제를 단순화하기 위해 1차원으로 생각해보자 위와 같으면, 위치를 기준으로 정렬하고 전체 배열을 다 조회하지 않고도 이진 검색 같은 걸로 주변 유닛을 쉽게 찾을 수 있다. 이렇게 위치에 따라 구성되는 자료구조에 객체를 저장 =&amp;gt; 빠르게 검색 가능 이걸 2차원 이상의 공간에 적용한 것이 공간 분할 패턴이다. The pattern 객체들은 공간 위에서 위치 값을 갖는다. 공간 자료구조: 객체 위치에 따라 구성됨 같은 위치 혹은 주변 객체를 빠르게 찾을 수 있다. 위치 변경 =&amp;gt; 공간 자료구조도 업데이트 언제 사용 공간 분할 패턴은 움직이는 게임 객체뿐만이 아니라 정적인 프랍이나 지형을 저장할 때 복잡한 게임에는 콘텐츠별로 공간 분할 자료구조를 따로 두기도 한다. 위치 값이 있는 객체가 많고, 위치에 따라 객체를 찾는 쿼리가 성능에 영향을 줄만큼 잦을 경우 주의사항 객체가 많을 때만 의미가 있다. 이진검색 O(log n), 전체 검색 O(nlogn), 비둘기집 정렬 같은 기법을 사용하면 O(n) 공간 분할 패턴 == 객체를 위치에 따라 정리 == 위치 변경 복잡함. CPU도 더 소모 추가 메모리가 더 필요. CPU보다 메모리가 더 부족한 곳에서는 오히려 손해일 수 있다. 해시 테이블에 들어 있는 객체의 해시 키가 자발적으로 변경되는것을 상상해보면 어려운일 이라는것을 알 수 있음. 예제 코드 여러 변형들이 잘 문서화 되어있다. 이 책에서는 가장 간단한 공간 분할 형식인 고정 격자(fixed-grid)방법을 다룬다.모눈종이 정사각형 모양의 고정 크기 격자를 모눈종이 모양처럼 겹쳐 놓는다. 유닛을 배열이 아닌 격자 칸 안에 집어넣는다. 칸마다 유닛 리스트가 있어서 유닛 중에서 위치가 칸의 범위 안에 들어오는 것들을 저장한다. 전투를 처리할 때에는 같은 칸에 들어 있는 유닛만 신경 쓰면 된다. 소규모로 적은 개수의 유닛들만 비교하게하는것. 유닛을 링크드 리스트로 저장한 격자 아래와 같이 Unit 클래스를 작성할 수 있다. Unit에는 위치 값과 자기가 속한 격자(grid) 객체 포인터가 있다. class Unit{ friend class Grid;public: Unit(Grid* grid, double x, double y) : grid_(grid), x_(x), y_(y) {} void move(double x, double y);private: double x_, y_; Grid* grid_;}; 유닛이 움직일 때 격자에 속해 있는 데이터도 제대로 위치해 있도록 Grid 객체와 통신해야 할 수 있기 때문에 Grid 클래스가 friend로 정의되어 있다. 격자 클래스는 대략 다음과 같다. class Grid{public: Grid() { // Clear the grid. for (int x = 0; x &amp;lt; NUM_CELLS; x++) { for (int y = 0; y &amp;lt; NUM_CELLS; y++) { cells_[x][y] = NULL; } } } static const int NUM_CELLS = 10; static const int CELL_SIZE = 20;private: Unit* cells_[NUM_CELLS][NUM_CELLS];}; 모든 칸(cell)이 유닛의 포인터로 되어 있다. 이제 유닛이 이전 포인터와 다음 포인터를 갖도록 해야한다.class Unit{ // Previous code...private: Unit* prev_; Unit* next_;}; 이를 통해서 배열이 아니라 더블 링크드 리스트로 유닛을 관리할 수 있다. 격자 칸은 그 칸에 들어 있는 유닛 리스트의 첫 번째 유닛을 포인터로 가리킨다. 유닛은 자기 이전과 이후 유닛을 포인터로 가리킨다. 전장 속으로 들어가기 먼저 새로 만든 유닛을 적당한 격자 칸에 넣어야 한다. Unit 클래스 생성자에서 한다. Unit::Unit(Grid* grid, double x, double y): grid_(grid), x_(x), y_(y), prev_(NULL), next_(NULL){ grid_-&amp;gt;add(this);} add() 메서드는 다음과 같다void Grid::add(Unit* unit){ // Determine which grid cell it&#39;s in. int cellX = (int)(unit-&amp;gt;x_ / Grid::CELL_SIZE); int cellY = (int)(unit-&amp;gt;y_ / Grid::CELL_SIZE); // Add to the front of list for the cell it&#39;s in. unit-&amp;gt;prev_ = NULL; unit-&amp;gt;next_ = cells_[cellX][cellY]; cells_[cellX][cellY] = unit; if (unit-&amp;gt;next_ != NULL) { unit-&amp;gt;next_-&amp;gt;prev_ = unit; }} 위 코드는 유닛이 들어갈 칸을 찾은 뒤 그 칸에 들어 있는 리스트 맨 앞에 유닛을 추가한다. 칸에 이미 유닛 리스트가 들어 있다면, 추가한 유닛 뒤에 유닛 리스트를 붙인다. 검의 격돌 모든 유닛을 적절한 칸에 넣은 뒤, 유닛끼리 서로 칼을 휘두르게할 수 있다. 격자를 이용해서 전투를 처리하는 메서드는 다음과 같다. void Grid::handleMelee(){ for (int x = 0; x &amp;lt; NUM_CELLS; x++) { for (int y = 0; y &amp;lt; NUM_CELLS; y++) { handleCell(cells_[x][y]); } }} 칸을 순회하면서 handleCell()을 호출한다. 큰 전장을 각각 고립된 전투 공간들로 분할한 것. void Grid::handleCell(Unit* unit){ while (unit != NULL) { Unit* other = unit-&amp;gt;next_; while (other != NULL) { if (unit-&amp;gt;x_ == other-&amp;gt;x_ &amp;amp;&amp;amp; unit-&amp;gt;y_ == other-&amp;gt;y_) { handleAttack(unit, other); } other = other-&amp;gt;next_; } unit = unit-&amp;gt;next_; }} 이 코드에서도 모든 유닛 쌍에 대해서 같은 위치에 있는지를 검사한다. 하지만, 모든 유닛을 확인하지 않는다, 같은 칸에 들어 있을 정도의 가까운 유닛들만 검사한다. 루프문이 더 많이 중첩해서 성능이 떨어진것처럼 보일 수 있지만, 내부 2중루프에서 검사하는 유닛 개수가 훨씬 적기 때문에 칸마다 순회하는 외부 루프 비용을 상쇄하기에 충분하다.(칸의 분할정도에 따라 성능에 문제가 생길 수 있다)Charging forward 유닛이 칸에 묶여 있음. =&amp;gt; 칸 너머로 이동하면 그 칸에 있는 유닛들만이 아니라 어느 유닛에서도 그 유닛을 볼 수 없음. 해결 : 유닛 이동시 추가작업 수행 칸을 넘어가면 유닛을 현재 칸에서 제거, 새로운 칸에 추가 이를 위해 이동용 메서드 추가해야함 void Unit::move(double x, double y){ grid_-&amp;gt;move(this, x, y);} 실제 작업은 Grid 클래스의 move()에서 실행된다.void Grid::move(Unit* unit, double x, double y){ // See which cell it was in. int oldCellX = (int)(unit-&amp;gt;x_ / Grid::CELL_SIZE); int oldCellY = (int)(unit-&amp;gt;y_ / Grid::CELL_SIZE); // See which cell it&#39;s moving to. int cellX = (int)(x / Grid::CELL_SIZE); int cellY = (int)(y / Grid::CELL_SIZE); unit-&amp;gt;x_ = x; unit-&amp;gt;y_ = y; // If it didn&#39;t change cells, we&#39;re done. if (oldCellX == cellX &amp;amp;&amp;amp; oldCellY == cellY) return; // Unlink it from the list of its old cell. if (unit-&amp;gt;prev_ != NULL) { unit-&amp;gt;prev_-&amp;gt;next_ = unit-&amp;gt;next_; } if (unit-&amp;gt;next_ != NULL) { unit-&amp;gt;next_-&amp;gt;prev_ = unit-&amp;gt;prev_; } // If it&#39;s the head of a list, remove it. if (cells_[oldCellX][oldCellY] == unit) { cells_[oldCellX][oldCellY] = unit-&amp;gt;next_; } // Add it back to the grid at its new cell. add(unit);} 위 코드와 같이 매 프레임마다 많은 유닛을 링크드 리스트에 넣으면 삽입/삭제를 빠르게 할 수 있다.사정거리 안에서 예제에서는 같은 위치에 있는 유닛끼리만 상호작용한다. 범위안에 있도록 수정해야함. if (distance(unit, other) &amp;lt; ATTACK_DISTANCE){ handleAttack(unit, other);} 범위를 검사할 때, 다른 칸에 들어 있는 유닛도 상호작용할 수 있게 해야함. 위 와 같이 다른 칸 또한 검사하려면, 먼저 handleCell()에서 내부 루프를 따로 빼야한다.void Grid::handleUnit(Unit* unit, Unit* other){ while (other != NULL) { if (distance(unit, other) &amp;lt; ATTACK_DISTANCE) { handleAttack(unit, other); } other = other-&amp;gt;next_; }} handleUnit()은 유닛 한 개와 그 유닛과 충돌하는지를 검사할 유닛 리스트를 인수로 받는다. handleCell()에서는 handleUnit()을 사용하게 변경void Grid::handleCell(int x, int y){ Unit* unit = cells_[x][y]; while (unit != NULL) { // Handle other units in this cell. handleUnit(unit, unit-&amp;gt;next_); unit = unit-&amp;gt;next_; }} HandleCell()은 유닛 리스트가 아닌 칸의 좌표값을 받는다. 이를 아래와같이 확장할 수 있다. void Grid::handleCell(int x, int y){ Unit* unit = cells_[x][y]; while (unit != NULL) { // Handle other units in this cell. handleUnit(unit, unit-&amp;gt;next_); // Also try the neighboring cells. if (x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0) handleUnit(unit, cells_[x - 1][y - 1]); if (x &amp;gt; 0) handleUnit(unit, cells_[x - 1][y]); if (y &amp;gt; 0) handleUnit(unit, cells_[x][y - 1]); if (x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;lt; NUM_CELLS - 1) { handleUnit(unit, cells_[x - 1][y + 1]); } unit = unit-&amp;gt;next_; }} 확장된 handleUnit()에서는 현재 유닛이 주변 8칸 중에서 좌측 4칸에 들어 있는 유닛과 충돌여부를 검사한다. 주변 유닛 중에서도 공격 범위 안에 들어와 있는 유닛에 대해서는 공격 처리를 한다. 내부 루프에서는 같은 유닛끼리 두 번 검사하는 것을 막기 위해 주변 칸도 절반만 검사한다. 주변 8칸을 모두 검사하면 다음과 같이 된다. A공격을 검사할 때 오른쪽 칸에 있는 B를 찾는다. A와 B 사이의 공격을 등록한다. B공격을 검사할 때 왼쪽 칸에 있는 A를 찾는다. A와 B를 다시 등록한다. 주변 칸 중 반만 찾으면 이 문제를 해결할 수 있다. 일반적으로 A와 B관계가 비대칭이기 때문에 8칸 다 검사해야한다.(A가 B에 알림, B또한 A에게 알릴필요가 있음) 만약 한 칸의 크기가 짧고 공격범위가 더 넓다면, 주변 칸을 더 넓게해야한다. 디자인 결정 공간분할 자료구조에 대해 간략한 설명.공간을 계층적으로 나눌 것인가, 균등하게 나눌것 인가? 계층적 공간 분할: 공간을 몇 개의 영역으로 나눈다. 그런 뒤 객체가 많은 영역은 다시 분할한다. 모든 영역에 들어 있는 유닛의 개수가 특정 최대 개수 이하로 떨어질 때까지 이 과정을 재귀적으로 반복한다.(2의 제곱수로 분할) 균등하게 나눈다면 더 단순하다 매모리 사용량이 일정하다: 공간을 새로 분할하지 않음, 공간 분할에 필요한 메모리양 불변 객체가 위치를 이동할 때 자료구조의 업데이트 속도가 빠르다: 계층형 공간 분할 =&amp;gt; 여러 계층을 같이 고쳐야할 가능성계층적으로 나눈다면 빈 공간을 훨씬 효율적으로 처리할 수 있다 어느 공간에 객체가 없으면, 칸이 비어있어도 칸에 메모리 할당해야함, 매 프레임마다 순회도 해야함. 계층형 공간 분할에서는 한산한 공간을 재분할하지 않기 때문에, 크게 비어 있는 공간들은 한 영역으로 남아있게 된다. 그렇기 때문에 작은 영역들을 순회하지 않고 큰 영역 하나만 순회하면 됨. 밀집된 영역도 효과적으로 처리 가능 많은 객체가 한곳에 뭉쳐 있으면, 비계층형 분할 방식이 비효율적일 수 있다. 계층형 분할에서는 상황에 맞게 공간을 재분할, 한 번에 고려해야 할 객체 개수가 너무 많아지지 않도록 해준다. 객체 개수에 따라 분할 횟수가 달라지는가? 예제: 분할 크기가 미리 정해짐. 적응형: 유닛 개수와 위치에 따라 분할 크기를 조절. 성능을 위해 영역마다 비슷한 수의 유닛이 들어갈 수 있도록 균형 잡힌 분할을 만들어야한다. 한 칸에 전부 있으면 O(n^2) 수준. 객체 개수와 상관없이 분할한다면 객체는 순차적으로 추가될 수 있다 적당한 위치를 찾아 넣어줌. -&amp;gt; 성능 걱정 없이 한 번에 처리 객체가 빠르게 이동할 수 있다 공간 분할이 고정 =&amp;gt; 이동시 이전 영역에서 제거, 다음 분할 영역에서 추가 객체 개수에 따라 공간을 분할 =&amp;gt; 유닛 하나만 다른 영역으로 이동해도 다른 많은 유닛까지 영역을 옮겨야할 수 있음. 레드-블랙 트리, AVL 트리 같은 이진 검색 트리와 마찬가지. 재정렬하거나 여러 노드를 섞어줘야할 필요가 있음. 영역이 균형잡혀 있지 않을 수 있다 객체가 뭉침 == 비어 있는 영역 메모리 낭비 == 성능 더 떨어질 가능성 객체 개수에 따라 영역이 다르게 분할된다면 이진 공간 분할(BSP)이나 k-d트리: 공간 분할에서는 양쪽에 같은 수의 객체가 들어 있도록, 월드 공간을 반씩 재귀적으로 쪼갬. 양쪽에 객체가 몇개 있는지 계산해야함 경계 볼륨 계층구조(BVH)는 객체 분호에 맞춰서 공간을 분할하는 또 다른 기법이다. 영역의 균형 잡힙을 보장할 수 있다 성능을 일정하게 유지 가능. 프레임레이트 일정하게 유지 =&amp;gt; 단순한 성능향상보다 일정함이 더 중요 전체 객체에 대해 한번에 분할해놓는 게 훨씬 효과적 공간을 분할하기 전에 전체 객체를 미리 준비해두는 게 최선. 보통 게임에서 고정된 정적 지형이나, 아트 리소스에 많이 사용됨 영역 분할은 고정되어 있지만, 계층은 객체 개수에 따라 달라진다면 쿼드트리(quadtree): 고정 분할과 적응형 분할의 장점을 둘 다 어느 정도 가지는 방식 전체 공간을 한 영역으로 시작 공간에 들어 있는 객체 개수가 정해진 수 이상을 넘어가면 사각형 4개로 분할, 크기는 1/4 고정 쿼드트리 == 2차원 공간 분할, 3차원 공간 == 옥트리(octree), 차원이 더 높지만 동작방식은 같다. 이렇게 분할된 사각형에 대해, 각 사각형에 들어 있는 객체 개수가 일정 수 이하가 될 때까지 재귀적으로 반복 밀도가 높은 영역만 재귀적으로 분할한다는 면에서 객체 개수에 따라 조정되긴하지만, 분할 영역이 이동하지는 않는다. 아래 그림을 보면, 분할 영역들이 바뀌는 것을 확인할 수 있다. 객체를 순차적으로 추가할 수 있다 위치에 맞는 사각형 칸을 찾아 추가하기만 하면됨. 사각형에 들어 있는 유닛이 최대 개수를 넘기면 영역을 분할 기존 사각형에 있던 유닛들은 새로운 사각형에 편입 이 때 추가작업이 필요, 그러나 이동해야 하는 객체는 항상 유닛 최대 개수 이하, 필요한 성능을 보장받을 수 있음. 객체를 하나 추가할 때 분할은 최대 한번 제거: 최대 개수 미만이면 합침. 객체 이동이 빠름 이동: 단순히 추가와 삭제 분할 영역이 균형잡힘 사각형 내부 유닛 개수 항상 최대 개수 미만 한 영역에 많은 유닛이 동시에 못들어가게 막음 객체를 공간 분할 자료구조에만 저장하는가? 공간 분할 자료구조에서 게임 객체의 생명주기까지 관리 가능. 컬렉션에 객체들을 넣고, 공간 분할 자료구조는 위치 관련 처리를 빠르게 하기 위한 캐시 용도로만 사용할 수도 있다.객체를 공간 분할 자료구조에만 저장한다면 컬렉션이 두 개가 되면서 생기는 메모리 비용과 복잡도 피함 한 곳에 두는게 더 싸다. 동기화 비용 없음 다른 컬렉션에도 객체를 둔다면 전체 객체를 더 빠르게 순회 가능 객체마다 계속해서 처리해야 할 작업이 있으면, 위치와 상관 없이 자주 모든 객체를 순회해야함. 별도의 컬렉션 저장 =&amp;gt; 순회 과정 훨씬 빠르게 (두 개의 자료구조 각자 용도에 맞게 최적화) 관련자료 가장 많이 쓰이는 공간 분할 자료구조들 Grid Quadtree BSP k-d tree Bounding volume hierarchy 이들 자료구조는 1차원 자료구조를 다차원으로 확장한 것과 다르지 않음. Grid == 버킷 정렬(bucket sort) BSP, k-d 트리, BVH == 이진 검색 트리 쿼드 트리, 옥트리 == 트라이(trie) 출처spatial-partition" }, { "title": "[게임 프로그래밍 패턴] Optimization Patterns: Object Pool", "url": "/posts/2022/02/28/15/07/pattern19/", "categories": "pattern", "tags": "", "date": "2022-02-28 15:07:26 +0900", "snippet": "Object Pool 객체를 매번 할당, 해제하지 않고 고정 크기 풀에 들어 있는 객체를 재사용함으로써 메모리 사용 성능을 개선한다.Motivation 파티클 시스템 파티클을 굉장히 빠르게 만들 수 있어야함. 생성, 제거하는 과정에서 메모리 단편화(memory fragmentation)가 생겨서는 안됨. 메모리 단편화의 저주 단편화: 힙에 사용 가능한 메모리 공간이 크게 뭉쳐 있지 않고 작게 조각나 있는 상태 전체 사용 가능한 메모리 양은 많아도 연속해서 사용 가능한 영역이 작을 수 있음 아래는 힙이 단편화되면, 이론적으로 충분한 메모리가 있음에도 메모리 할당이 실패하는 것을 보여주는 이미지이다. 단편화를 계속 놔두면, 지속적으로 힙에 구멍과 틈을 내서 힙을 사용하지 못하게 하고, 게임을 망가뜨림. 많은 콘솔 제조사에서, 게임 출시 전에 먼저 게임을 데모 모드로 며칠 동안 켜두는 ‘침투 테스트(soak test)’ 통과를 요구한다.(메모리 누수 + 메모리 단편화 예방하기 위해)둘 다 만족시키기 게임이 실행할 때 =&amp;gt; 메모리 미리 크게 잡아놓고 끝날 때까지 계속 들고 있으면 된다. 이 패턴은 이를 만족시킬 수 있다. 메모리 관리자 입장: 처음에 한번 메모리 잡음, 게임이 실행되는 동안 계속 들고 있을 수 있음 오브젝트 풀 사용자 입장: 마음껏 객체를 할당, 해제 가능 The pattern 재사용 가능한 객체들을 모아놓은 오브젝트 풀 클래스 정의 여기에 들어가는 객체는 현재 자신이 ‘사용중’인지 여부를 알 수 있는 방법을 제공해야 한다. -초기화: 사용할 객체들 미리 생성, ‘사용 안함’ 상태로 초기화 새로운 객체가 필요하면 풀에 요청 풀은 사용 가능한 객체를 찾아 ‘사용 중’으로 초기화한 뒤 반환한다. 메모리나 다른 자원 할당을 신경 쓰지 않고 객체를 생성, 삭제 가능언제 사용? 게임 개체나 시각적 효과같이 눈으로 볼 수 있는 것에 많이 사용된다. 사운드 같이 눈에 잘 보이지 않는 객체에도 사용 객체를 빈번하게 생성/삭제해야 하는 경우 객체들의 크기가 비슷한 경우 객체를 힙에 생성하기가 느리거나 메모리 단편화가 우려될 경우 데이터베이스 연결이나 네트워크 연결같이 접근 비용이 비싸면서 재사용 가능한 자원을 객체가 캡슐화하고 있는 경우주의 사항 오브젝트 풀 사용 == ‘메모리를 어떻게 처리할지를 사용자가 더 잘 안다’라고 선언하는것 오브젝트 풀의 한계도 사용자가 직접 해결해야 한다. 윈도우에서 16kb 이하의 메모리를 많이할당 =&amp;gt; LFH(low-fragmentation heap)을 쓰면 효과가 좋다.객체 풀에서 사용되지 않는 객체는 메모리 낭비와 다를 바 없다 객체 풀은 필요에 따라 크기를 조절해야 한다. 크기가 너무 작으면 크래시남 너무 커도 문제 한 번에 사용 가능한 객체 개수가 정해져 있다 메모리를 객체 종류별로 별개의 풀로 나누면 한번에 이펙트가 많이 터진다고 파티클 시스템이 메모리를 전부 먹는다거나, 메모리가 부족해 새로운 적 객체를 생성하지 못하는 문제를 막을 수 있다. 오브젝트 풀의 모든 객체가 사용 중이어서 재사용할 객체를 반환받지 못할 때를 대비해야함 이런 일이 생기지 않도록 해야함: 풀의 크기 조절 잘하기. 상황에 따라 풀의 크기를 다르게 조절할 수 있는지 고려해야함. 그냥 객체를 생성하지 않음: 파티클의 경우, 크게 상관은 없다.(파티클이 전부 사용되는 경우, 화면은 이미 화려하다) 기존 객체를 강제로 제거: 사운드의 경우, 소리가 가장 작은 것과 교체, 덮어 쓴다. 풀의 크기를 늘린다: 런타임에 늘리거나 보조 풀을 생성, 나중에 크기를 돌릴것인지 유지할것인지 결정해야함 객체를 위한 메모리 크기는 고정됨 다른 자료형이 모인 풀: 가장 큰 자료형에 맞춰야함 객체 크기가 다양하면 메모리 낭비 일어남 메모리관리자는 블록 크기에 따라 풀을 여러 개 준비한다. 메모리 요청을 받으면 크기에 맞는 풀에서 사용 가능한 메모리를 찾아 반환한다.재사용되는 객체는 저절로 초기화되지 않음 거의 모든 메모리 관리자가 디버깅을 위해 새로 할당한 메모리를 초기화하거나 삭제된 메모리를 구별할 수 있도록 0xdeadbeaf값을 덮어 쓴다. 이는 초기화되지 않은 변수나 이미 해제된 메모리를 사용하는 바람에 생기는 버그를 찾는데 도움이됨 새로운 객체를 초기화할 경우 주의해서 객체를 완전히 초기화해야함. 객체를 회수할 때 객체에 대한 메모리를 전부 초기화 하는 디버깅 기능을 추가하는것도 고려할만함. 사용 중이지 않은 객체도 메모리에 남아 있다 GC를 지원하는 시스템은 GC가 메모리 단편화 알아서 처리함. GC와 오브젝트 풀을 같이 사용한다면 충돌을 주의해야함 오브젝트 풀에서는 객체가 사용중이 아니더라도 메모리를 해제하지 않기 때문에 계속 메모리에 암음. 이 때 이들 객체가 다른 객체 참조 중이라면, GC는 그 객체를 회수하지 않음 예제 코드 예제는 단순한 파티클 시스템 (정해진 한 방향으로 이동 후 사라짐) 최소로 구현된 파티클 클래스는 다음과 같다. 기본 생성자에서는 파티클을 ‘사용 안함’으로 초기화 한다 파티클은 매 프레임마다 한번씩 실행되는 animate()를 통해서 애니메이션된다. 업데이트 메서드 패턴을 사용한 예 inUse(): 풀은 어떤 파티클을 재사용할 수 있는지 알기 위해서 inUse()를 호출한다. class Particle{public: Particle() : framesLeft_(0) {} void init(double x, double y, double xVel, double yVel, int lifetime) { x_ = x; y_ = y; xVel_ = xVel; yVel_ = yVel; framesLeft_ = lifetime; } void animate() { if (!inUse()) return; framesLeft_--; x_ += xVel_; y_ += yVel_; } bool inUse() const { return framesLeft_ &amp;gt; 0; }private: int framesLeft_; double x_, y_; double xVel_, yVel_;}; 풀: 객체를 재사용할 수 있는지 알기 위해 파티클 클래스의 inUse()를 호출한다. _framesLeft =&amp;gt; 정히진 시간동안 유지 =&amp;gt; 사용중인지 확인 animate()를 호출해 풀에 들어 있는 파티클을 차례차례 애니메이션한다. class ParticlePool{public: void create(double x, double y, double xVel, double yVel, int lifetime); void animate() { for (int i = 0; i &amp;lt; POOL_SIZE; i++) { particles_[i].animate(); } }private: static const int POOL_SIZE = 100; Particle particles_[POOL_SIZE];}; particles_는 고정 길이 배열이다.(동적 배열이나, 템플릿 매개변수로 크기 전달 가능)void ParticlePool::create(double x, double y, double xVel, double yVel, int lifetime){ // Find an available particle. for (int i = 0; i &amp;lt; POOL_SIZE; i++) { if (!particles_[i].inUse()) { particles_[i].init(x, y, xVel, yVel, lifetime); return; } }} 사용 가능한 파티클을 찾을 때까지 풀을 순회(비효율적) 파티클 렌더링을 빼면, 이게 전부, 파티클은 스스로 비활성화 파티클생성 복잡도 O(n) free list 파티클 객체의 데이터 일부를 활용하여 사용가능한 파티클을 찾는법 사용되지 않는 파티클에서 위치나 속도 같은 데이터는 의미가 없음. _frameLeft만 있으면됨 class Particle { public: // ... Particle* getNext() const { return state_.next; } void setNext(Particle* next) { state_.next = next; } private: int framesLeft_; union { // State when it&#39;s in use. struct { double x, y; double xVel, yVel; } live; // State when it&#39;s available. Particle* next; } state_; }; frameLeft_를 제외한 모든 멤버 변수를 state_ 공용체의 live 구조체 안으로 옮겼다. 사용중이 아닐 때: 공용체의 next가 사용됨. next: 이 파티클 다음에 사용 가능한 파티클 객체를 포인터로 가리킨다. next: 풀에서 사용 가능한 파티클이 묶여 있는 연결 리스트를 만들 수 있다. 이렇게 하면 추가 메모리 없이 객체의 메모리를 재활용해서 자기 자신을 사용 가능한 파티클 리스트에 등록하게 할 수 있다. 이와 같은 걸 빈칸 리스트(free list)기법이라고 부른다. 이 경우 포인터를 초기화할 때, 파티클이 생성, 삭제될 때에도 포인터를 관리, 리스트의 head도 관리해야함. class ParticlePool{ // ...private: Particle* firstAvailable_;}; 처음 풀을 생성하면, 모든 파티클이 사용 가능하므로, 빈칸 리스트에 전체가 연결된다.ParticlePool::ParticlePool(){ // The first one is available. firstAvailable_ = &amp;amp;particles_[0]; // Each particle points to the next. for (int i = 0; i &amp;lt; POOL_SIZE - 1; i++) { particles_[i].setNext(&amp;amp;particles_[i + 1]); } // The last one terminates the list. particles_[POOL_SIZE - 1].setNext(NULL);} 이제 새로운 파티클을 생성하기 위해서는 첫 번째 사용 가능한 파티클을 바로 얻어오면 된다.void ParticlePool::create(double x, double y, double xVel, double yVel, int lifetime){ // Make sure the pool isn&#39;t full. assert(firstAvailable_ != NULL); // Remove it from the available list. Particle* newParticle = firstAvailable_; firstAvailable_ = newParticle-&amp;gt;getNext(); newParticle-&amp;gt;init(x, y, xVel, yVel, lifetime);} 파티클이 죽으면, 다시 빈칸 리스트에 돌려줘야함. 프레임 단위에서 파티클이 죽었는지를 알 수 있도록 animate() 반환 값을 불리언으로 바꾸고 죽을 때 true를 반환한다. bool Particle::animate(){ if (!inUse()) return false; framesLeft_--; x_ += xVel_; y_ += yVel_; return framesLeft_ == 0;} 파티클이 죽으면 빈칸 리스트에 다시 넣는다. void ParticlePool::animate(){ for (int i = 0; i &amp;lt; POOL_SIZE; i++) { if (particles_[i].animate()) { // Add this particle to the front of the list. particles_[i].setNext(firstAvailable_); firstAvailable_ = &amp;amp;particles_[i]; } }}디자인 결정 실제 코드에서는 위 예제는 부족함. 객체 풀을 더 일반적이면서 사용하기에 안전하거나 유지보수하기 쉽게 만들 수 있음. 풀이 객체와 커플링되는가? 객체 풀을 구현 객체가 자신이 풀에 들어 있는지를 알게 할 것인지부터 결정해야함. 아무 객체나 담을 수 있는 일반적인 풀 클래스를 구현해야 한다면 이런걸 못할 수 있음 객체가 풀과 커플링된다면 더 간단하게 구현 가능: 객체에 플래그 하나만 두면 끝. 객체가 풀을 통해서만 생성할 수 있도록 강제 가능: C++에서는 풀 클래스를 객체 클래스의 friend로 만든 뒤 객체 생성자를 private에 두면 된다. 객체 클래스를 어떻게 사용해야 하는지를 문서화하는 효과 class Particle{ friend class ParticlePool;private: Particle() : inUse_(false) {} bool inUse_;};class ParticlePool{ Particle pool_[100];}; ‘사용 중’ 플래그가 꼭 필요한 건 아닐 수도 있다.: 객체에 자신이 사용 중인지를 알 수 있는 상태가 이미 있는 경우가 많음. ex. 화면 밖 객체가 풀과 커플링되지 않는다면 어떤 객체라도 풀에 넣을 수 있음 일반적이면서 재사용 가능한 풀 클래스를 구현할 수 있다. ‘사용 중’ 상태를 객체 외부에서 관리해야한다 비트 필드 따로 필요 template &amp;lt;class TObject&amp;gt;class GenericPool{private: static const int POOL_SIZE = 100; TObject pool_[POOL_SIZE]; bool inUse_[POOL_SIZE];}; 재사용되는 객체를 초기화할 때 어떤 점을 주의해야 하는가? 재사용을 위해, 새로 상태를 초기화 해야함. 객체 초기화를 풀 클래스 안에서? 밖에서? 객체를 풀 안에서 초기화한다면 풀은 객체를 완전히 캡슐화할 수 있음 객체를 풀 내부에 완전히 숨기기 가능 객체를 아예 참조할 수 없어서 예상치 못한 재사용 막음 풀 클래스는 객체가 초기화되는 방법과 결합 풀에 들어가는 객체 중에는 초기화 메서드를 여러개 지원하는 게 있을 수 있다. 풀에서 초기화를 관리하려면, 풀에 들어 있는 객체의 모든 초기화 메서드를 풀에서 지원해야함. 객체에도 포워딩해야함 class Particle{ // Multiple ways to initialize. void init(double x, double y); void init(double x, double y, double angle); void init(double x, double y, double xVel, double yVel);};class ParticlePool{public: void create(double x, double y) { // Forward to Particle... } void create(double x, double y, double angle) { // Forward to Particle... } void create(double x, double y, double xVel, double yVel) { // Forward to Particle... }}; 객체를 밖에서 초기화한다면 풀의 인터페이스는 단순해진다: 초기화 함수를 전부 제공할 거 없이 새로운 객체에 대한 레퍼런스만 반환하면 된다. class Particle{public: // Multiple ways to initialize. void init(double x, double y); void init(double x, double y, double angle); void init(double x, double y, double xVel, double yVel);};class ParticlePool{public: Particle* create() { // Return reference to available particle... }private: Particle pool_[100];}; 밖에서 반환받은 객체의 초기화 메서드를 바로 호출할 수 있다. ParticlePool pool; pool.create()-&amp;gt;init(1, 2); pool.create()-&amp;gt;init(1, 2, 0.3); pool.create()-&amp;gt;init(1, 2, 3.3, 4.4); 외부 코드에서는 객체 생성이 실패할 때의 처리를 챙겨야할 수 있다. 풀이 비어있는 경우 =&amp;gt; NULL 반환, 처리해야함 Particle* particle = pool.create();if (particle != NULL) particle-&amp;gt;init(1, 2); 관련 자료 경량 패턴과 비슷한 점이 많음 둘 다 재사용 가능한 객체 집합을 관리 차이점은 ‘재사용’의 의미 경량: 같은 인스턴스를 여러 객체에서 공유 =&amp;gt; 재사용, 같은 객체를 동시에 여러 문맥에서 사용함으로써 메모리 중복 사용을 피하는게 목적 오브젝트 풀: 동시에 재사용하지 않음, 재사용의 의미는 이전 사용자가 다 쓴 다음에 객체 메모리를 회수해 가는 것을 의미, 한곳에서만 사용됨 같은 종류의 객체를 메모리에 모아두면 =&amp;gt; CPU 캐시를 가득 채우는 데 도움이 됨.출처object-pool" }, { "title": "[게임 프로그래밍 패턴] Optimization Patterns: Dirty Flag", "url": "/posts/2022/02/28/12/34/pattern18/", "categories": "pattern", "tags": "", "date": "2022-02-28 12:34:13 +0900", "snippet": "Dirty Flag 불필요한 작업을 피하기 위해 실제로 필요할 때까지 그 일을 미룬다Motivation 많은 게임에서 월드에 들어 있는 모든 객체를 장면 그래프(scene graph)라는 큰 자료구조에 저장한다. 렌더링 코드에서는 장면 그래프를 이용하여, 화면에 그려야 할 것을 결정 가장 간단한 장면 그래프 구현: 객체 리스트 하나 모든 객체에는 모델 or 그래픽에 관련된 기본단위 데이터 + 트랜스폼(transform)이 들어 잇음 트랜스폼: 객체의 위치, 회전, 스케일을 표현 렌더러: 객체를 그릴 때 먼저 객체 모델을 받아서 트랜스폼 적용 =&amp;gt; 화면에 그림 장면 그래프: 계층형 장면 그래프의 객체: 자신에게 붙어 있는 객체의 상위 객체가 될 수 있음 하위 객체의 트랜스폼: 상위의 상대적인 값으로 저장됨 하지만 렌더링하기 위해서 절대 위치를 알아야함 객체의 Local transform 이 아닌 world transform을 알아야함. 트랜스폼 == 변환 값 로컬 트랜스폼 과 월드 트랜스폼 월드 변환 계산은 간단하다. (계속해서 합치면 끝) 상위 객체 없으면 로컬 == 월드 이 계산을 계속해서 해 매 프레임마다, 최신값으로 유지해야함 간단한 해결: 렌더링마다 새로 계산, 프레임마다 장면 그래프를 최상위 노드부터 순회할 때, 그때마다 월드 변환 값 계산 위 해결방법: CPU 자원 낭비 정적 지형같은 경우도 다시 계산해야됨 =&amp;gt; 낭비 월드 트랜스폼 캐싱 변환 값을 캐시하는것이 확실한 방법 모든 객체의 지역 + 월드 변환 값을 저장 렌더링 =&amp;gt; 미리 계산해놓은 월드 변환 값 사용 객체가 움직임 =&amp;gt; 월드 값 업데이트 하위 객체들 또한 월드 값 재귀적으로 재계산 필요 매번 재계산하면 중복 게산이 많아진다. ex) 배 =&amp;gt; 배의 하위 객체들, 배의 하위 객체 =&amp;gt; 그 아래의 하위 객체들 …. 아래 그림에서 앵무새는 마지막 값만 필요함, 이전 값들은 없어짐 문제: 월드 변환 =&amp;gt; 여러 개의 로컬 변환에 의존 같은 변환을 여러번 계산하게됨 재계산 미루기 문제 해결: 로컬 변환과 월드 변환 값 업데이트 분리 지역 변환 값부터 한 번에 전부 변경 업데이트해야 하는 월드 변환 값을 렌더링 직전에 한 번만 재계산. 이를 위해 장면 그래프에 들어가는 객체에 플래그를 추가 지역 변환 값이 바뀌면 플래그를 킴. 월드 변환값이 필요할 때 =&amp;gt; 플래그 검사 켜져있으면 계산 후 끔 플래그: ‘월드 변환 값이 더 이상 맞지 않음’ 맞지 않음 == 더티 더티 플래그 패턴 적용한 뒤 객체 이동은 다음과 같음.1비트 추가의 결과 상위 노드를 따라가면서, 여러 번 지역 변환을 곱하던 것을 객체당 한 번의 재계산으로 합친다. 움직이지 않는 객체는 변환 계산을 하지 않는다. 그 외에도 렌더링 전에 제거될 객체는 월드 변환 계산을 하지 않아도 된다는 장점.The pattern 계속해서 변경되는 기본 값(primary data) 파생값(derived data)은 기본 값에 비싼 작업을 거쳐야 얻을 수 있음. 더티 플래그는 파생 값이 참조하는 기본 값의 변경 여부 추적 기본 값 변경 =&amp;gt; 켜짐 파생 값 사용 =&amp;gt; 더티 플래그 켜진 상태 =&amp;gt; 재계산, 플래그 끔 꺼진 상태 =&amp;gt; 이전 캐시해놓은 파생 값 사용 언제 사용? 계산과 동기화라는 두 종류의 작업에 사용 둘 다 기본 값으로부터 파생 값을 얻는 게 오래 걸리거나 비용이 크다. 장면 그래프 에제: 계산 양이 많음 동기화: 파생 값이 디스크나 네트워크상에 있는 다른 기기 등, 원격에 있어 가져오는 비용이 큼요구사항 파생 값이 사용되는 횟수보다 기본 값이 더 자주 변경 되어져야함 기본 값이 변경 =&amp;gt; 이전 계산된 파생 값 무효화 되는 것을 막음 기본값이 바뀔 때마다 파생 값이 항상 필요하면, 이 패턴은 쓸모 없음 점진적으로 업데이트하기 어려워야함 무게를 계산할 때 배에 무언가를 쌓는다면, 매번 무언가가 늘어날 때 재 계산하기보다는, 전체 값을 유지한 채 더하고 빼는게 좋음 =&amp;gt; 더티 플래그가 유용하지 않은 예 주의 사항너무 오래 지연하려면 비용이 든다 더티 플래그 패턴: 오래 걸리는 작업을 결과가 실제로 필요할 때까지 지연 하지만, 막상 결과가 당장 필요할 때가 많음. 전체를 처리하는 데 상당한 시간이 걸리는 작업이 있다 해보자. 이 작업을 지연 =&amp;gt; 결과를 보고싶을 때 처리 =&amp;gt; 하면 멈춤. GC 정책에서도 비슷함. 참조 상태가 바뀔 때 마다 =&amp;gt; 모든 레퍼런스 횟수 업데이트 =&amp;gt; CPU 낭비 단순한 GC: 메모리 꽉차면 메모리 회수 =&amp;gt; GC가 정리할 때 까지 멈춤 =&amp;gt; GC pause 현상(STW) 복잡한 GC: 지연 레퍼런스 카운팅( deferred ref-counting), 증분(incremental)은 두 방식을 절충(참조 횟수 업데이트, 메모리 회수) 작업 지연 문제: 작업이 전부 날아갈 수 있음. - 영속적인 상태 저장에 더티 플래그 패턴을 사용할 경우(when you’re using this pattern to save some state to a more persistent form.) - ex. 텍스트 편집기 =&amp;gt; 변경내용 저장되지 않았음. - 도중에 끄면 자동저장 기능이 없다면 전부 날라감(자동저장 =&amp;gt; 단점 보완)상태가 변할 때마다 플래그를 켜야함 필킬턴: “컴퓨터 과학에서 어려운 것은 캐시 무효화와 이름 정하기” 기본 값 =&amp;gt; 파생 값 파생값은 본질적으로 캐시 캐시 무효화(cache invalidation): 데이터를 캐시할 때 어려운 부분, 원본 데이터가 변경될 때 캐시 값이 더 이상 맞지 않음을 제때 알려주는 작업.(기본 값 변경시 더티플래그 켜주는 작업) 이를 놓치면, 무효화된 파생 값 사용됨 버그 생길 가능성 높음 기본 값을 변경하는 모든 코드가 더티 플래그를 수정하도록 해야함 해결 방법: 기본 값을 변경하는 코드를 인터페이스로 캡슐화 하나의 API에서 수정하도록 이전 파생 값을 메모리에 저장해야함 동기화에 사용될 경우 메모리에 저장되지 않으므로 상관없음. 더티플래그 사용x: 계산한 후 값 버리기(계산 비용 생기지만, 메모리 캐시 부담 피함) 더티 플래그: 속도를 위해 메모리 희생 압축알고리즘: 압축을 푸는 데 필요한 계산 시간을 비용 삼아 공간을 최적화예제 코드트랜스폼 예제: 패턴 적용전 class Transform{public: static Transform origin(); Transform combine(Transform&amp;amp; other);}; combine(): 상위 노드를 따라서 로컬 값을 전부 결합, 월드 값 리턴 origin(): 단위 행렬 리턴 장면 그래프에 들어갈 객체의 클래스는 다음과 같다.(패턴 적용전) class GraphNode{public: GraphNode(Mesh* mesh) : mesh_(mesh), local_(Transform::origin()) {}private: Transform local_; Mesh* mesh_; GraphNode* children_[MAX_CHILDREN]; int numChildren_;}; mesh_: 그래픽스 객체, 보이지 않을 경우 NULL 장면 그래프는 모든 객체를 하위에 두는 하나의 최상단 GraphNode GraphNode* graph_ = new GraphNode(NULL);// Add children to root graph node... 장면 그래프를 그리기 위해, 루트부터 시작해서 전체 노드 트리를 순회해야함. 각 노드마다 월드 변환과 메시값을 인수로 renderMesh 호출 void renderMesh(Mesh* mesh, Transform transform); 트랜스폼 예제: 패턴 적용 전 순회 코드 렌더링하기위해 다음 메서드 추가 void GraphNode::render(Transform parentWorld){ Transform world = local_.combine(parentWorld); if (mesh_) renderMesh(mesh_, world); for (int i = 0; i &amp;lt; numChildren_; i++) { children_[i]-&amp;gt;render(world); }} 장면 그래프 전체 그리기: 루트 노드부터 시작 graph_-&amp;gt;render(Transform::origin()); 트랜스폼 예제: 패턴 적용 이 예제 코드는 모든 매시를 정확히 그리지만 매 프레임마다 모든 노드에 대해 local_.combine(parentWorld)를 호출하고 있다는 점에서 비효율적이다. 더티 플레그 패턴으로 해결 월드 값과 플래그 추가 class GraphNode{public: GraphNode(Mesh* mesh) : mesh_(mesh), local_(Transform::origin()), dirty_(true) {} // Other methods...private: Transform world_; bool dirty_; // Other fields...}; 플래그 초기 값: 참(월드 값 계산 반영 전) 이동하기 위해 트랜스폼 변환 함수를 추가해보자 void GraphNode::setTransform(Transform local){ local_ = local; dirty_ = true;} setTransform()이 호출할 때마다 플래그도 같이 켜짐 상위 노드가 이동 =&amp;gt; 모든 하위 노드들의 월드 값 무효화 하지만 전체 플래그를 변경하면 느림 렌더링할 때 처리하면 됨. 여기에서는 if문 검사가 행렬 곱셈보다 빠르다고 가정 요즘 CPU에서는 파이프라이닝 기법에 많이 의존하므로 분기 예측 실패가 일어나면 사이클 많이 낭비할 가능성도 있음을 주의해야함 void GraphNode::render(Transform parentWorld, bool dirty){ dirty |= dirty_; if (dirty) { world_ = local_.combine(parentWorld); dirty_ = false; } if (mesh_) renderMesh(mesh_, world_); for (int i = 0; i &amp;lt; numChildren_; i++) { children_[i]-&amp;gt;render(world_, dirty); }} 플래그가 꺼져있으면 combine 연산하지 않음을 코드에서 볼 수 있음. 또한 플래그 값을 넘겨 setTransform()에서 상위가 움직였을 경우 하위 플래그들의 플래그를 변경안해줘도됨 결과적으로 노드의 로컬 값을 몇 번의 대입만으로 바꿀 수 있고, 렌더링 할 때에는 이전 프레임 이후로 변경된 노드에 대해서만 최소한으로 월드 값을 계산하면됨. 이런 기법은 GraphNode에서 render()외에는 최신 월드 변환 값을 필요로 하는 곳이 없을 때만 가능. 다른 곳에 최신 값이 필요하다면 다르게 구현해야함디자인 결정언제 플래그를 끄는가?결과가 필요할 때 결과 값이 필요 없다면 아예 계산하지 않을 수 있다 파생 값 사용빈도 &amp;lt; 기본 값 변경 빈도 인경우 좋음 계산시간이 오래 걸린다면 거슬리는 멈춤 현상이 생길 수 있음 더 일찍 계산해야함. At well-defined checkpoints 어떤 지점에서 특정 이벤트를 작동 시킬 수 있거나 작동될경우 로딩 화면이나 컷신 나오는 동안 작업 처리 지연 작업 처리가 플레이 경험에 영향 주지 않음 작업중 관심을 돌릴 수 있는 화면 출력 가능 전과는 반대로 작업처리 시점을 제어할 수 없다 지연 작업 처리 == 세밀하게 제어 가능, 게임에서 깔끔하게 처리 가능. 체크포인트에 억지로 보내거나 특정행동을 하도록 강제할 수 없기 때문에 플레이어가 길을 잃거나 게임 상태가 꼬여버리면 의도했던 것보다 오래 작업이 지연될 수있다. 백그라운드로 처리할 때 처음 값을 변경하면, 정해진 타이머를 추가하고 타이머가 돌아올 경우 변경사항 처리 HCI(human-computer interaction)에서는 프로그램이 사용자 입력을 받았을 때 약간 기다렸다가 응답하는 것을 이력현상(hysteresis)라고 함 얼마나 자주 작업을 처리할 지 조절 가능 타이머 간격 조절 필요 없는 작업을 더 많이 할 수 있음 변경된 상태가 얼마 안된 것, 같이 처리하게됨 비동기 작업 지원 ‘백그라운드’로 데이터 처리: 그동안 플레이어도 계속 하던 일 할 수 있음 멀티스레딩 or 동시성 기법 =&amp;gt; 데이터 접근 동시성 =&amp;gt; 데이터 안전하게 변경 가능 플래그는 값 변화를 얼마나 세밀하게 관리하는가? 개발 중인 해적 게임에서, 배를 만들고 개조 가능하다고 가정 배는 서버에 자동 저장, 이전 상태로 다시 시작 가능 갑판이 변경 =&amp;gt; 값을 서버로 보내야할지를 플래그로 확인 서버로 보내는 데이터 =&amp;gt; 변경된 배에 대한 데이터 + 배의 어디가 변경되었는지를 나타내는 메타데이터 더 세밀하게 관리 갑판의 모든 널빤지마다 더티플래그 실제로 변경된 데이터만 처리 정확하게 변경된 부분만 서버로 전달 더 듬성듬성하게 관리 갑판별 더티 비트 갑판의 널빤치 어느 하나라도 변경 =&amp;gt; 갑판 전체에 대한 비트가 켜짐 변경 안된 데이터도 같이 처리 더티 플래그에 드는 메모리 줄어든다 고정 오버헤드에 드는 시간이 줄어든다 데이터 처리 외의 일종의 고정작업(메타데이터), 데이터를 더 큰 단위 == 메타데이터 적음 == 오버헤드 적음 관련 자료 앵귤러 같은 브라우저-사이드 웹 프레임워크에서도 흔하게 사용됨 앵귤러는 브라우저에서 어느 데이터가 변경되었고 서버에 올려야 할지를 더티 플래그로 관리한다. 물리엔진에서는 어떤 객체가 움직이는 중인지, 멈춰있는지를 기록한다. 멈춰 있는 물체는 충격을 받기 전에는 움직이지 않음, 누가 건드리기 전에는 아무런 처리 x 이런 isMoving 플래그는 객체가 힘을 적용받아 물리 처리를 해야 하는지를 알려주는 더티플래그가 됨. 출처dirty-flag" }, { "title": "[게임 프로그래밍 패턴] Optimization Patterns: Data Locality", "url": "/posts/2022/02/27/08/32/pattern17/", "categories": "pattern", "tags": "", "date": "2022-02-27 08:32:58 +0900", "snippet": "최적화 패턴 하드웨어 성능을 끌어내기 위해 게임 속도를 높이는 데 사용되는 중간 수준(mid-level)의 패턴들 데이터 지역성 패턴: 컴퓨터 메모리 계층과 이를 활용하는 법 더티 플래그 패턴: 불필요한 계산 오브젝트 풀 패턴: 불필요한 객체 할당 피하는법 공간 분할 패턴: 게임 월드 공간 내에서 객체들을 빠르게 배치할 수 있게 해줌데이터 지역성 CPU 캐시를 최대한 활용할 수 있도록 데이터를 배치해 메모리 접근 속도를 높인다.Motivation 무어의 법칙으로 하드웨어는 급속히 발달했다. 하지만 데이터 연산은 훨씬 빨라졌지만, 데이터를 가져오는 건 그렇게 빨라지지 않았다. CPU성능은 급격하게 증가한 반면, RAM은 더 뒤쳐짐 주 메모리 ==데이터==&amp;gt; 레지스터 RAM은 CPU 속도를 전혀 따라잡지 못함. RAM에서 데이터를 한 바이트 가져오는 데 몇백 CPU 사이클 정도가 걸린다.(2010년대) RAM은 디스크 드라이브와는 달리 이론적으로는 어느 데이터나 같은 시간 안에 접근할 수 있어서 ‘임의접근기억장치’라고 부른다. RAM은 디스크처럼 순차 읽기를 걱정하지 않아도 된다.(그래도 완전히 임의접근이 가능한건 아님) CPU는 대부분의 시간을 데이터를 기다리며 대기상태로 있지 않는다.CPU를 위한 팰릿 CPU 캐싱 CPU안에 작은 메모리, 메인메모리보다 훨씬 빠르게 CPU에 데이터를 전달할 수 있다. CPU 칩 안에 들어가기 때문에, 빠르고 용량이 작고 비싸다(static RAM, SRAM) 캐시: 작은 크기의 메모리 (칩내부: L1캐시) 캐시 == 팰릿 칩이 RAM으로부터 데이터를 한 바이트라도 가져와야 할 경우, RAM은 보통(64~128바이트 정도의) 연속된 메모리를 선택해 캐시에 복사함다. - 이런 메모리 덩어리를 캐시 라인(cache line)이라고 한다. L1, L2, L3와 같이 여러 계층으로 나뉜다. 숫자가 올라갈수록 크기는 커지지만, 속도는 느려진다. 필요한 데이터가 캐시 라인 안에 들어 있다면 CPU는 RAM보다 빠른 캐시로부터 데이터를 가져온다. 캐시 라인이 여러개 =&amp;gt; 캐시 집합(cache associativity) 캐시 히트: 캐시에서 원하는 데이터를 찾는 것 캐시 미스: 데이터를 찾지 못해 주 메모리에서 데이터를 가져오는 것 캐시 미스가 발생하면 CPU는 멈춘다. 이렇게 기다리는 시간을 최대한 피해야한다. Wait, data is performance? 캐시를 뒤엎는 코드: 저자가 테스트했을 때, 속도가 50배 차이남. 데이터를 어떻게 두느냐가 성능에 직접적인 영향을 미침. 캐시 최적화는 굉장히 큰 주제: 명령어 캐시 같은것도 있다. 코드 역시 메모리에 존재, CPU에 로드되어야함 캐시 뒤엎기(cache thrash): 캐시 무효화가 계속 반복되는 현상 Data-Oriented Design 이 장에선 자료구조가 성능에 어떻게 영향을 미치는지에 대해 간단한 기법 몇가지를 소개함. 모든 기법의 결론: 캐시 라인에 있는 값을 더 많이 사용할수록 더 빠르게 만들 수 있다. 즉, 자료구조를 잘 만들어서 처리하려는 값이 메모리 내에서 서로 가까이 붙어 있도록 해야한다. 여기에선 스레드가 하나라는 가정이 있음. 두 스레드에 같은 캐시 라인에 들어 있는 데이터를 고치려 든다면, 두 코어 모두 비싼 캐시 동기화 작업을 해야한다. =&amp;gt; 캐시 일관성 프로톨콜에 대한 내용: “프로그래머가 몰랐던 멀티 코더 CPU이야기” 이렇게 하려면 아래 그림처럼 실제 객체 데이터가 순서대로 들어있어야 한다. The pattern CPU는 메모리 접근 속도를 높이기 위해 캐시를 여러개 둔다. 캐시를 사용하면 최근에 접근한 메모리 근처에 있는 메모리를 훨씬 빠르게 접근할 수 있다. 데이터 지역성을 높읠수록, 즉, 데이터를 처리하는 순서대로 연속된 메모리에 둘수록 캐시를 통해서 성느응ㄹ 향상할 수 있다.언제 사용? 데이터 지역성 패턴: 성능 문제가 있을 경우 사용해야함. 필요 없는 곳을 최적화해 봐야 코드만 복잡해지고 유연성만 떨어짐. 성능 문제가 캐시 미스 때문인지 확인해야함. 프로파이링: 쿠드 두 지점 사이에 얼마나 시간이 지났는지 타이머 코드 넣음. 캐시 사용량을 확인하려면 더 복잡한 방법이 필요 지원하는 프로파일러들 사용해야함. 개발하는 내내 자료구조를 캐시하기 좋게 만들려고 노력할 필요가 있다. 프로파일러: Cachegrind 는 프로그램을 가상의 CPU와 캐시 계층 위에서 실행한 뒤에 모든 캐시 상호작용 결과를 알려준다. 가상 함수 호출: CPU가 객체의 vtable에서 실제로 호출할 함수 포인터를 찾아야함. =&amp;gt; 포인터 추적 발생 =&amp;gt; 캐시 미스주의사항 추상화: 소프트웨어 아키텍처의 전형적인 특징 중 하나 객체 지향 언어 =&amp;gt; 인터페이스 사용하여 디커플링 C++에서 인터페이스를 사용하려면 포인터나 레퍼런스를 통해 객체에 접근해야함. 포인터 사용 =&amp;gt; 메모리를 여기저기서 찾아가야 하기 때문에, 캐시미스가 발생한다. 추상화를 일부 희생해야 데이터 지역성을 사용할 수 있음. 상속, 인터페이스로부터 얻을 수 있는 이득을 포기해야함. 샘플 코드연속 배열 게임 루프부터 시작 게임 개체는 컴포넌트 패턴을 이용해 AI, 물리, 렌더링 같은 분야로 나눈다. 컴포넌트에 직접 접근하는 게임루프 GameEntity 클래스는 다음과 같다. class GameEntity{public: GameEntity(AIComponent* ai, PhysicsComponent* physics, RenderComponent* render) : ai_(ai), physics_(physics), render_(render) {} AIComponent* ai() { return ai_; } PhysicsComponent* physics() { return physics_; } RenderComponent* render() { return render_; }private: AIComponent* ai_; PhysicsComponent* physics_; RenderComponent* render_;}; 각 컴포넌트에는 벡터 몇 개 또는 행렬 한 개 같은 몇몇 상태와 이를 업데이트하기 위한 메서드가 들어 있다.(업데이트 메서드 패턴 사용) class AIComponent{public: void update() { /* Work with and modify state... */ }private: // Goals, mood, etc. ...};class PhysicsComponent{public: void update() { /* Work with and modify state... */ }private: // Rigid body, velocity, mass, etc. ...};class RenderComponent{public: void render() { /* Work with and modify state... */ }private: // Mesh, textures, shaders, etc. ...}; 월드에 있는 모든 개체는 거대한 포인터 배열 하나로 관리한다. 매번 게임 루프를 돌 때마다 다음 작업을 수행한다. 모든 개체의 AI 컴포넌트를 업데이트한다. 모든 개체의 물리 컴포넌트를 업데이트한다. 렌더링 컴포넌트를 통해서 모든 개체를 렌더링한다. 대부분 다음과 같이 구현한다. while (!gameOver){ // Process AI. for (int i = 0; i &amp;lt; numEntities; i++) { entities[i]-&amp;gt;ai()-&amp;gt;update(); } // Update physics. for (int i = 0; i &amp;lt; numEntities; i++) { entities[i]-&amp;gt;physics()-&amp;gt;update(); } // Draw to screen. for (int i = 0; i &amp;lt; numEntities; i++) { entities[i]-&amp;gt;render()-&amp;gt;render(); } // Other game loop machinery for timing...} 이 코드는 단순히 캐시를 뒤엎는 정도가 아니라 더 심각함. 아래와 같은 일들이 일어남. 게임 개체가 배열에 포인터로 저장되어 있음, 배열 값에 접근할 때마다 포인터를 따라가면서 캐시 미스가 발생 게임 개체는 컴포넌트를 포인터로 들고 있어서 캐시 미스 발생 컴포넌트를 업데이트 모든 개체의 모든 컴포넌트에 대해 같은 작업 반복 포인터 추적(pointer chasing): 포인터를 따라다니느라 시간을 낭비하는것 이들 객체의 메모리 배치는 메모리 메니저만 알고, 우리는 전혀 모름 -개체가 할당, 해제를 반복할수록 힙은 점점 어질러짐. 개선해보자. 게임 루프에는 컴포넌트만 있으면 된다. 다음과 같이 AI, 물리, 렌더링 컴포넌트 타입별로 큰 배열을 준비한다. AIComponent* aiComponents = new AIComponent[MAX_ENTITIES];PhysicsComponent* physicsComponents = new PhysicsComponent[MAX_ENTITIES];RenderComponent* renderComponents = new RenderComponent[MAX_ENTITIES]; 배열에 컴포넌트가 포인터가 아닌 컴포넌트 객체가 들어간다는 점이 중요 모든 데이터가 배열 안에 나란히 들어 있기 때문에 게임 루프에서는 객체에 바로 접근할 수 있다. while (!gameOver){ // Process AI. for (int i = 0; i &amp;lt; numEntities; i++) { aiComponents[i].update(); } // Update physics. for (int i = 0; i &amp;lt; numEntities; i++) { physicsComponents[i].update(); } // Draw to screen. for (int i = 0; i &amp;lt; numEntities; i++) { renderComponents[i].render(); } // Other game loop machinery for timing...} 간접 참조 연산자(-&amp;gt;)의 개수를 줄인것을 볼 수 있음. 이는 데이터 지역성을 높엿다는 것을 의미함. 포인터 추적을 제거했으므로, 메모리를 여기저기 뒤지지 않고, 연속된 배열 세 개를 쭉 따라갈 수 있다. 변경된 코드는 연속된 바이트 스트림을 CPU에 계속 밀어 넣는다. 저자 테스트 결과 업데이트 루프가 50배 빨라짐. 그리고 캡슐화를 많이 해치지 않는다. 컴포넌트는 자기 데이터와 메서드가 있다는 점에서 여전히 잘 캡슐화되어 있다. 단순히 컴포넌트가 사용되는 방식만 변함. GameEntity 클래스를 제거할 필요는 없다. 여기에 컴포넌트에 대한 포인터를 가지도록 만들 수 있다. 포인터는 이들 배열에 있는 객체를 가리킨다. 개념적인 ‘게임 개체’와 개체에 포함되어 있는 것 전부를 한 객체로 다른 코드에 전달 할 수 있기 때문에 유용함. 게임 루프 == 성능에 민감, 게임 개체를 우회해서 게임 개체 내부 데이터(컴포넌트)에 직접 접근했다는 점이 중요 정렬된 데이터 파티클 시스템을 살펴보자. 앞의 예제처럼 파티클들을 하나의 배열에 두고, 간단한 관리 클래스로 래핑 class Particle{public: void update() { /* Gravity, etc. ... */ } // Position, velocity, etc. ...};class ParticleSystem{public: ParticleSystem() : numParticles_(0) {} void update();private: static const int MAX_PARTICLES = 100000; int numParticles_; Particle particles_[MAX_PARTICLES];}; 파티클 시스템의 업데이트 메서드는 다음과 같은 기본 기능만 한다.void ParticleSystem::update(){ for (int i = 0; i &amp;lt; numParticles_; i++) { particles_[i].update(); }} 하지만, 파티클 객체를 매번 전부 처리할 필요는 없다. 파티클 시스템에는 고정크기 객체 풀이 있지만, 풀에 있는 파티클이 전부 화면에서 반짝거리는 건 아님. 아래와 같이 해결할 수 있음. for (int i = 0; i &amp;lt; numParticles_; i++){ if (particles_[i].isActive()) { particles_[i].update(); }} 이 코드의 문제점: 모든 파키클에 대해 if 검사 =&amp;gt; CPU 분기 예측 실패를 겪으면서 파이프라인 지연(pipeline stall)이 생길 수 있음. CPU 분기 예측: 이전에 어떻게 분기했는지 예측, 하지만 활성 비활성이 반복될 경우 이 예측의 실패율은 올라감, 그러므로 파이프라인을 정리(flush)하고, 다시 시작해야하는 빈도가 증가하게됨 위와 같이 코드를 짜면, 업데이트 루프에서 모든 파티클에 대해서 이 값을 검사함. 활성 파티클이 적을수록, 메모리를 더 자주 건너뛰게됨.(비활성화 =&amp;gt; 로딩한 데이터 무용지물) 캐시미스 발생 =&amp;gt; 배열이 크고, 비활성 파티클이 많으면 캐시 뒤엎기 문제 발생 이처럼 연속적인 배열에 둔다해도, 실제로 처리할 객체가 배열에 연속되어 있지 않으면 도움되지 않음 활성 여부를 플래그로 검사하지 않고, 활성 파티클만 앞에 모아두면된다. 그러면 다음과 같이 수정할 수 있다.for (int i = 0; i &amp;lt; numActive_; i++){ particles[i].update();} 매 프레임마다 퀵소트하는것이 아니라, 활성 객체를 앞에 모아두기만 하면된다. 파티클이 활성화 되면, 이를 비활성 파티클 중에서 맨 앞에 있는것과 스왑하면 끝 처음: 모든 파티클이 비활성 상태로 정리 배열의 정리 상태: 파티클의 활성 상태가 변할 때만 깨짐 void ParticleSystem::activateParticle(int index){ // Shouldn&#39;t already be active! assert(index &amp;gt; numActive_); // assert(index&amp;gt;=numActive_) // Swap it with the first inactive particle // right after the active ones. Particle temp = particles_[numActive_]; particles_[numActive_] = particles_[index]; particles_[index] = temp; // Now there&#39;s one more. numActive_++;} 비활성화는 다음과 같다.void ParticleSystem::deactivateParticle(int index){ // Shouldn&#39;t already be inactive! //assert(index &amp;lt; numActive_); assert(index &amp;lt;= numActive_); // There&#39;s one fewer. numActive_--; // Swap it with the last active particle // right before the inactive ones. Particle temp = particles_[numActive_]; particles_[numActive_] = particles_[index]; particles_[index] = temp;} 저자를 포함한 대부분의 프로그래머들은 이처럼 메모리에서 객체를 복사로 옮기기를 꺼려한다. 여러 바이트를 옮기는 것이 포인터를 할당하는 것에 비해서 무겁다고 느끼기 때문. 하지만 포인터 추적 비용을 생각하면 틀릴 수 있다. 캐시를 계속 채워놓는 경우, 메모리 복사가 더 쌀 수 있다. 이렇게 하면 객체지향성을 어느 정도 포기해야함 Particle 클래스는 자시느이 활성 상태를 스스로 제어할 수 없음. 파티클을 활성화하려면 꼭 ParticleSystem클래스를 통해야함. 빈번한 코드와 한산한 코드 나누기 간단한 기법으로 캐시를 활용할 수 있는 예제 AI 컴포넌트에서 현재 재생 중인 애니메이션, 이동 중인 묙표 지점, 에너지 값 등이 들어 있어서 프레임마다 이 값을 확인하고 변경해야 한다. class AIComponent{public: void update() { /* ... */ }private: Animation* animation_; double energy_; Vector goalPos_;}; 하지만 AI 컴포넌트에는 사용 빈도수가 적은 상태도 있다. 죽은 뒤 아이템을 떨어뜨려야할 때가 그렇다. 이 ‘드랍’ 데이터는 개체가 죽었을 때 한 번만 사용된다. class AIComponent{public: void update() { /* ... */ }private: // Previous fields... LootType drop_; int minDrops_; int maxDrops_; double chanceOfDrop_;}; 컴포넌트 크기가 커져, 캐시 라인에 들어갈 컴포넌트 개수가 줄었다. 읽어야 할 전체 데이터 크기가 크다 보니, 캐시 미스가 더 자주 발생한다. 드랍 정보 == 업데이트에서 사용 안하고, 매 프레임마다 캐시로 읽어옴. 해결: ‘빈번한 코드와 한산한 코드를 나누는것(hot/cold spliting)’ 데이터를 두 개로 분리해 한곳에는 매 프레임마다 필요로 하는 ‘빈번한(hot)’ 데이터와 상태를 두고, 다른 곳에는 ‘한산한(cold)’ 데이터, 즉 자주 사용하지 않는 것들을 모아둔다. 자주 사용 == 포인터를 거치지 않기 가끔 사용 == 포인터로 가리키게 함class AIComponent{public: // Methods...private: Animation* animation_; double energy_; Vector goalPos_; LootDrop* loot_;};class LootDrop{ friend class AIComponent; LootType drop_; int minDrops_; int maxDrops_; double chanceOfDrop_;}; 더 많이 캐시에 올라갈 수 있다. 하지만, 이렇게 나누기 애매함. 실제 게임 코드에서는 분간하기 쉽지 않음. 최적화하기 위해서 연습, 노가다가 필요 한산한 데이터/ 빈번한 데이터 두 개의 배열에 나란히 두면 포인터 모두 제거 가능, 두 데이터는 각자의 배열에서 같은 인덱스 위에 있어 쉽게 찾을 수 있음.디자인 결정 메모리 배치에 따라 성능이 변함 구현은 다양함. 자료구조나 전체 구조를 변경할 수 있음. 많은 사람이 캐시를 활용할 수 있도록 게임 코드를 디자인하게 만든 노엘 로피스의 유명한 글: ‘데이터 중심 디자인’, 번역다형성(polymorphism)은 어떻게 할 것? 배열에는 있는 객체 크기가 모두 같다: 멤버 변수가 추가되지 않은 하위 클래스는 상위 클래스와 크기가 같음 =&amp;gt; 억지로 배열에 집어넣을 수 있음. 정렬된 단일 자료형 객체 배열이라고 가정. 다형성, 동적 디스패치를 같이 사용하는 방법?사용하지 않는다 요즘 상속을 과하게 사용하지 않는 편. 상속 없이 다형성의 유연함 =&amp;gt; 타입 오브젝트 패턴 안전하고 쉬움. 모든 객체는 정확하게 같은 크기, 어떤 클래스를 다루고 있는지 정확하게 안다. 더 빠르다 동적 디스패치: vtable에서 메서드를 찾아본 다음에 포인터를 통해서 실제 코드를 찾아가야한다.(성능 비용) 유연하지 않다 객체간 동작을 다르게 할 수 없음 이를 동적 디스패치 없이 지원하기 위해 함수 안에 다중 선택문 같은걸 넣는다면, 코드가 지저분해짐 종류별로 다른 배열에 넣는다 다형성 사용: 어떤 자료형인지 모르는 객체의 특정 행동을 호출하고 싶은 경우. 종류별로 다른 컬렉션에 나눠담기 객체를 빈틈없이 담을 수 있음 한 가지 클래스 객체만 들어감 =&amp;gt; 패딩(공용체 이용)도 없고, 그외 다른것도 들어갈 틈이 없음 정적 디스패치를 할 수 있다 종류별로 객체를 나눔 =&amp;gt; 다형성을 사용하지 않고, 일반적인 비-가상함수 호출가능 여러 컬렉션을 관리해야함 객체 종류가 많으면, 종류별로 배열을 관리하는 부담이 커질 수 있다. 모든 자료형을 알고 있어야 함 전체 클래스 자료형과 커플링됨. 다형성의 장점 == 확장성(open-ended) 어떤 인터페이스와 상호작용하는 코드 == 해당 인터페이스를 구현하는 구체 클래스가 아무리 많아도 이들과 전혀 커플링되지 않음. 하나의 컬렉션에 포인터를 모아놓는다 캐시를 신경쓰지 않는 경우 다형성 최대한 활용 어떤 크기의 객체라도 배열에서 포인터로 가리킴 유연 인터페이스 =&amp;gt; 어떤 종류의 객체라도 기존 코드와 상호작용 캐시 친화적이지 않음게임 개체는 어떻게 정의? 컴포넌트 패턴도 같이 사용할 경우, 연속된 배열에 모든 컴포넌트들이 이 배열에 들어감. 게임 루프 == 컴포넌트들을 직접 순회, 게임 개체 자체는 그다지 중요하지 않음. 개념적인(conceptual) ‘개체(entity)’를 표현하고 싶을 때에는 여전히 게임 개체 객체가 쓸모 있다. 그러면 어떻게 게임 개체 표현? 어떻게 컴포넌트 관리?게임 개체 클래스가 자기 컴포넌트를 포인터로 들고 있을 경우 일반적인 OOP식 해결 방법 포인터를 가지므로, 메모리 어디에 들어있는지 모름 컴포넌트들을 연속된 배열에 저장 가능 컴포넌트들을 정렬된 배열에 둬서 순회 작업 최적화 가능 개체로부터 개체 컴포넌트 쉽게 얻기 가능 컴포넌트를 메모리에서 옮기기 어려움 개체가 포인터로 가리키므로, 배열내에서 컴포넌트의 위치가 변경되면 같이 변경해야함 게임 개체 클래스가 컴포넌트를 ID로 들고 있을 경우 컴포넌트를 ID나 인덱스를 통해서 찾게 컴포넌트별로 유일한 ID를 발급 =&amp;gt; 배열에서 찾기 컴포넌트 배열에서 현재 위치를 ID와 매핑하는 해시 테이블로 관리 복잡함 포인터를 쓰는 것보다는 할 일이 많음. 시스템 구현, 디버깅, 메모리도 더 필요 더 느림 컴포넌트 찾기 =&amp;gt; 해싱 작업 =&amp;gt; 포인터를 따라가는 것보다는 느림 컴포넌트 ‘관리자’같은 것에 접근해야함 기본 아이디어: ID를 컴포넌트의 추상 식별자로 사용 =&amp;gt; 실제 컴포넌트 객체 레퍼런스 얻기 무엇인가가 ID를 받아서 컴포넌트를 찾아줘야함 =&amp;gt; 컴포넌트 배열을 래핑한 클래스가 그 역할을 맡음 이 경우 컴포넌트 레지스터리가 필요함. 게임 개체가 단순히 ID일 경우 몇몇 게임에서 사용하는 최신 방식. 개체의 동작과 상태를 전부 컴포넌트로 관리 =&amp;gt; 개체에는 컴포넌트 집합만 남음 컴포넌트들끼리 상호작용해야하기 때문에 개체는 여전히 필요 모든 컴포넌트는 자신이 속한 개체의 형제 컴포넌트에 접근할 수 있어야함. 모든 컴포넌트는 자신을 소유하는 개체의 ID를 기억해야함. 개체 클래스는 완전히 사라지고, 숫자만으로 컴포넌트를 묶을 수 있음. 개체가 단순해짐 개체가 비어 있음 단점: 모든 것이 컴포넌트 상태나 작동을 둘 곳이 없어짐 컴포넌트 패턴에 더 집중 개체 생명주기를 관리하지 않아도 됨 개체는 그저 단순한 값. 개체를 구성하는 모든 컴포넌트가 파괴될 때 죽음 특정 개체의 컴포넌트를 찾는 게 느릴 수 있음 ‘개체가 컴포넌트들을 ID로 관리할 때’와 같은 문제지만 방향은 다름 컴포넌트 얻기 == ID로 : 작업 비용이 비쌀 수 있음 성능에 민감: 상호작용이 많은 경우, 자주 컴포넌트를 찾아야할 수 있음 해결: 컴포넌트를 종류별로 들고 있는 배열에서의 인덱스를 개체 ID로 삼는것 모든 개체가 같은 컴포넌트를 가지면, 컴포넌트 배열들을 완전히 병렬로 둘 수 있음 인덱스가 모두 같게. 하지만 병렬로 유지하기 어려움 (비활성화 등 정렬 필요) 관련 자료 이 패턴은 컴포넌트 패턴과 관련이 많음 컴포넌트 패턴 == 캐시 사용 최적화를 위해 가장 많이 사용되는 자료구조 중 하나 컴포넌트로 분리하면 큰 덩어리의 개체를 캐시에 적합한 크기로 나눌 수 있음. 토니 알브레히트(Tony Albrecht)의 “Pitfalls of Object-Oriented Programming” 은 캐시 친화성을 위한 게임 데이터 구조 설계에 대해 다룬다. 비슷한 시기에 노엘 로피스(Noel Llopis)도 비슷한 글을 썼다. 번역된 글 데이터 지역성 패턴에서는 거의 언제나 단일 자료형을 하나의 연속된 배열에 나열하는 방식을 활용하고 있다. 객체는 시간이 지남에 따라 배열에 추가, 제거 =&amp;gt; 오브젝트 풀 패턴과 비슷 Artemis 게임엔진은 처음으로 ID만 가지고 게임 개체를 표현한 것으로 알려진 프레임워크이다.출처data-locality" }, { "title": "[게임 프로그래밍 패턴] Decoupling Patterns: Service Locator", "url": "/posts/2022/02/27/02/07/pattern16/", "categories": "pattern", "tags": "", "date": "2022-02-27 02:07:54 +0900", "snippet": "Service Locator 서비스를 구현하는 구체적인 클래스에 사용자를 커플링하지 않고, 어디에서나 서비스에 접근할 수 있게한다.동기 거의 모든 코드에서 사용되는 것들. 메모리 할당, 로그, 난수 생성 일종의 서비스 싱글턴 등의 사용 =&amp;gt; 강한 커플링 ex. 오디오 시스템은 다음과 같이 호출할 수 있어야함. // Use a static class?AudioSystem::playSound(VERY_LOUD_BANG); // Or maybe a singleton? AudioSystem::instance()-&amp;gt;playSound(VERY_LOUD_BANG); 이는 강한 커플링도 생기게 한다. 오디오를 구현한 구체 클래스를 바로 접근할 수 있게 하는건, 우편 물 하나 받겠다고 수많은 이방인에게 집 주소를 알려주는 것과 같음. 개인정보가 너무 노출됨. 주소가 바뀌면 모두에게 바뀐 주소를 알려줘야함. 전화번호부가 있으면, 이름과 주소를 찾을 수 있음. 호출하는 쪽에서 전화번호부를 통해서 찾게 함으로써, 우리를 찾을 방법을 한곳에서 편리하게 관리할 수 있다. 핵심: 서비스를 사용하는 코드로부터 서비스가 누구인지(서비스를 구현한 구체 클래스 자료형이 무엇인지), 어디에 있는지(클래스 인스턴스를 어떻게 얻을지)를 몰라도 되게 해줌.The pattern 서비스(service): 여러 기능을 추상 인터페이스로 정의 구체적인 서비스 제공자(service provider): 인터페이스를 상속받아 구현 서비스 중개자(service locator): 서비스 제공자의 실제 타입과 이를 등록하는 과정은 숨긴채 적절한 서비스 제공자를 찾아 서비스에 대한 접근을 제공.언제 사용? 싱글턴 패턴에서의 문제와 마찬가지로 절제해서 사용하는 게 좋다. 접근해야 할 객체가 있다면 전역 메커니즘 대신, 필요한 객체를 인수로 넘겨줄 수는 없는지부터 생각해야함. 이 방법은 커플링을 명확하게 보여줌 하지만, 넘기는 방식이 불필요하거나, 코드를 읽기 어렵게 하기도 한다. 또한 로그나 메모리 관리 같은 시스템이 모듈의 공개 API에 포함되어 있어선 안 된다. 어떤 시스템은 본질적으로 하나임. 오디오, 디스플레이 등. 이를 깊숙이 들어있는 함수에 전달하는 것은 복잡성만 증가시킴 이 패턴은 더 유연하고 더 설정히기 좋은 싱글턴 패턴이다. 잘만 사용하면, 런타임 비용은 거의 들이지 않고도 코드를 훨씬 유연하게 만들 수 있다 반대로 잘못 사용하면 싱글턴 패턴의 나쁜 점은 전부 있으면서, 실행 성능까지 떨어진다. 주의사항 두 코드가 커플링되는 의존성을 런타임 시점까지 미루는 부분이 어려움. 유연성은 얻을 수 있지만, 코드만 봐서는 어떤 의존성을 사용하는지를 알기 어려움.서비스가 실제로 등록되어 있어야함 싱글턴, 정적 클래스는 항상 인스턴스가 준비되어 있음. 서비스 중개자 패턴에서는 서비스 객체를 등록해야 하기 때문에, 필요한 객체가 없을 때를 대비해야 한다.서비스는 누가 자기를 가져다 놓는지 모른다 서비스 중개자 == 전역에서 접근 가능. 모든 코드에서 서비스를 요청하고 접근할 수 있음. 즉, 서비스는 어느 환경에서나 문제없이 동작해야한다. 서비스는 정확히 정해진 곳에서만 실행되는 걸 보장할 수 없음. 어떤 클래스가 특정 상황에서만 실행되어야 한다면, 전체 코드에 노출되는 이 패턴을 적용하지 않는게 안전함. 예제 코드 이벤트 큐에서 다룬 오디오 시스템 문제로 돌아가보자. 이번에는 서비스 중개자를 통해서 오디오 시스템을 제공하게 할것. The service 오디오 API부터 시작.class Audio{public: virtual ~Audio() {} virtual void playSound(int soundID) = 0; virtual void stopSound(int soundID) = 0; virtual void stopAllSounds() = 0;}; 위와 같이 간단히 인터페이스를 구현할 수 있다.The service provider 인터페이스를 구체적인 클래스를 구현해야한다.class ConsoleAudio : public Audio{public: virtual void playSound(int soundID) { // Play sound using console audio api... } virtual void stopSound(int soundID) { // Stop sound using console audio api... } virtual void stopAllSounds() { // Stop all sounds using console audio api... }};A simple locator 의존성 주입: Locator 클래스는 Audio 서비스의 인스턴스가 필요하다. 보통은 중개자가 서비스 인스턴스를 직접 생성해준다. 이를 의존성 주입에서는 특정 객체가 필요로 하는 의존 객체를 외부 코드에서 주입해준다고 한다.class Locator{public: static Audio* getAudio() { return service_; } static void provide(Audio* service) { service_ = service; }private: static Audio* service_;}; 정적인 함수 getAudio()가 중개 역할을 한다.Audio *audio = Locator::getAudio();audio-&amp;gt;playSound(VERY_LOUD_BANG); Locator가 오디오 서비스를 ‘등록하는’ 방법은 굉장히 단순하다. 게임이 시작될 때 외부 코드에서 등록 ConsoleAudio *audio = new ConsoleAudio();Locator::provide(audio); playSound()를 호출하는 쪽에서는 Audio라는 추상 인터페이스만 알 뿐 구체 클래스에 대해서는 전혀 모름. 구현된 클래스가 실제로 사용되는지는 서비스를 제공하는 초기화 코드에서만 알 수 있다. 또한 Audio 인터페이스도 자기가 서비스 중개자를 통해서 여기저기로부터 접근된다는 사실을 모른다. 꼭 서비스 중개자 패턴용으로 만들지 않은 기존 클래스에도 이 패턴을 적용할 수 있다. 싱글턴과 정반대(‘서비스’를 제공하는 클래스의 형태 자체에 영향을 미침) 널 서비스 위 예제의 단점 서비스 등록 전 서비스 사용 시도 =&amp;gt; NULL 반환 호출하는 쪽에서 NULL을 검사하지 않으면 크래시 일어남. 시간적 결합(temporal coupling): 두 가지 다른 코드를 정해진 순서대로 실행해야만 제대로 동작하는것. 제거하는것이 유지보수하기 좋다. 널 객체 패턴을 사용할 수 있음 NULL 반환 대신 인터페이스를 구현한 특수한 객체를 반환 class NullAudio: public Audio{public: virtual void playSound(int soundID) { /* Do nothing. */ } virtual void stopSound(int soundID) { /* Do nothing. */ } virtual void stopAllSounds() { /* Do nothing. */ }}; NullAudio는 Audio 서비스 인터페이스를 상속받지만 아무 기능도 하지 않는다. Locator 클래스를 다음과 같다. class Locator{public: static void initialize() { service_ = &amp;amp;nullService_; } static Audio&amp;amp; getAudio() { return *service_; } static void provide(Audio* service) { if (service == NULL) { // Revert to null service. service_ = &amp;amp;nullService_; } else { service_ = service; } }private: static Audio* service_; static NullAudio nullService_;}; getAudio()가 서비스를 포인터가 아닌 레퍼런스로 반환하게 바뀜 C++에서 레퍼런스는 절대 NULL이 될 수 없음, 레퍼런스를 반환한다는 것은 코드를 사용하는 쪽에서 항상 객체를 받을 수 있다고 기대해도 된다는것. 초기화 함수를 먼저 호출해야함, NULL 검사 분기문을 provide에 둘 수 있어서 서비스에 접근할 때마다 생길 수 있는 CPU 낭비를 조금 줄일 수 있다. 호출하는 쪽에서 진짜 서비스가 준비되어 있는지를 신경 쓰지 않아도 되고 NULL 반환 처리도 필요 없다. Locator는 항상 유효한 객체를 반환한다는 점을 보장한다. 널 서비스는 의도적으로 특정 서비스를 못 찾게 하고 싶을 때에도 유용하다. 개발하는 동안 오디오 기능을 끌 수 있음.로그 데커레이터 서비스 중개자 패턴을 활용한 ‘데커레이션으로 감싼 서비스(decorated service)’ 로그를 남겨 무슨 일이 벌어지는지 확인하고 싶은 경우. log()함수를 코드 여기저기 집어넣어야한다. 이러다 로그가 너무 많아지는 문제가 발생한다. 원하는 로그만 볼 수 있게해야하고, 최종 빌드에는 로그를 전부 제거하는 것이 이상적이다. 조건적으로 로그를 남기고 싶은 시스템이 서비스로 노출되어 있다면 GoF의 데커레이터 패턴(장식자 패턴)으로 해결할 수 있다. class LoggedAudio : public Audio{public: LoggedAudio(Audio &amp;amp;wrapped) : wrapped_(wrapped) {} virtual void playSound(int soundID) { log(&quot;play sound&quot;); wrapped_.playSound(soundID); } virtual void stopSound(int soundID) { log(&quot;stop sound&quot;); wrapped_.stopSound(soundID); } virtual void stopAllSounds() { log(&quot;stop all sounds&quot;); wrapped_.stopAllSounds(); }private: void log(const char* message) { // Code to log message... } Audio &amp;amp;wrapped_;}; LoggedAudio 클래스는 다른 오디오 서비스 제공자를 래핑하는 동시에 같은 인테페이스를 상속받는다. 로그를 남기면서, 실제 기능 요청은 참조하는 서비스에 전달한다. 다음과같이 로그 기능을 킬 수 있다.void enableAudioLogging(){ // Decorate the existing service. Audio *service = new LoggedAudio(Locator::getAudio()); // Swap it in. Locator::provide(service);} 사운드를 비활성화 해서 로그만을 보고 확인할 수 있다.디자인 결정 핵심적인 질문들을 고려해 다양하게 달라질 수 있다.서비스는 어떻게 등록되는가?외부 코드에서 등록 예제가 이에 해당. 가장 일반적인 방법 빠르고 간단: getAudio()는 단순히 반환만, 이는 컴파일러에서 인라인으로 성능 손해 없이 깔끔한 추상 계층을 둘 수 있다. 서비스 제공자를 어떻게 만들지 제어할 수 있다: 온라인용, 로컬용 입력 온라인용: 네트워크를 통해 반대편에 전달 가능, 다른 코드는 구별못함, Locator는 IP 주소 같은 것을 알아야함. Locator는 다른 유저 IP 주소는 커녕 원격인지도 모름, 어떤 값을 서비스 제공자에게 전달해야하는지 모름 외부에서 제공: 게임 네트워크 코드에서 온라인용 서비스 제공자 객체를 IP주소와 함께 생성한 뒤에 서비스 중개자에 전달하면 됨. 이러면 서비스 중개자도 문제없이 온라인 플레이 서비스를 중개할 수 있다. 게임 실행 도중에 서비스를 교체할 수 있다 개발중 서비스를 끄는 등 활용 서비스 중개자가 외부 코드에 의존한다는 단점이 있다 초기화가 제대로 안된 상태 == 크래시 위험 컴파일할 때 바인딩 전처리기 매크로를 이용해 컴파일할 대 등록class Locator{public: static Audio&amp;amp; getAudio() { return service_; }private: #if DEBUG static DebugAudio service_; #else static ReleaseAudio service_; #endif}; 빠르다 모든 작업이 컴파일할 때 긑나기 때문에 런타임에 따로 할 일이 없다. 컴파일러가 getAudio()를 인라인으로 바꾼다면 속도 측면에서도 좋음 서비스는 항상 사용가능: 선택된 서비스를 소유, 컴파일 후면 서비스 준비 완료 서비스를 쉽게 변경 불가능 재컴파일해야함. 런타임에 설정 값 읽기 기업용 소프트웨어 분야 쪽에서 보통 사용하는 방식 중개자는 요청받은 실제 구현을 런타임에 찾아냄. 일부 프로그래밍 언어에서는 리플렉션을 이용해 런타임에 타입 시스템과 상호작용할 수있다, 이름만으로 클래스를 찾은 뒤에 생성자를 호출해 인스턴스를 생성할 수 있다.(리스프, 파이썬 같은 동적 타이핑 언어, C#, 자바) 보통 설정 파일을 로딩한 뒤, 리플렉션으로 원하는 서비스 제공자 클래스 객체를 런타임에 생성. 다시 컴파일하지 않고도 서비스를 교체할 수 있다 유연하지만, 바꾼 설정 값을 적용하려면 게임 재시작해야함. 실행 도중에 서비스를 교체할 수 있는 방식보다는 덜 유연 프로그래머가 아니어도 서비스를 변경할 수 있다 등록 과정을 코드에서 완전히 빼냈기 때문에 하나의 코드로 여러 설정을 동시에 지원할 수 있다 설정만 건드리면, 여러 다른 서버 환경에서 사용 가능. 복잡하다 파일 로딩=&amp;gt;파싱, 서비스를 동록하는 설정 시스템을 만들어야함. 다른 방식보다 상당히 무거움 서비스 등록에서 시간이 걸린다는 단점 런타임에 설정 값을 사용하려면, 서비스를 등록하기 위해 CPU 사이클을 낭비해야한다. 캐시하면 이런 낭비를 최소화할 수 있을지 몰라도, 처음에는 시간 약간 소모됨 게임분야에서 게임 경험 향상과 상관없는 곳에서 CPU 사이클을 낭비하는 것은 지양됨 서비스를 못 찾으면 어떻게 할 것인가?사용자가 알아서 처리하게 한다 실패했을 경우 어떻게 처리할지를 사용자가 정할 수 있음 서비스 사용자 쪽에서 실패를 처리해야함 호출하는 쪽에서 거의 같은 방식으로 오류를 처리하다 보면 굉장히 많은 중복 코드가 코드베이스에 퍼짐. 검사를 하나라도 제대로 하지 않으면 크래시가 생길 수 있음 게임을 멈춘다 단언문을 추가한다.class Locator{public: static Audio&amp;amp; getAudio() { Audio* service = NULL; // Code here to locate service... assert(service != NULL); return *service; }}; assert()는 서비스를 찾지 못하는 문제를 해결하지 못함. 누구에게 문제가 있는지를 분명하게 보여줌. 중개자에서 버그가 난 것을 분명히 알 수 있음. 사용자 측에서는 서비스가 없는 경우를 처리하지 않아도 된다. 하나의 서비스가 수많은 곳에서 사용될 수 있기 때문에, 코드를 굉장히 줄일 수 있다. 서비스를 찾지 못하면 게임이 중단됨 고치기 전까지 다른 팀원들이 아무것도 할 수없다. 규모가 큰 개발팀에선 다른 프로그래머들이 기다려야함 널 서비스를 반환한다 외부 코드에서는 서비스가 없는 경우를 처리하지 않아도 된다. 서비스를 찾지 못하면 게임이 중단된다. 장점이자 단점 준비되어 있지 않아도 게임을계속 진행할 수 있다는 점은 장점. 미구현된 다른 시스템에 의존할 때 특히 유리 의도치 않게 서비스를 찾지 못할 때에도 디버깅하기가 쉽지 않다는 점. 결론 단언문을 거는 형태가 제일 많이 사용됨. 서비스를 찾지 못할 가능성은 굉장히 작다. 규모가 큰 팀이면 널 서비스 추천 구현 쉬움, 서비스를 사용하지 못하는 동안 멈추지 않고 계속 개발 가능 서비스에 버그가 있더라도 다른 작업을 하는 동안 서비스가 귀찮게 굴면 쉽게 끌 수 있다. 서비스의 범위는 어떻게 잡을 것인가? 다음과 같이 특정 클래스 및 그 클래스의 하위 클래스에만 접근을 제한할 수있다.class Base{ // Code to locate service and set service_...protected: // Derived classes can use service static Audio&amp;amp; getAudio() { return *service_; }private: static Audio* service_;};전역에서 접근 가능한 경우 전체 코드에서 같은 서비스를 쓰도록한다 보통 이런 서비스(오디오같은)는 단 하나만 존재하는게 맞다. 모든 코드에서 같은 서비스에 접근하게 하고, 제공자에 접근 제한하여 생성하지 못하도록 할 수 있다. 언제 어디에서 서비스가 사용되는지를 제어할 수 없다 전역으로 만들면서 생기는 비용 접근이 특정 클래스에 제한되면 커플링 제어 가능: 특정 클래스를 상속받는 클래스들에게만 제한 =&amp;gt; 디커플링 유지 중복 작업을 해야할 가능성: 둘 이상의 서로 상관없는 클래스에서 같은 서비스에 접근해야한다면 각자 그 서비스를 참조해야 한다. 서비스를 찾거나 등록하는 작업을 이들 클래스에 대해 중복으로 해줘야 한다. 결론 게임 분야에서는 하나의 클래스로 접근 범위를 좁히는것이 저자가 선호하는 것. 네트워크 접근하기 위한 서비스 =&amp;gt; 온라인 클래스에서만 사용하게 로그같은 다양한 곳에서 사용하는 서비스 =&amp;gt; 전역에 둔다. 관련 자료 서비스 중개자 패턴: 싱글턴 패턴과 비슷 유니티 프레임워크에서 GetComponent()에서 컴포넌트 패턴과 함께 서비스 중개자 패턴을 사용한다. 마이크로소프트의 XNA 프레임워크의 핵심 클래스의 Game에 서비스 중개자 패턴이 포함되어있다. Game.Services 속성 =&amp;gt; 어떤 종류의 서비스라도 등록 가능 출처service-locator" }, { "title": "[게임 프로그래밍 패턴] Decoupling Patterns: Event Queue", "url": "/posts/2022/02/26/19/16/pattern15/", "categories": "pattern", "tags": "", "date": "2022-02-26 19:16:29 +0900", "snippet": "Event Queue 메시자나 이벤트를 보내는 시점과 처리하는 시점을 디커플링한다.동기 메시지 큐, 이벤트 루프, 메시지 펌프 등등..GUI 이벤트 루프 UI 프로그래밍 버튼 클릭, 메뉴 선택, 키보드 입력 등등.. 상호작용 =&amp;gt; 운영체제는 이벤트를 만들어 프로그램으로 전달. 프로그램 =&amp;gt; 이벤트 핸들러 코드에 전달 이벤트 주도 프로그래밍(event-driven programming) 이벤트받기 위해서는 이벤트 루프가 있어야함 while (running){ Event event = getNextEvent(); // Handle event...} 프로그램이 원할 때 이벤트를 가져온다. 즉, OS가 디바이스 드라이버로부터 입력값을 받은 후, 그 값을 어딘가에 저장해 둔다는 뜻. 그 장소는 큐(queue) 사용자 입력 =&amp;gt; OS는 아직 처리 안된 이벤트 큐에 추가한다. 중앙 이벤트 버스 이벤트 주도 방식으로 구현된 게임은 거의 없음(게임 루프 사용) 게임에서 자체 이벤트 큐를 만들어 통신 시스템으로 활용하는 경우는 흔함. “central”, “global”, or “main” 같은 형용사가 흔히 붙음. 게임 시스템들이 디커플링 상태를 유지한 채, 서로 고수준 통신을 하고 싶을 경우 이를 사용한다. 예시)특정 인-게임 이벤트가 발생할 때, 말풍선을 보여주는 튜토리얼 시스템 ‘적이 죽었음’이라는 이벤트를 받으면, 알려달라고 큐에 자기 자신을 등록한다. 전투, 튜토리얼 시스템이 서로 몰라도, 사실을 전달 가능. 이벤트 큐가 언제나 게임 전체 통신 시스템으로만 사용되어야하는 건 아님. - 클래스 하나, 분야(domain) 하나에서도 유용함. 개체가 정보를 보내고 통지를 받을 수 있는 공용공간 == AI 분야의 흑판(blackboard) 시스템과 비슷하다. Say What?(문제있는 단순한 사운드 시스템) 사운드 시스템을 추가하기 위해 아이디와 볼륨을 받아 사운드를 출력하는 API를 제공하는 오디오 엔진 부터 만들어 보자 시스템 하드웨어에 보통 오디오 출력은 하나이므로, 싱글턴 패턴이 유용할 수 있다. class Audio{public: static void playSound(SoundId id, int volume);}; 오디오 엔진 적당한 사운드 리소스 로딩, 출력할 수 있는 채널을 찾아 틀어줌. playSound는 다음과 같다. void Audio::playSound(SoundId id, int volume){ ResourceId resource = loadSound(id); int channel = findOpenChannel(); if (channel == -1) return; startSound(resource, channel, volume);} 위 코드를 소스 관리 툴에 체크인하고 사운드 파일을 만들고 나면 코드 아무곳에서 playSound을 호출할 수 있다. 아래는 UI코드에서 선택한 메뉴가 바뀔 때 소리를 내는 코드이다. class Menu{public: void onSelect(int index) { Audio::playSound(SOUND_BLOOP, VOL_MAX); // Other stuff... }}; 이 상태에서 메뉴를 옮겨다니다 보면, 화면이 멈출 가능성이 있다. **문제1:** API는 오디오 엔진이 요청을 완전히 처리할 때까지 호출자를 블록(block)한다. 동기적(ssynchronous)인 함수로, 소리가 나기 전까지 API는 블록됨. 공격을 하면, 몹 두마리가 한 프레임에 같이 맞을 수 있음. 같은 소리 파형 두 개를 동시에 출력하면 하나의 소리를 두 배 크기로 출력하는것과 같아 좋지 않음. 전체 사운드 호출을 취합하고, 우선순위에 따라 나열해서 해결 가능 하지만 playsound는 하나씩 처리하기 때문에 사운드 요청을 한 번에 하나밖에 볼 수 없다. **문제2:** 요청을 모아서 처리할 수 없다. 여러 다른 시스템이 playsound를 마음대로 호출 멀티코어 하드웨어에서 실행된다면 게임 시스템들을 별도의 스레드로 나눠야한다. playsound API가 동기식이기 때문에 코드는 호출한 스레드에서 실행된다. playsound는 여러 스레드에서 동시에 실행됨 동기화 처리가 없으므로 문제 오디오용 스레드를 별도로 만들면 문제가 더 심각해짐. **문제3:** 요청이 원치 않는 스레드에서 처리된다. 모든 문제의 원인: 오디오 엔진이 playsound 호출을 ‘하던 일을 멈추고 사운드 재생’이라고 해석 즉시성문제 오디오 엔진이 요청을 받을 때 이를 처리하기에 항상 적당한 것은 아님 해결: 요청을 받는 부분과 요청을 처리하는 부분을 분리해야함. The pattern 큐: 요청이나 알림을 받는 순서대로 저장. 알림을 보내는 곳: 요청을 큐에 넣은 뒤 결과를 기다리지 않고 리턴. 요청을 처리하는 곳: 큐에 들어 있는 요청을 나중에 처리한다. 요청: 그곳에서 직접 처리 or 다른 여러 곳으로 보내질 수 있다. 이렇게 요청을 보내는 쪽과 받는 쪽을 코드뿐만이 아니라 시간 측면에서도 디커플링한다.언제 사용할 것인가? 메시지를 보내는 곳과 받는 곳을 분리하고 싶을 뿐이라면 옵저버 패턴이나 명령 패턴같은 걸로 덜 복잡하게 이를 처리할 수 있다. 메시지를 보내는 시점과 받는 시점을 분리하고 싶은 경우에 큐가 필요하다. pushing, pulling 일을 요청: 밀어 넣기 일을 받기: 가져와서 처리 둘 사이에 버퍼가 필요 큐만 제공할 수 있는 기능 큐는 요청을 받는 쪽에 제어권을 제공한다. 받는 쪽: 처리 지연가능, 모아서 처리 또는 버릴 수 있음. 보내는쪽: 요청을 큐에 넣은 뒤, 잘 처리하기를 바라는 것밖에 없음. 보내는 쪽에서 처리 응답을 받아야 한다면 큐를 쓰는 게 적합하지 않다.주의 사항 이벤트 큐는 복잡하고 게임 구조에 전반적으로 영향을 미침. 잘 생각해야함. 중앙 이벤트 큐는 전역변수와 같다 이벤트 큐는 모든 게임 시스템에서 서로 메시지를 주고받는 복잡한 중앙역에 많이 사용됨. 전역변수 == 좋지 못함 상호 의존성이 생김. 관리 문제 발생 월드 상태는 언제든 바뀔 수 있다 다양한 월드 상태를 알아야함. 어떤 상황에서 어떤 객체가 죽었는지 등에 관한 정보 바로바로 이벤트가 처리되지 않으면 정보가 사라질 수 있음. 현재 월드 상태가 이벤트가 만들어진 당시 상태와 다를 수 있음. 큐에 들어가는 이벤트에 데이터가 훨씬 더 많이 필요. 동기 이벤트: 알림 받는 쪽이 바로 상황 확인 가능피드백 루프에 빠질 수 있다 모든 이벤트, 메시지 시스템은 순환이 생기지 않도록 주의해야함, A에게 이벤트를 보냄 B가 이벤트를 받아 응답으로 다른 이벤트를 보냄 이 이벤트가 우연하게 A에서 처리해야하는 작업이라 A가 이벤트 보냄 2-3 반복 동기적이면, 스택 오버플로가 나기 때문에 순환을 금방 찾을 수 있다. 비동기적 =&amp;gt; 콜스택이 풀려 계속 이벤트를 서로 주고 받을 수 있다. 이 문제를 피하는 일반적인 규칙: 이벤트를 처리하는 코드 내에서는 이벤트를 보내지 않는것. 이벤트 시스템에 간단한 디버깅용 로거를 집어넣는것도 괜찮다. 예제 코드 위에서 다룬 사운드 엔진의 playSound()의 문제점을 해결하려고함. 문제1: API가 블록된다. playsound가 바로 리턴하게, 기본 배열 사용하여 메시지 저장 =&amp;gt; 큐가 필요 playsound가 바로 리턴하게 만들려면 사운드 출력 작업을지연 시켜야한다. 나중에 사운드를 출력할 때 필요한 정보를 저장할 수있도록 간단히 구조체부터 정의해야한다. struct PlayMessage{ SoundId id; int volume;}; 보류된 메시지를 저장할 수 있도록 저장 공간을만들어야한다. 피보나치 힙, 스킵 리스트, 링크드리스트 등 실무에서 동일한 데이터들을 저장하는 가장 좋은 방법은 그냥 배열을 쓰는것이다. 기본 배열의 장점 동적할당이 필요없음. 메모리에 추가 정보나 포인터저장하지 않아도됨. 메모리가 이어져있어 캐시하기 좋음.(데이터 지역성 패턴 참고) 코드는 다음과 같다. class Audio{public: static void init() { numPending_ = 0; } // Other stuff...private: static const int MAX_PENDING = 16; static PlayMessage pending_[MAX_PENDING]; static int numPending_;}; 배열의 크기는 최악의 경우에 맞추어 조정한다. 메시지는 배열 제일 맨 뒤에 넣는다. void Audio::playSound(SoundId id, int volume){ assert(numPending_ &amp;lt; MAX_PENDING); pending_[numPending_].id = id; pending_[numPending_].volume = volume; numPending_++;} 사운드 출력은 update 메서드에 놓는다.(업데이트 메서드 패턴) class Audio{public: static void update() { for (int i = 0; i &amp;lt; numPending_; i++) { ResourceId resource = loadSound(pending_[i].id); int channel = findOpenChannel(); if (channel == -1) return; startSound(resource, channel, pending_[i].volume); } numPending_ = 0; } // Other stuff...}; 이제 update를 적절한 곳에서 호출하면 된다. 메인 게임 루프 or 별도의 오디오 스레드 update() 한 번 호출로 모든 사운드 요청을 다 처리할 수 있다고 가정하고 있음. 사운드 리소스가 로딩된 다음에 비동기적으로 요청을 처리해야한다면 이렇게 안됨. update()에서 한 번에 하나의 요청만 처리하게 하려면 버퍼에서 요청을 하나씩 꺼낼 수 있어야함. - 큐가 필요 원형 버퍼 큐를 구현하는 방법중 하나. 큐 앞에서부터 순차적으로 데이터를 가져올 수 있다. 머리(head): 큐에서 요청을 읽을 위치.(가장 먼저 보류된 요청) 꼬리(tail): 배열에서 새로운 요청이 들어갈 자리. (마지각 요청의 다음을 가리킴, 반 열린구간) playSound()는 배열 맨 뒤에 요청을 추가한다. 코드는 다음과 같다. class Audio{public: static void init() { head_ = 0; tail_ = 0; } // Methods...private: static int head_; static int tail_; // Array...}; numPending* 이 tail*로 바뀌었다. void Audio::playSound(SoundId id, int volume){ assert(tail_ &amp;lt; MAX_PENDING); // Add to the end of the list. pending_[tail_].id = id; pending_[tail_].volume = volume; tail_++;} update()는 다음과 같이 바뀌었다. void Audio::update(){ // If there are no pending requests, do nothing. if (head_ == tail_) return; ResourceId resource = loadSound(pending_[head_].id); int channel = findOpenChannel(); if (channel == -1) return; startSound(resource, channel, pending_[head_].volume); head_++;} 이제 버퍼를 원형 버퍼로 만들어보자 머리 앞부분의 빈 공간을 사용하게끔, 꼬리를 다시 배열 앞으로 보내면 된다. playsound에서의 구현은 다음과 같다. void Audio::playSound(SoundId id, int volume){ assert((tail_ + 1) % MAX_PENDING != head_); // Add to the end of the list. pending_[tail_].id = id; pending_[tail_].volume = volume; tail_ = (tail_ + 1) % MAX_PENDING;} update는 다음과 같이 수정한다. void Audio::update(){ // If there are no pending requests, do nothing. if (head_ == tail_) return; ResourceId resource = loadSound(pending_[head_].id); int channel = findOpenChannel(); if (channel == -1) return; startSound(resource, channel, pending_[head_].volume); head_ = (head_ + 1) % MAX_PENDING;} 동적 할당도 필요 없고, 데이터를 옮길 필요도 없고 단순 배열만큼이나 캐시하기 좋은 큐가 완성되었다. 큐의 최대용량 MAX_PENDING이 신경쓰인다면, 늘어나는 배열을 사용하면 된다. 배열이 늘어날 때 데이터를 복사해야하지만, 그 외에 삽입등 작업은 평균적으로 상수시간 안에 가능하다. 사운드 겹치는 문제 =&amp;gt; 요청 취합하기 첫 번째 문제는 같은 소리를 동시에 틀면 소리가 너무 커지는 현상이 일어난다는 것이다. 대기 중인 요청을 확인하여 같은 요청은 병합하는것 void Audio::playSound(SoundId id, int volume){ // Walk the pending requests. for (int i = head_; i != tail_; i = (i + 1) % MAX_PENDING) { if (pending_[i].id == id) { // Use the larger of the two volumes. pending_[i].volume = max(volume, pending_[i].volume); // Don&#39;t need to enqueue. return; } } // Previous code...} 보류 중인 요청을 조회하여 둘 중 소리가 큰 값 하나로 합치는것. 배치(batch) 작업도 같은 방식이다. 요청을 처리할 때가 아니라 큐에 넣기 전에 일어나는 일. 호출하는 쪽의 처리 부담이 늘어난다는 단점이 생김. 큐가 큰 경우 update()에서 요청을 취합하는게 더 나을 수 있음. 아니면 해시 테이블 같은 걸 사용하면 상수 시간에 중복여부 확인 가능하다. 주의 : 취합 가능한 최대 동시 요청 수는 큐의 크기와 같다. 요청을 너무 빨리 처리하면, 요청을 합칠 가능성이 줄어든다. 요청 처리가 늦어져 큐가 거의 차있으면 합칠만한 요청을 찾을 가능성이 더 높다. 이벤트 큐 패턴은 요청자가 실제로 요청이 언제 처리되는지를 모르게 막는다. 이벤트를 없애므로 큐가 이렇게 상황에 따라 다르게 반응한다면, 큐에 넣은 요청이 실제로 처리될 때까지 걸리는 시간이 동작에 영향을 미칠 수 있다. 멀티 스레드 동기식으로 만든 오디오 API에서는 playsound를 호출한 스레드에서 요청도 같이 처리해야 했음. 멀티코어 하드웨어의 성능을 최대한 끌어내야함. 분야별로 할당하는 전략을 많이 사용한다. 앞에서 멀티코어를 적용하기 위한 세 가지 주요 조건을 준비했음 사운드 요청 코드와 사운드 재생 코드 분리 양쪽 코드 사이에 마샬링(marshalling)을 제공하기 위한 큐 큐는 나머지 코드로 부터 캡슐화됨 이제 playsound, update를 스레드 안전하게 만들기만 하면된다. 큐가 동시에 수정되는 것만 막으면 된다. update()에서는 조건 변수 같은 것으로 기다리게 만들면 처리할 요청이 없는 동안 CPU 낭비를 막을 수 있다. playSound는 작업이 많지 않아, 블록해도 오래걸리지 않음 서버 프로그래머들은 애플리케이션을 여러 프로세스로 나눠서 이를 보완한다. 이러면 OS에서 프로세스들을 별도 코어에서 병렬적으로 실행시켜준다. 게임 클라이언트는 대부분 프로세스를 하나만 사용하므로, 멀티스레딩을 적용하면 많은 도움을 얻을 수 있다. 디자인 결정 간단한 것부터 만들어보는게 좋다.큐에 무엇을 넣을것인가? 이벤트 와 메시지큐에 이벤트를 넣는 경우 이벤트 혹은 통지(notification): 이미 발생한 사건을 표현한다. “몬스터가 죽었음” 큐에 이벤트를 넣으면, 다른 객체가 비동기 옵저버 패턴 같은 방식으로 이벤트에 대해 반응 가능 복수 개의 리스너를 지원해야 할 때도 많다.: 큐에는 이미 발생한 일이 들어 있기 때문, 보내는 쪽에서는 누가 그걸 받는지 신경 쓰지 않는다. 큐의 범위가 더 넓은 편이다.: 이벤트 큐는 이벤트를 원하는 누구에게든지 전파하는 용도로 사용된다. 리스너가 최대한 유연할 수 있도록, 큐를 더 전역적으로 노출해야 할 수 있다.큐에 메시지를 넣는 경우 메시지 또는 요청: 나중에 실행했으면 하는 행동을 표현 “사운드 틀기” 서비스에 비동기적으로 API를 호출하는 것과 비슷. 요청은 명령 패턴에서의 명령과 같음. 대부분 리스너가 하나다. 누가 큐를 읽는가? 예제: 큐가 캡슐솨, Audio 클래스에서만 읽을 수 있었음. UI의 이벤트 시스템 같은 곳에서 원하는 대로 리스너를 등록할 수 있다. 싱글캐스트나 브로드캐스트 같은 용어를 사용한다. 싱글캐스트 큐 큐가 어떤 클래스의 API 일부일 때 적합. 호출하는 쪽에서는 playSound 메서드만 보일 뿐. 큐는 밖에서는 보이지 않는 내부 구현이 된다.: 보내는 쪽에서는 메시지를 보냈다는 것만 안다. 큐가 더 캡슐화되어 있다.: 캡슐화 되어 있을수록 좋다. 리스너 간에 경쟁을 고민하지 않아도 된다.: 리스너가 여러 개라면 모든 리스너에 이벤트를 보낼지, 하나의 리스너에 이벤트를 하나씩 나눠줄지(작업큐) 정해야한다. 리스너들은 중복 작업을 하거나 서로 간섭함 =&amp;gt; 리스너가 하나면 복잡성이 사라짐 브로드캐스트 큐 대부분의 ‘이벤트’ 시스템 리스너가 10개일 경우 이벤트가 하나 들어왔을 때 10개의 리스너 모두가 그 이벤트를 볼 수 있다. 이벤트가 무시될 수 있다.: 리스너가 하나도 없다면, 이벤트는 그대로 벌진다. 이벤트 필터링이 필요: 이벤트 개수 x 리스너 개수만큼 이벤트 핸들러가 자주 호출된다. 이벤트 핸들러 호출 횟수를 최소화 =&amp;gt; 리스너가 받고 싶은 이벤트 집합을 조절할 수 있게 작업 큐 작업 큐에도 리스너가 여러 개 있다. 큐에 들어 있는 데이터가 리스너 중 한곳에만 간다. 스레드 여러 개가 동시에 실행 중인 스레드 풀에 작업을 나눠줘야 할 때 일반적으로 사용하는 패턴이다. 작업을 분배해야 한다.: 큐에 들어 있는 데이터가 하나의 리스너에만 가기 때문에 큐는 어느 리스너에 보내면 좋을지 알아야 한다. 라운드 로빈이나 좀 더 복잡한 우선순위 시스템을 적용해도 된다. 누가 큐에 값을 넣는가? 이벤트 큐 패턴: 일대일, 일대다, 다대일, 다대다 등 모든 읽기/쓰기 조합으로 사용할 수 있다.넣는 측이 하나 동기형 옵저버 패턴에 가까운 형태. 특정 객체에서만 이벤트 만들기 가능, 나머지는 받을 수만 있음. 어디에서 이벤트가 오는지 암시적으로 안다 리스너가 여러 개넣는 측이 여러개 위의 오디오 엔진이 이런 예 public 함수로 어디에서나 큐에 요청 가능, 전역 or 중앙 이벤트 버스도 이와 같이 작동 이벤트 순환을 주의해야 함. 이벤트 처리 도중에 큐를 넣으면 피드백 루프 문제 발생 가능 이벤트를 보낸 객체에 대한 레퍼런스를 이벤트에 추가해야 할 필요가 있을 수 있다. 리스너에서 보낸 쪽의 정보가 필요하다면, 정보를 같이 넣어줘야함, 큐에 들어간 객체의 생명주기는 어떻게 관리할 것인가? 동기형일 경우, 보내는 쪽은 기다려야함. 메시지 == 스택에 들어가는 지역 변수이기만 해도 충분. 큐에다 메시지를 추가하는 함수 호출이 끝난 후에도 메시지 객체가 유지되어야함. GC지원 언어의 경우 큐에 들어 있는 데이터는 필요한 만큼 메모리에 유지됨. 소유권 전달 받는 쪽에서 소유권을 가져가고 메시지 해제도 해야함. unique_ptr&amp;lt;T&amp;gt; 소유권을 공유 메시지를 참조하는 곳이 어디 하나라도 있다면 계속 메모리에 남아 있음. 참조하지 않으면 알아서 해제 shared_ptr&amp;lt;T&amp;gt; 큐가 소유권을 가진다 메시지 큐가 생명을 관리 - 큐에서 새로운 메시지를 하나 달라고 요청 - 큐는 미리 할당해놓은 메시지의 레퍼런스를 반환하고 보내는 쪽에서는 여기에 값을 채움. - 처리가 끝나면, 받는 쪽에서 이 메시지 참조 오브젝트 풀이 큐의 보조 기억장치가 되는것. 관련 자료 이벤트 큐 == 옵저버 패턴의 비동기형 여러 이름으로 불림. 이벤트 큐 == 애플리케이션 내부 메시지 큐 == 여러 애플리케이션 끼리 통신 발행자/구독자(publish/subcribe, pubsub): 대규모 분산처리 시스템 GOF의 상태 패턴과 유사한 FSM에서는 입력값을 stream으로 받음. FSM 입력에 비동기적으로 응답하게 하고 싶다면 입력에 큐를 넣어야함. 서로 통신을 주고받는 여러 상태 기계가 있고, 각자 입력을 보류하기 위해 소형 큐(mailbox)를 사용한다면, 계산 액터 모델(actor model)을 만든것과 같다. GO에서는 이벤트 큐나 메시지 큐로 사용하는 channel이라는 자료형을 언어 차원에서 지원한다.출처event-queue" }, { "title": "[게임 프로그래밍 패턴] Decoupling Patterns: Component", "url": "/posts/2022/02/26/03/19/pattern14/", "categories": "pattern", "tags": "", "date": "2022-02-26 03:19:35 +0900", "snippet": "Decoupling Patterns 어려운것: 요구사항 변경을 대비해 코드 고치기 쉽게 만드는 일 디커플링이 많은 도움을 줌. 컴포넌트 패턴: 한 개체에 들어 있는 코드들을 기능별로 서로 디커플링 이벤트 큐 패턴: 서로 통신을 주고받는 두 객체를 코드뿐만 아니라 시간 측면에서도 디커플링한다. 서비스 중개자 패턴: 코드가 실제로 그 기능을 제공하는 코드와 결합하지 않고도 특정 기능에 접근할 수 있게Component 한 개체가 여러 분야를 서로 커플링 없이 다룰 수 있게동기 플랫포머를 만든다고 가정. 입력, 행동, 물리, 충돌, 애니메이션, 렌더링, 사운드 등… 여러 분야의 코드를 작성해야함. 이때 분야가 다른 코드끼리는 최대한 서로 모르는게 좋음. 클래스가 크다 == 기능보다 버그가 더 빨리 늘어남문제: 고르디우스의 매듭 더 큰 문제는 커플링이다. 알아야할 코드량이 많아짐 아래 코드를 손보려면 물리, 그래픽, 사운드 전부 알아야함. 멀티스레드 환경에서 더 심각, 보통 분야별로 스레드 분배한다. 분야별로 스레드를 나누면, 분야별로 디커플링해야 교착상태 같은 골치 아픈 동시성 버그를 피할 수 있다. 서로 다른 스레드에서 실행되어야 하는 메서드를 한 클래스 안에 모아두는 것은 동시성 버그를 조장하는 짓이다. if (collidingWithFloor() &amp;amp;&amp;amp; (getRenderState() != INVISIBLE)){ playSound(HIT_FLOOR);} 커플링 + 코드 길이 =&amp;gt; 서로 악영향해결방법: 매듭 끊기 클래스 코드 크기문제: 클래스를 여러 작은 클래스 한 덩어리를 분야에 따라 나누면 됨 해당하는 분야의 여러 인스턴스를 소유하는 하나의 클래스로 만드는것. 열린구조 컴포넌트 클래스들은 디커플링되어 있다. 여러 사람이 작업하기 편함 컴포넌트끼리 상호작용 필요할 수도 있다. 모든 코드를 한곳에 섞어놓지 않았기 때문에 서로 통신이 필요한 컴포넌트만으로 결합을 재현할 수 있다. 다시 합치기 이런 컴포넌트는 재사용가능하다. 요즘 소프트웨어 설계: 상속 대신 조합(composition)이 대세,두 클래스에서 같은 코드를 공유하고 싶다면, 상속이 아닌 같은 클래스의 인스턴스를 가지게 한다. 플랫포머에서 주인공 외에 다른 객체들을 생각해보자 데커레이션(decorations): 덤불, 먼지 같이 볼 수 있으나 상호작용 불가능한 객체 프랍(props): 상자, 바위, 나무같이 볼 수 있으면서 상호작용도 할 수 있는 객체 존(zone): 데커레이션과 반대, 보이지 않지만 상호작용 가능 주인공이 특정 영역에 들어올 때 컷신을 틀고 싶다면 존을 사용할 수 있다. 컴포넌트를 쓰지 않는다면 이들 클래스는 아래와 같이 상속할 것이다. GameObject: 위치나 방향 등 기본 데이터 Zone: GameObject 상속, 충돌 검사 기능 Decoration: GameObject 상속, 렌더링 기능 추가 Prop: 충돌 기능을 위해 Zone 상속, 하지만 렌더링 기능을 추가하기 위해 Decoration 상속하려는 순간 &#39;죽음의 다이아몬드&#39;라고 불리는 다중 상속 문제 피할 수 없음. 깔끔하게 재사용할 수 없음.컴포넌트 생성 상속은 필요없음. GameObject 클래스, PhysicsComponent, GraphicsComponent 클래스만 있으면됨. 데커레이션: 그래픽 존: 물리 프랍: 물리 + 그래픽 코드 중복 x, 다중상속 x, 적은 클래스 컴포넌트 == 객체를 위한 플러그 앤 플레이 개체 소캣에 재사용 가능한 여러 컴포넌트 객체를 넣어 기능이 풍부하게 만든다. The pattern 여러 분야를 다루는 하나의 개체 분야별로 격리 각각의 코드를 별도의 컴포넌트 클래스에 둔다. 개체 클래스는 단순히 이들 컴포넌트들의 컨테이너 역할만 한다. 컴포넌트 다양한 의미가 있음: 기업용 소프트웨어에서는 웹을 통해서 통신하도록 서비스를 디커플링하는 것을 컴포넌트 디자인 패턴이라고 부름(컴포넌트 기반 개발), 게임에서는 이와 개념이 다르지만 컴포넌트라는 용어가 대중적임언제 사용? 다음 조건 중 하나라도 만족하면 유용하게 사용가능. 한 클래스에서 여러 분야 건드리고 있어, 서로 디커플링하고 싶을 때 클래스가 거대해져 작업하기 어려울 때 여러 다른 기능을 공유하는 다양한 객체를 정의하고 싶을 경우(단, 상속으로는 딱 원하는 부분만 골라서 재사용할 수가 없다.) 주의사항 클래스 한곳에 모아놨을 때보다 더 복잡해질 가능성이 높음. 컴포넌트끼리 통신하기도 어렵고, 메모리 제어하는것도 복잡해짐. 코드베이스 규모가 크면, 디커플링과 컴포넌트를 통한 재사용에서 이득이 더 클 수 있음 하지만 오버엔지니어링은 지양해야함. 무엇이든지 하려면 한 단계를 거쳐야 할 경우가 많다. 포인터를 타고 내려가다보면 성능이 떨어질 가능성이 있음. 반대로, 성능이나 캐시 일관성을 향상해줄 때도 많음. 컴포넌트는 CPU에서 필요로 하는 순서대로 데이터를 조직하는 데이터 지역성 패턴을 사용하기 쉽게한다. 예제 코드통짜 클래스 모든 기능이 들어 있는 클래스 class Bjorn{public: Bjorn() : velocity_(0), x_(0), y_(0) {} void update(World&amp;amp; world, Graphics&amp;amp; graphics);private: static const int WALK_ACCELERATION = 1; int velocity_; int x_, y_; Volume volume_; Sprite spriteStand_; Sprite spriteWalkLeft_; Sprite spriteWalkRight_;}; Bjorn 의 update는 매 프레임마다 호출된다. void Bjorn::update(World&amp;amp; world, Graphics&amp;amp; graphics){ // Apply user input to hero&#39;s velocity. switch (Controller::getJoystickDirection()) { case DIR_LEFT: velocity_ -= WALK_ACCELERATION; break; case DIR_RIGHT: velocity_ += WALK_ACCELERATION; break; } // Modify position by velocity. x_ += velocity_; world.resolveCollision(volume_, x_, y_, velocity_); // Draw the appropriate sprite. Sprite* sprite = &amp;amp;spriteStand_; if (velocity_ &amp;lt; 0) { sprite = &amp;amp;spriteWalkLeft_; } else if (velocity_ &amp;gt; 0) { sprite = &amp;amp;spriteWalkRight_; } graphics.draw(*sprite, x_, y_);} 업데이트 코드는 입력에 따라 주인공을 가속하며, 물리엔진을 통해 다음 위치를 구한다. 그리고 마지막으로 주인공을 그린다. 입력 나누기 먼저 분야 하나를 정해서 관련 코드를 Bjorn에서 별도의 컴포넌트 클래스로 옮긴다. 입력을 분리하면 다음과 같다. class InputComponent{public: void update(Bjorn&amp;amp; bjorn) { switch (Controller::getJoystickDirection()) { case DIR_LEFT: bjorn.velocity -= WALK_ACCELERATION; break; case DIR_RIGHT: bjorn.velocity += WALK_ACCELERATION; break; } }private: static const int WALK_ACCELERATION = 1;}; class Bjorn{public: int velocity; int x, y; void update(World&amp;amp; world, Graphics&amp;amp; graphics) { input_.update(*this); // Modify position by velocity. x += velocity; world.resolveCollision(volume_, x, y, velocity); // Draw the appropriate sprite. Sprite* sprite = &amp;amp;spriteStand_; if (velocity &amp;lt; 0) { sprite = &amp;amp;spriteWalkLeft_; } else if (velocity &amp;gt; 0) { sprite = &amp;amp;spriteWalkRight_; } graphics.draw(*sprite, x, y); }private: InputComponent input_; Volume volume_; Sprite spriteStand_; Sprite spriteWalkLeft_; Sprite spriteWalkRight_;}; Bjorn 클래스에 InputComponent 객체가 추가되었다. 나머지도 나누기 남아 있는 물리 코드와 그래픽스 코드도 똑같이 나눌 수 있다. class PhysicsComponent{public: void update(Bjorn&amp;amp; bjorn, World&amp;amp; world) { bjorn.x += bjorn.velocity; world.resolveCollision(volume_, bjorn.x, bjorn.y, bjorn.velocity); }private: Volume volume_;}; 데이터(volume_)도 같이 옮겼긴것 주의. class GraphicsComponent{public: void update(Bjorn&amp;amp; bjorn, Graphics&amp;amp; graphics) { Sprite* sprite = &amp;amp;spriteStand_; if (bjorn.velocity &amp;lt; 0) { sprite = &amp;amp;spriteWalkLeft_; } else if (bjorn.velocity &amp;gt; 0) { sprite = &amp;amp;spriteWalkRight_; } graphics.draw(*sprite, bjorn.x, bjorn.y); }private: Sprite spriteStand_; Sprite spriteWalkLeft_; Sprite spriteWalkRight_;}; 이제 주인공 코드는 다음과 같다. class Bjorn{public: int velocity; int x, y; void update(World&amp;amp; world, Graphics&amp;amp; graphics) { input_.update(*this); physics_.update(*this, world); graphics_.update(*this, graphics); }private: InputComponent input_; PhysicsComponent physics_; GraphicsComponent graphics_;}; 분리된 Bjorn 의 두 가지 역할 자신을 정의하는 컴포넌트 집합을 관리하는 역할 컴포넌트들이 공유하는 상태를 들고 있는 역할(위치와 속도) 위치 속도를 남긴 두 가지 이유 이 상태들은 전 분야에서 사용됨 컴포넌트들이 서로 커플링되지 않고도 쉽게 통신할 수 있음. Robo-Bjorn 동작 코드를 컴포넌트로 옮겼지만, 아직 추상화하지 않음. 추상 상위 클래스로 인풋 컴포넌트를 만들고, 입력처리 컴포넌트를 인터페이스 뒤로 숨겨보자.class InputComponent{public: virtual ~InputComponent() {} virtual void update(Bjorn&amp;amp; bjorn) = 0;}; 사용자 입력을 처리하던 코드는 InputComponent 인터페이스를 구현하는 클래스로 끌어내린다.class PlayerInputComponent : public InputComponent{public: virtual void update(Bjorn&amp;amp; bjorn) { switch (Controller::getJoystickDirection()) { case DIR_LEFT: bjorn.velocity -= WALK_ACCELERATION; break; case DIR_RIGHT: bjorn.velocity += WALK_ACCELERATION; break; } }private: static const int WALK_ACCELERATION = 1;}; Bjorn 클래스는 인터페이스의 포인터를 들고 있게 바꾼다.class Bjorn{public: int velocity; int x, y; Bjorn(InputComponent* input) : input_(input) {} void update(World&amp;amp; world, Graphics&amp;amp; graphics) { input_-&amp;gt;update(*this); physics_.update(*this, world); graphics_.update(*this, graphics); }private: InputComponent* input_; PhysicsComponent physics_; GraphicsComponent graphics_;}; 이제 Bjorn 객체를 생성할 때, Bjorn이 사용할 입력 컴포넌트를 다음과 같이 전달할 수 있다.Bjorn* bjorn = new Bjorn(new PlayerInputComponent()); 어떤 클래스라도 InputComponent 추상 인터페이스만 구현하면 입력 컴포넌트가 될 수 있다. update()를 가상 메서드로 변경하여 속도는 느려짐. 대신 ‘데모 모드’ 지원 가능해짐 자동으로 게임을 플레이하는 모드 만들기 가능. class DemoInputComponent : public InputComponent{public: virtual void update(Bjorn&amp;amp; bjorn) { // AI to automatically control Bjorn... }}; 위 컴포넌트를 연결하면, 인공지능 플레이어를 만들 수 있다.Bjorn* bjorn = new Bjorn(new DemoInputComponent());No Bjørn at all? 이제 Bjorn 클래스는 컴포넌트 묶음일 뿐이다. 그래픽과 물리를 인터페이스와 구현부로 나눠보자. class PhysicsComponent{public: virtual ~PhysicsComponent() {} virtual void update(GameObject&amp;amp; obj, World&amp;amp; world) = 0;};class GraphicsComponent{public: virtual ~GraphicsComponent() {} virtual void update(GameObject&amp;amp; obj, Graphics&amp;amp; graphics) = 0;}; Bjorn 클래스의 이름을 바꾸고 인터페이스를 사용하게 해야함. 일부 컴포넌트 시스템은 여기서 한발 더 나아간다. 게임 개체는 컴포넌트 포인터를 들고 있는 클래스가 아니라 그냥 ID 숫자로만 표현된다. 개별 컬렉션에 들어 있는 컴포넌트들은 ID를 통해 어느 개체인지 안다. 이러한 개체 컴포넌트 시스템은 극단적으로 컴포넌트 간의 커플링을 막는다. 개체는 컴포넌트가 추가되는지를 알 수 없다.class GameObject{public: int velocity; int x, y; GameObject(InputComponent* input, PhysicsComponent* physics, GraphicsComponent* graphics) : input_(input), physics_(physics), graphics_(graphics) {} void update(World&amp;amp; world, Graphics&amp;amp; graphics) { input_-&amp;gt;update(*this); physics_-&amp;gt;update(*this, world); graphics_-&amp;gt;update(*this, graphics); }private: InputComponent* input_; PhysicsComponent* physics_; GraphicsComponent* graphics_;}; 인터페이스들을 구현해보자class BjornPhysicsComponent : public PhysicsComponent{public: virtual void update(GameObject&amp;amp; obj, World&amp;amp; world) { // Physics code... }};class BjornGraphicsComponent : public GraphicsComponent{public: virtual void update(GameObject&amp;amp; obj, Graphics&amp;amp; graphics) { // Graphics code... }}; 이제 이전의 Bjron을 다음과 같이 똑같이 만들 수 있다.GameObject* createBjorn(){ return new GameObject(new PlayerInputComponent(), new BjornPhysicsComponent(), new BjornGraphicsComponent());} 이 함수는 GOF의 팩토리 메서드 패턴임. 이제 컴포넌트를 조합하여 여러 객체를 만들 수 있음디자인 결정 어떤 컴포넌트 집합이 필요한가?객체는 컴포넌트를 어떻게 얻는가? 누가 컴포넌트를 하나로 합치는지?객체가 필요한 컴포넌트를 알아서 생성할 때 객체는 항상 필요한 컴포넌트를 가지게 된다. 객체를 변경하기가 어렵다.외부 코드에서 컴포넌트를 제공할 때 객체가 유연해진다. 객체를 구체 컴포넌트 타입(the concrete component types)으로부터 디커플링할 수 있다. 밖에서 전달 == 인터페이스를 상속받은 컴포넌트 객체일 가능성이 높음 객체는 컴포넌트의 인터페이스만 알고 있음, 어떤 클래스인지 구체적으로 모름, 구조를 캡슐화하기 더 좋다. 컴포넌트들끼리는 어떻게 통신? 아래의 여러 방식을 동시에 지원할 수 있다. 보통 그렇게함. 컨테이너 객체의 상태를 변경하는 방식 컴포넌트들은 서로 디커플링 상태를 유지함. input 에서 속도 변경, physics에서 그 값을 사용하면 서로 몰라도됨. 컴포넌트들이 공유하는 정보를 컨테이너 객체에 전부 넣어야한다. 모든 컴포넌트들이 접근할 수 있는 컨테이너 객체로 올려야한다. 컴포넌트 조합에 따라 컨테이너 객체의 상태를 전혀 사용하지 않을 수 있다. =&amp;gt; 보이지 않는(그래픽이 없는) 객체에는 컨테이너 객체에 들어 있는 렌더링 관련데이터는 그저 메모리 낭비 컴포넌트끼리 암시적으로 통시하다 보니, 컴포넌트 실행 순서에 의존하게됨. 분리해도 통짜 클래스의 순서 그대로 유지해, 실행순서가 바뀌지 않도록해야함. 그렇지 않으면 미묘한 버그가 생길 수있음. ex. 그래픽 부터 업데이트하면 이전 프레임을 그리게 됨. 이런 이유 때문에, 하스켈 같이 변경 가능한 상태가 전혀 없는 순수 함수형 언어를 연구하고 있음. 컴포넌트가 서로 참조하는 방식 서로 통신해야 하는 컴포넌트들이 컨테이너 객체를 통하지 않고 직접 참조하게 만드는것 점프 기능 =&amp;gt; 그래픽스-점프스프라이트 점프 여부 == 물리엔진에게 쿼리 그래픽스 컴포넌트가 물리 컴포넌트를 알고 있으면 쉽게 해결 가능 그래픽스 컴포넌트를 생성할 때 적절한 Phyics 컴포넌트를 인수에 레퍼런스로 제공해야함class BjornGraphicsComponent{public: BjornGraphicsComponent(BjornPhysicsComponent* physics) : physics_(physics) {} void Update(GameObject&amp;amp; obj, Graphics&amp;amp; graphics) { Sprite* sprite; if (!physics_-&amp;gt;isOnGround()) { sprite = &amp;amp;spriteJump_; } else { // Existing graphics code... } graphics.draw(*sprite, obj.x, obj.y); }private: BjornPhysicsComponent* physics_; Sprite spriteStand_; Sprite spriteWalkLeft_; Sprite spriteWalkRight_; Sprite spriteJump_;}; 간단하고 빠름: 한 객체가 다른 객체 메서드를 직접 호출, 컴포넌트는 참조하는 컴포넌트의 메서드를 제한없이 호출 가능 두 컴포넌트가 강하게 결합메시지를 전달하는 방식 가장 복잡한 대안 컨테이너 객체에 간단한 메시징 시스템을 만든 뒤에, 각 컴포넌트들이 서로에 정보를 뿌리게 할 수 있다. 일단 컴포넌트에 메시지를 받는 receive메서드를 추가해야함. 지금은 int로 메세지 구현, 제대로 구현하려면 데이터를 추가적으로 보내야함. class Component{public: virtual ~Component() {} virtual void receive(int message) = 0;}; 컨테이너 객체에는 메시지를 보내는 메서드를 추가한다.class ContainerObject{public: void send(int message) { for (int i = 0; i &amp;lt; MAX_COMPONENTS; i++) { if (components_[i] != NULL) { components_[i]-&amp;gt;receive(message); } } }private: static const int MAX_COMPONENTS = 10; Component* components_[MAX_COMPONENTS];}; 컴포넌트가 컨테이너에 접근할 수 있는 경우, 컴포넌트가 컨테이너에게 메시지를 보낼 수 있다. 그러면 컨테이너는 포함된 모든 구성 요소에 메시지를 다시 브로드 캐스트한다. 여기서 처음 메시지 보낸 컴포넌트도 포함되니, 피드백 루프를 조심해야한다.(이벤트 큐 패턴 참고) 결과는 다음과 같다. - 하위 컴포넌트들은 디커플링된다.: 상태 공유 방식에서처럼 상위 컨테이너 객체를 통해서 통신하기 때문에, 컴포넌트들은 메시지 값과 커플링될 뿐, 컴포넌트끼리는 디커플링 상태 유지 - 컨테이너 객체는 단순하다: 무작정 메시지만 전달하면 끝. GOF의 중재자(mediator)패턴: 둘 이상의 객체가 중간 객체를 통해서 메시지를 간접적으로 전달해 통신하는 방법 결론 세 방식 중에 정답은 없음 조금씩 셋다 쓰게됨 상태 공유 방식: 위치나 크기같은 기본적인 정보를 공유하기 좋음 서로 가까운 분야: 입력과 AI, 물리와 충돌 =&amp;gt; 쌍을 직접 알게 하는게 좋을 수 있음. 메시지: 호출하고 나서 신경 안써도 되는 ‘사소한’통신에 좋음 물리 컴포넌트- 충돌 =&amp;gt; 오디오 컴포넌트- 소리 관련 자료 유니티 프레임 워크의 핵심 클래스인 GameObject는 전적으로 컴포넌트 방식에 맞춰 설계되었다. 오픈소스 엔진인 Delta3D는 actor에 컴포넌트 패턴 사용 마소 XNA 게임 프레임워크에는 Game이라는 핵심 클래스가 있음. 여기에 GameComponent에서 이 패턴 사용. 컴포넌트 패턴을 메인 게임 객체 수준에서 적용함. GoF의 전략 패턴과 비슷함 두 패턴 모두 객체의 동작 일부를 별도의 하위 객체에 위임. 전략객체: 상태가 없는 경우가 대부분.(데이터가 없음, 동작만 정의) 컴포넌트: 객체를 표현하는 상태 소유, 정체성 정의됨 출처component" }, { "title": "[게임 프로그래밍 패턴] Behavioral Patterns: Type Object", "url": "/posts/2022/02/25/16/38/pattern13/", "categories": "pattern", "tags": "", "date": "2022-02-25 16:38:59 +0900", "snippet": "Type Object 단일 클래스를 각 인스턴스가 다른 타입 객체형으로 표현할 수 있게 만든다. 이를 통해 새로운 ‘classes’을 유연하게 생성할 수 있음. 동기 다양한 몬스터 구현 체력 + 공격 + 그래픽 + 사운드 등 속성 attack string 속성 종족(breed) 속성 (체력, attack string 결정한다고 가정) 전형적인 OOP방식OOP 몬스터 예제: 구현할 몬스터가 많아지면.. 여러 종족들은 모두 몬스터이다. 객체지향 방식 =&amp;gt; Monster라는 상위 클래스를 만드는게 자연스러움 즉, is-a관계(상속말고도 방법이 있음) class Monster{public: virtual ~Monster() {} virtual const char* getAttack() = 0;protected: Monster(int startingHealth) : health_(startingHealth) {}private: int health_; // Current health.}; getAttack(): 공격할 때 보여줄 문구를 반환한다. 하위클래스가 오버라이드(override)해서 다른 공격 문구를 보여줌 생성자: protected, 체력을 받음. 하위클래스인 종족에서 최대 체력을 전달 아래는 종족을 표현한 하위클래스 class Dragon : public Monster{public: Dragon() : Monster(230) {} virtual const char* getAttack() { return &quot;The dragon breathes fire!&quot;; }};class Troll : public Monster{public: Troll() : Monster(48) {} virtual const char* getAttack() { return &quot;The troll clubs you!&quot;; }}; 이렇게 클래스들을 구현하면, 하위 클래스가 많아진다.문제점 몬스터 수백 종을 만드면, 작업이 느려지게 됨. 몇 줄 안되는 Monster 하위 클래스를 작성 후 컴파일 해야함. 작업 플로우: 기획자의 수정 요청 =&amp;gt; 헤더파일 체크아웃 후 수정 =&amp;gt; 컴파일 =&amp;gt; 변경사항 체크인 =&amp;gt; 기획자에게 답장 이를 반복함. 프로그래머들은 생각없이 데이터만 입력하게됨 기획자들은 숫자 몇개만 바꾸는 데에도 하루 종일 걸리는 것에 좌절 종족 상태 값은 게임 코드를 빌드하지 않고도 변경가능해야한다. 기획자가 스스로 새로운 종족을 만들고 값 또한 수정할 수 있어야한다. 클래스를 위한 클래스 해결하는 간단한 방법: 게임에 몬스터가 여러 종 =&amp;gt; 몇몇 속성은 여러 몬스터가 공유하게 몬스터마다 종족에 대한 정보를 두는 것. 종족마다 Monster 클래스를 상속받게 하지 않고, Monster 클래스 하나와 종족(Breed) 클래스 하나만 만든다. 그리고 Monster에서 Breed를 참조하게(몬스터와 종족을 결합) 이제 클래스 두 개만으로 해결 가능하다. 모든 몬스터를 Monster 클래스의 인스턴스로 표현할 수 있다. Breed 클래스에는 공유하는 정보가 들어있다. Breed 클래스 == 몬스터의 ‘타입’을 정의 (타입 객체 패턴이라는 이름의 이유) 타입 객체 패턴 코드 수정 없이 새로운 타입을 정의할 수 있다는 게 장점. 런타임에 정의할 수 있는 데이터로 옮긴것. Breed 인스턴스를 만들어 다른 값 입력 == 또 다른 종족 생성 설정 파일에서 읽은 데이터로 종족 객체를 생성 == 데이터만으로 전혀 다른 몬스터 정의 가능 The pattern type object 클래스와 typed object 클래스를 정의해야함. (타입 객체와 타입 사용 객체) 타입 객체: 논리적으로 다른 타입 의미 개념적으로 같은 타입끼리 공유하는 데이터나 동작 저장 타입 사용 객체: 자신의 타입을 나타내는 타입 객체를 참조 인스턴스별로 다른 데이터는 타입 사용 객체 인스턴스에 저장 같은 타입 객체를 참조 == 같은 타입인 것처럼 동작 상속 처리를 하드 코딩하지 않고 마치 상속받는 것처럼 비슷한 객체끼리 데이터나 동작을 공유. 언제 사용? 타입 객체 패턴: 다양한 종류를 정의해야하는데, 개발 언어의 타입 시스템이 유연하지 않아 코드로 표현하기 어려울 경우 적합. 나중에 어떤 타입이 필요할지 알 수 없음.(새로운 몬스터) 컴파일이나 코드 변경 없이 새로운 타입을 추가하거나 타입을 변경하고 싶을 경우. 주의 사항 타입 객체 패턴의 핵심 표현력은 감소, 유연성은 증가, 데이터로 ‘타입’표현 타입 객체 수동 추적 C++의 타입 시스템 컴파일러가 클래스를 위한 일들을 알아서 해줌. C++ 가상함수: 내부적으로 vtable로 구현 vtable은 단순한 구조체에 클래스의 가상 함수들을 함수 포인터를 저장해놓은 것. 가상함수 호출할 경우, 먼저 객체로부터 vtable을 찾은 후 vtable에 저장된 함수 포인터를 찾아 호출한다. vtable == 종족 객체, vtable에 대한 포인터 == 몬스터에 있는 종족 객체 레퍼런스 C++클래스 == 컴파일러가 C언어 내부적으로 타입 객체 패턴을 적용한 것 각각의 클래스를 정의하는 데이터: 컴파일될 때 자동으로 실행 파일의 정적 메모리 영역에 들어가 동작. 타입 객체 패턴에서는, 몬스터 인스턴스와 타입 객체를 직접 관리해야한다. 타입 객체를 필요로 하는 객체가 있다면, 메모리에 계속 유지해야함. 몬스터 생성시 알맞은 레퍼런스 초기화 컴파일러가 해주던 일을 직접 구현해야함.타입별로 동작을 표현하기 어려움 상속 방식 =&amp;gt; 메서드 오버라이드 =&amp;gt; 코드로 값계산, 다른 코드 호출 타입 객체 패턴 =&amp;gt; 종족 객체 변수에 값을 저장하는 방식 ‘데이터‘는 정의하기 쉽지만 ‘동작‘을 정의하기는 어려움 ex. 다른 AI알고리즘 적용 간단한 해결방법: 미리 동작 코드 여러개 정의 타입 객체가 적당한 함수 포인터를 저장하게 하면 타입 객체를 AI알고리즘과 연계 가능.(타입 객체에서 vtable 구현) 데이터만으로 동작을 정의할 수도 있다. 바이트코드 패턴 or 인터프리터 패턴 =&amp;gt; 데이터로 동작 표현 파일에서 데이터 읽고, 이들 패턴으로 자료구조 생성, 동작 정의 게임은 점점 데이터 주도 방식으로 변화, 하드웨어 최적화보다 콘텐츠를 얼마나 만들 수 있는가에 따른 제약을 받음. 요즘 게임은 게임플레이를 가득 채우는게 일 스크립트 언어 같은 고수준 방식으로 게임 동작을 정의 == 실행 성능은 하락, 생산성은 높임.예제 코드타입 객체 패턴의 핵심 class Breed{public: Breed(int health, const char* attack) : health_(health), attack_(attack) {} int getHealth() { return health_; } const char* getAttack() { return attack_; }private: int health_; // Starting health. const char* attack_;}; Breed 클래스에는 최대 체력과, 공격 문구 필드 두 개만 있다. Monster 클래스에서는 이 클래스를 아래와 같이 사용. class Monster{public: Monster(Breed&amp;amp; breed) : health_(breed.getHealth()), breed_(breed) {} const char* getAttack() { return breed_.getAttack(); }private: int health_; // Current health. Breed&amp;amp; breed_;}; Monster 클래스 생성자는 Breed 객체를 레퍼런스로 받는다. - 상속 없이 종족 정의 - 최대 체력 == breed로부터얻음 생성자 함수를 통해 타입 객체를 좀 더 타입 같이 위에선 몬스터 생성자에서 종족을 전달했음 메모리를 먼저 할당한 후 그 메모리에 클래스를 할당하는 것과 같음. 대부분 OOP언어에서는 이런 식으로 객체를 만들지 않음. 대신 클래스의 생성자 함수를 호출해 클래스가 알아서 새로운 인스턴스를 생성하게 한다.(팩토리 함수같은것) 타입 객체에도 이 패턴을 적용한다.(팩토리 메서드 패턴) class Breed{public: Monster* newMonster() { return new Monster(*this); } // Previous Breed code...}; 그리고 다음과 같이 몬스터의 생성자를 private로 설정, 종족을 friend로 설정한다.class Monster{ friend class Breed;public: const char* getAttack() { return breed_.getAttack(); }private: Monster(Breed&amp;amp; breed) : health_(breed.getHealth()), breed_(breed) {} int health_; // Current health. Breed&amp;amp; breed_;}; Breed 클래스의 newMonster가 팩토리 메서드 패턴의 생성자가 된다. 루비, 스몰토크, 오브젝트 C == 클래스가 객체인 언어 == 새로운 인스턴스를 생성하기 위해 클래스 객체의 메서드를 호출 이제 몬스터는 다음과 같이 생성한다.Monster* monster = someBreed.newMonster(); 이러면, 객체는 메모리 할당과 초기화 2단계로 생성됨. Monster 클래스 생성자 함수에서는 필요한 모든 초기화 작업을 다 할 수있다. 그래픽 로딩, 몬스터 AI 설정 등 다른 초기화 작업을 한번에 할 수 있음. 이런 초기화 작업 == 메모리 할당 후에 진행 아직 제대로 초기화되지 않은 몬스터가 메모리에 먼저 올라와있음. 객체 생성 과정을 제어하고 싶은 경우: 오브젝트 풀 패턴을 이용, 커스텀 할당자 이용 =&amp;gt; 객체가 메모리 어디에 생성될지를 제어 이점 생성자를 다른곳에 두는 이점 Monster 클래스에 초기화 제어권 넘겨주기 전에 메모리 풀이나 커스텀 힙에서 메모리를 가져올 수 있다. 모든 몬스터가 정해놓은 메모리 관리 루티능ㄹ 따라 생성되도록 강제 가능. 상속으로 데이터 공유하기 종족이 수백 개, 속성이 많아질 경우 여러 종족이 속성 값을 공유하면 좋음. OOP방식처럼 상속을 통할 수 있음. 프로그래밍 언어의 상속기능이 아닌 타입 객체끼리 상속할 수 있는 시스템을 구현할것임. 단일 상속 클래스가 상위 클래스를 갖는 것처럼 종족 객체도 상위 종족 객체를 가질 수 있게 만든다.class Breed{public: Breed(Breed* parent, int health, const char* attack) : parent_(parent), health_(health), attack_(attack) {} int getHealth(); const char* getAttack();private: Breed* parent_; int health_; // Starting health. const char* attack_;}; breed 객체생성시 상속받을 종족 객체를 넘겨줌. 상위 종족이 없는 최상위 종족 == NULL 값 하위 객체는 상위 객체로부터 받을지, 자기 값으로 오버라이드할지 제어 가능해야함. 예제: 최대체력이 0이 아닐 때, 공격 문구가 NULL이 아닐 때 자기 값 사용하도록, 그 외는 상위 객체 값. 두가지 방식이 있음.속성을 요청받을 때마다 동적으로 위임 int Breed::getHealth(){ // Override. if (health_ != 0 || parent_ == NULL) return health_; // Inherit. return parent_-&amp;gt;getHealth();}const char* Breed::getAttack(){ // Override. if (attack_ != NULL || parent_ == NULL) return attack_; // Inherit. return parent_-&amp;gt;getAttack();} 런타임에 변경해야할 경우 좋음 특정 속성 값을 더 이상 오버라이드하지 않을 때 더이상 상속 받지 않도록 변경 단점 - 포인터 유지 - 메모리 차지 - 속성 조회시 상속된것들 전부 확인 =&amp;gt; 느림 종족 속성 값이 바뀌지 않으면, 생성 시점에 바로 상속적용 가능. &#39;카피다운(copy-down)&#39; 위임 이라고 함 객체 생성시 상속받는 속성 값을 하위 타입으로 복사해서 넣기 때문. 카피다운 위임 Breed(Breed* parent, int health, const char* attack): health_(health), attack_(attack){ // Inherit non-overridden attributes. if (parent != NULL) { if (health == 0) health_ = parent-&amp;gt;getHealth(); if (attack == NULL) attack_ = parent-&amp;gt;getAttack(); }} 상위 종족 객체를 포인터로 유지할 필요가 없음. 깔끔하고 빠르다. int getHealth() { return health_; }const char* getAttack() { return attack_; } Json json 파일로 종족을 정의해보자 프로토타입 패턴에서 다룬것처럼 { &quot;Troll&quot;: { &quot;health&quot;: 25, &quot;attack&quot;: &quot;The troll hits you!&quot; }, &quot;Troll Archer&quot;: { &quot;parent&quot;: &quot;Troll&quot;, &quot;health&quot;: 0, &quot;attack&quot;: &quot;The troll archer fires an arrow!&quot; }, &quot;Troll Wizard&quot;: { &quot;parent&quot;: &quot;Troll&quot;, &quot;health&quot;: 0, &quot;attack&quot;: &quot;The troll wizard casts a spell on you!&quot; }} 체력이 0이므로 상위 종족으로부터 값을 상속받음. 종족과 종족별 속성 개수가 늘어날 수록 상속으로 시간을 많이 아낄 수 있다. 기획자가 자유롭게 제어할 수 있음.디자인 결정 설계의 폭이 넓고 여러 시도를 할 수 있는 패턴 하지만 가능성이 제한됨 시스템 복잡 =&amp;gt; 개발기간 증가, 유지보수 어려움 사용자는 프로그래머가 아닌 경우가 많음(이해하기 쉽게 만들어야함) =&amp;gt; 간단하게 타입 객체를 숨김? 노출? Monster 설계시 종족을 반환하도록 변경할 경우 모든 몬스터에 종족 객체가 있다는 사실이 공개 API에 포함되어야함. Monster 클래스 설계가 바뀜 class Monster{public: Breed&amp;amp; getBreed() { return breed_; } // Existing code...};타입 객체를 캡슐화(If the type object is encapsulated) 타입 객체 패턴의 복잡성이 나머지 다른 코드에는 드러나지 않음 구현 디테일 == 타입 사용 객체에서만 고민. 타입 사용 객체는 타입 객체로부터 동작을 선택적으로 오버라이드할 수 있다. 외부 코드에서 Breed 객체의 getAttack()을 사용하면, 아래와 같이 코드를 추가 못함. const char\\* Monster::getAttack(){if (health\\_ &amp;lt; LOW_HEALTH){return &quot;The monster flails weakly.&quot;;}return breed\\_.getAttack();} 타입 객체 메서드를 전부 포워딩해야 한다. 타입 사용 객체 클래스에서 외부에 공개하고 싶은 메서드들을 포워딩해야함. 타입 객체를 노출 타입 사용 클래스 인스턴스를 통하지 않고도 외부에서 타입 객체에 접근할 수 있다. 타입 객체인 Breed의 메서드를 호출해 새로운 몬스터 생성(팩토리) 타입 객체가 공개 API의 일부가 됨. 인터페이스를 적게 노출 =&amp;gt; 복잡성 줄어들고, 유지보수 편함 타입 객체 노출 =&amp;gt; 타입 객체가 제공하는 모든 것 == 객체 API에 포함 타입 사용 객체를 어떻게 생성? 객체는 쌍으로 존재 (타입, 타입 사용)객체 생성한 후 타입 객체를 넘겨주는 경우 외부 코드에서 메모리 할당 제어 가능 두 객체 모두 외부에서 생성 커스텀 메모리 할당자, 스택 등에 둘 수 있음. 타입 객체의 생성자 함수에서 생성하는 경우 타입 객체에서 메모리 할당을 제어 외부에서 타입 객체 메모리 생성 선택권을 주고 싶지 않을 경우 타입 객체 팩토리 메서드를 통해 객체를 생성하여 메모리 제어 가능. 모든 객체를 특정 오브젝트 풀 or 다른 메모리 할당자에서만 생성하도록 제한하고 싶을 경우 타입을 변경할 수 있는가? 변경하게 가능. ex. 죽으면 종족을 좀비로타입을 바꿀 수 없다면 코드 구현 쉬움, 이해 쉬움. 디버깅 쉬움.타입을 바꿀 수 있다면 객체 생성횟수 줄어든다. 타입 불변: 기존 몬스터 삭제 =&amp;gt; 새로운 몬스터 생성 타입 변: 포인터 교체 강한 커플링 종족 타입을 바꾼다면, 기존 코드들이 새로운 타입의 요구사항에 맞아야함. =&amp;gt; 검증 코드 필요할 수 있음. 상속을 어떻게 지원?상속 없음 단순 중복 작업이 생길 가능성단일 상속 그나마 단순한 편 구현 쉽고, 이해 쉬움. 많은 프로그래밍 언어가 단일 상속만 지원함. 속성 값을 얻는 데 오래 걸림 값을 얻으려면, 적절한 타입을 찾을 때 까지 상속구조 타고 올라감. 런타임 낭비 다중 상속 거의 모든 데이터 중복 피함 복잡함 이해하기 어려움. 상속 그래프 흐름 이해해야함. 상속 구조를 잘 설계해야함 C++ 표준에서는 다중 상속을 금지함.(구글 코딩 컨벤션에서는 interface에서는 허용. 다른 규약들도 비슷) 관련 자료 고수준에서 이 패턴이 해결하려고 하는 문제 == 여러 객체끼리 데이터와 동작을 공유하려는 것. 프로토타입 패턴 또한 이 문제를 해결하고자 함. 타입 객체 패턴은 경량 패턴이랑 비슷. 여러 인스턴스가 데이터 공유할 수 있게 함. 경량 패턴 목적: 메모리 절약 타입 객체 패턴 목적: 조직화와 유연성 상태 패턴과 유사함. 자기를 정의하는 부분 일부를 위임함. 타입 객체: 해당 객체를 나타내는 불변 데이터를 주로 위임 상태 패턴: 객체의 현재 상태가 어떤지를 나타내는 임시 데이터를 주로 위임 타입 객체 교체 == 상태 패턴 역할도 가능. 출처Type Object" }, { "title": "[게임 프로그래밍 패턴] Behavioral Patterns: Subclass Sandbox", "url": "/posts/2022/02/25/03/53/pattern12/", "categories": "pattern", "tags": "", "date": "2022-02-25 03:53:40 +0900", "snippet": "Subclass Sandbox 상위 클래스가 제공하는 기능들을 통해서 하위 클래스에서 행동을 정의동기다양한 능력을 선택하는 게임SuperPower라는 상위클래스 =&amp;gt; 상속받는 클래스하위클래스가 많아질 가능성이 높음. 바이트 코드 패턴 or 타입 객체 패턴을 사용하면 더 나음(데이터 기반)하위 클래스인 초능력 클래스는 여러 코드를 건드리게됨다수의 하위클래스: 단점 중복 코드가 많아짐. 거의 모든 게임 코드가 초능력 클래스와 커플링 엮일 의도가 전혀 없던 하부 시스템(subsystem)을 바로 호출하도록 코드를 짤 수 있음 외부 시스템이 변경되면 초능력 클래스가 깨질 가능성이 높다. 여러 초능력 클래스가 게임 내 다양한 코드와 커플링 모든 초능력 클래스가 지켜야 할 불변식(invariant)을 정의하기 어렵다.원시 명령 집합 제공(a set of primitives) 사운드 =&amp;gt; playSound 파티클 =&amp;gt; spwanPaticles 필요한 모든 기능들을 제공하면 초능력 클래스가 이런저런 헤더를 include하거나 다른 코드를 찾아 헤매지 않아도 된다. 이러한 작업을 Superpower의 protected 메서드로 만들어 모든 하위 초능력 클래스에서 쉽게 접근하게 해야함 protected 또는 비-가상함수: 이들 함수가 하위 클래스 용이라는것을 알려주기 위해. 샌드 박스 메서드 사용할 공간을 제공하기 위해 하위 클래스가 구현해야하는 샌드박스 메서드 =&amp;gt; 순수 가상 메서드로 만들어 protected에 둔다. 이제 초능력 클래스 구현은 다음과 같다. Superpower를 상속받는 새로운 클래스를 만든다. 샌드박스 메서드인 activate()를 오버라이드한다. Superpower 클래스가 제공하는 protected 메서드를 호출하여 activate()를 구현한다. 장점 중복코드 문제 해결 중복되는 코드가 있으면, 언제든지 Superpower클래스로 옮겨서 하위 클래스에서 재사용. 리펙토링: pull up 기법이라고 부름. 커플링 문제 해결 커플링을 한곳으로 모음. Superpower 클래스 == 여러 게임 시스템과 커플링 하지만, 수 많은 하위 클래스는 상위 클래스와만 커플링됨. 게임 시스템이 변경될 때 Superpower클래스를 고쳐야함. 상속 구조가 얇게 퍼진다. 많은 클래스가 같은 상위 클래스를 둠 =&amp;gt; 전략적 요충지 확보 가능 Superpower 클래스에 집중 투자 깊은 상속 구조보다는 얇고 넓은 상속 구조가 좋음. The pattern 상위 클래스: 추상 샌드박스 메서드와 여러 제공 기능을 정의. 제공 기능: protected로 만들어서 하위 클래스용이라는 걸 분명히 한다. When to Use It굉장히 단순하고 일반적이라 게임이 아닌 곳에서도 사용.클래스 protected인 비-가상 함수가 있다면, 이 패턴을 사용하고 있을 가능성이 높다. 클래스 하나에 하위 클래스가 많이 있을 경우 사용 상위 클래스는 하위 클래스가 필요한 기능을 전부 제공 가능. 하위 클래스 행동 중에 겹치는 게 많아, 이를 하위 클래스끼리 쉽게 공유하고 싶을 경우. 하위 클래스들 사이의 커플링 및 하위 클래스와 나머지 코드와의 커플링을 최소화하고 싶을 경우.주의 사항 상속 == 코드가 계속 쌓이는 경향이 있음. 게임 엔진 아키텍처에서는 ‘버블업 효과’라고 부른다. 하위 클래스는 상위 클래스를 통해서 나머지 게임 코드에 접근함. 상위 클래스가 하위 클래스에서 접근해야 하는 모든 시스템과 커플링됨. 이런 커플링관계 =&amp;gt; 상위 클래스를 조금만 바꿔도 어딘가가 깨지기 쉽다. 깨지기 쉬운 상위 클래스(fragile base class) 문제에 빠짐 상위 코드가 거대해지면, 제공 기능 일부를 별도 클래스로 뽑아내 책임을 나눠 갖게 할 수 있음. 이 때 컴포넌트 패턴 유용 장점 하위 클래스를 나머지 코드와 깔끔하게 분리 이상적이라면 동작 대부분이 하위 클래스에 있을것. 많은 코드가 격리되어 있으면 유지보수 하기 쉽다. 예제 코드 의도가 중요.예제: 제어 흐름을 만드는데 유용 class Superpower{public: virtual ~Superpower() {}protected: virtual void activate() = 0; void move(double x, double y, double z) { // Code here... } void playSound(SoundId sound, double volume) { // Code here... } void spawnParticles(ParticleType type, int count) { // Code here... }}; activate: 샌드박스 메서드, 순수 가상 함수 초능력 클래스 구현 작업 위치 나머지 protected 메서드: 제공기능, activate메서드를 구현할 경우 사용 Superpower 클래스에서만 다른 시스템에 접근함, Superpower 안에 모든 커플링을 캡슐화 거미에게 점프 기능 부여 class SkyLaunch : public Superpower{protected: virtual void activate() { // Spring into the air. playSound(SOUND_SPROING, 1.0f); spawnParticles(PARTICLE_DUST, 10); move(0, 0, 20); }}; 점프 능력: 소리 + 흙먼지 + 높이 뛰어오름 모든 능력 클래스가 이런 조합만으로 되어 있다면, 이 패턴을 사용할 필요는 없음(동작은 같으면서 데이터만 다를 때) 정해진 동작만 하도록 activate()를 구현하고, 능력별로 다른 사운드 ID, 파티클, 움직임을 사용하게 만들면된다. 더 정교한 코드는 다음과 같다. class Superpower{protected: double getHeroX() { // Code here... } double getHeroY() { // Code here... } double getHeroZ() { // Code here... } // Existing stuff...}; class SkyLaunch : public Superpower{protected: virtual void activate() { if (getHeroZ() == 0) { // On the ground, so spring into the air. playSound(SOUND_SPROING, 1.0f); spawnParticles(PARTICLE_DUST, 10); move(0, 0, 20); } else if (getHeroZ() &amp;lt; 10.0f) { // Near the ground, so do a double jump. playSound(SOUND_SWOOP, 1.0f); move(0, 0, getHeroZ() + 20); } else { // Way up in the air, so do a dive attack. playSound(SOUND_DIVE, 0.7f); spawnParticles(PARTICLE_SPARKLES, 1); move(0, 0, -getHeroZ()); } }}; 어떤 상태에 대해 접근할 수 있기 때문에, 제어 흐름을 만들 수 있게 됨. 디자인 결정 상당히 소프트한 패턴.중요: 어떤 기능을 제공해야하나? 기능을 적게 제공하는 방향 맨 끝 상위 클래스에 제공 기능은 전혀 없음.(샌드박스 메서드 하나만있음) 하위 클래스에서는 상위 클래스가 아닌 외부 시스템을 직접 호출해야함. 모든 기능을 상위 클래스에서 제공 하위 클래스: 상위 클래스와만 커플링됨, 외부 시스템 접근 x(#include 상위 클래스 헤더 파일 딱 하나) 양 극단 사이 적절한 외부 시스템, 상위 클래스의 제공 기능들 제공 기능이 많음: 상위 클래스와 더 많이 커플링. 많은 하위 클래스가 일부 외부 시스템과 커플링되어 있다면, 커플링을 상위 클래스의 제공 기능으로 옮김으로써 커플링을 상위 클래스 한 곳에 모아둘 수 있다는 장점이 있다. 그럴수록 상위 클래스는 커지고 유지보수 힘들어짐 일반적인 원칙 제공기능을 몇 안되는 하위 클래스에서만 사용한다면 별 이득은 없다. 상위 클래스의 복잡도는 증가하는 반면, 혜택을 받는 클래스는 몇 안됨. 그냥 외부 시스템에 직접 접근하는 것이 더 간단 명료 다른 시스템의 함수를 호출할 때에도 그 함수가 상태를 변경하지 않는다면 크게 문제가 되지않음. 안전한 커플링 기술적으로는 데이터 읽기만으로 문제 발생 가능, 게임 상태가 엄격하게 결정적일 때도 까다로움(플레이어 상태 동기화해야하는 경우), 비결정적인 버그에 노출될 수 있다. 외부 시스템의 상태를 변경하는 함수 사용 ==&amp;gt; 그 시스템과 더 강하게 결합된다는 점을 좀 더 분명히 인지해야함. =&amp;gt; 상위 클래스 제공기능으로 옮겨 눈에 잘 들어오게 제공 기능이 단순한 외부 시스템으로 호출을 넘겨주는 일밖에 하지 않는다면 있어봐야 좋을 게 없다. 하위 클래스에서 외부 메서드 직접 호출하는 게 더 깔끔 단순 포워딩만해도, 하위 클래스에 특정 상태를 숨길 수 있다는 장점이 있음. void playSound(SoundId sound, double volume){soundEngine_.play(sound, volume);} 위 함수는 포워딩만 하지만, 함부로 soundEngine_에 하위 클래스에서 접근할 수 없도록 캡슐화함. 메서드를 직접 제공? 객체를 통해서 제공? 하위 클래스 샌드박스 패턴의 골칫거리: 상위 클래스의 메서드 수가 끔찍하게 늘어난다는 점. 다른 클래스로 이전하면 완화 가능 예제: 다른 클래스 추가 예를 들어 초능력을 사용할 때 사운드를 내기 위해 Superpower 클래스에 메서드 직접 추가하는 방법이 있다. class Superpower{protected: void playSound(SoundId sound, double volume) { // Code here... } void stopSound(SoundId sound) { // Code here... } void setVolume(SoundId sound) { // Code here... } // Sandbox method and other operations...}; 여기서 사운드 기능을 모아 이를 제공하는 클래스를 만들 수 있다. class SoundPlayer{ void playSound(SoundId sound, double volume) { // Code here... } void stopSound(SoundId sound) { // Code here... } void setVolume(SoundId sound) { // Code here... }}; 이 객체에 접근하도록 해야함. class Superpower{protected: SoundPlayer&amp;amp; getSoundPlayer() { return soundPlayer_; } // Sandbox method and other operations...private: SoundPlayer soundPlayer_;}; 보조 클레스로 옮기는것의 장점 상위 클래스의 메서드 개수 줄임. 보조 클래스에 있는 코드를 유지보수하기 더 쉬움. 상위 클래스와 다른 시스템과의 커플링을 낮춤. 상위 클래스는 필요한 객체를 어떻게 얻는가? 상위 클래스 멤버 변수 중 캡슐화하고 하위 클래스로부터 숨기고 싶은 데이터를 얻는 방법?상위 클래스의 생성자로 받기 상위 클래스의 생성자 인수로 받으면 가장 간단.class Superpower{public: Superpower(ParticleSystem* particles) : particles_(particles) {} // Sandbox method and other operations...private: ParticleSystem* particles_;}; 생성될 때 파티클 시스템 객체를 참조하도록 강제. 하지만 하위 클래스에서 문제. class SkyLaunch : public Superpower{public: SkyLaunch(ParticleSystem* particles) : Superpower(particles) {}}; 모든 하위 클래스 생성자는 파티클 시스템을 인수로 받아 상위 클래스 생성자에 전달해야함. 원치않게 상위 클래스의 상태가 노출됨. 상위 클래스에 다른 상태를 추가하려면 하위 클래스 생성자도 해당 상태를 전달하도록 전부 바꿔야함.(유지보수 취약) 2단계 초기화 초기화를 2단계로 나누면 생성자로 모든 상태를 전달하는 번거로움을 피할 수 있다. 생성자는 매개변수를 받지 않고 그냥 객체를 생성한다. 그 후 상위 클래스 메서드를 따로 실행해 필요한 데이터를 제공한다. Superpower* power = new SkyLaunch();power-&amp;gt;init(particles); private으로 숨겨놓은 멤버 변수와 전혀 커플링되지 않음. init()를 무조건 호출해야 한다는 문제가 발생 객체 생성 과정 전체를 한 함수로 캡슐화 하면 해결. Superpower* createSkyLaunch(ParticleSystem* particles){ Superpower* power = new SkyLaunch(); power-&amp;gt;init(particles); return power;} ?? 생성자를 private에 두고 friend 클래스를 잘 활용하면 createSkyLaunch()에서만 SkyLaunch 객체를 생성할 수 있도록 보장할 수 있다. ???정적 객체로 만들기 상태를 상위 클래스의 private 정적 멤버 변수로 만들 수 있음. 한 번한 초기화 하면 됨. 어떤 상태가 많은 객체에 공유되기 때문에 싱글턴의 여러 단점이 따라옴. 같은 객체를 여러 인스턴스가 건드려서 코드가 복잡해짐 class Superpower{public: static void init(ParticleSystem* particles) { particles_ = particles; } // Sandbox method and other operations...private: static ParticleSystem* particles_;}; 하위 클래스 생성자만 호출하면 Superpower인스턴스를 그냥 만들 수 있음. particles_가 정적 변수이기 때문에 메모리 사용량을 줄임.서비스 중개자 이용 앞에서는 상위클래스가 필요로 하는 객체를 먼저 넣어주는 작업을 밖에서 잊지말고 해줘야 했음. 초기화 부담을 외부 코드에 넘기고 있었음. 만약 상위 클래스가 원하는 객체를 직접 가져올 수 있으면 스스로 초기화 가능. 서비스 중개자 패턴class Superpower{protected: void spawnParticles(ParticleType type, int count) { ParticleSystem&amp;amp; particles = Locator::getParticles(); particles.spawn(type, count); } // Sandbox method and other operations...}; spawnParticles()는 필요로 하는 파티클 시스템 객체를 외부 코드에서 전달받지않고 직접 서비스 중개자(Locator 클래스)에서 가져온다.관련자료 업데이트 메서드 패턴: 업데이트 메서드는 흔히 샌드박스 메서드임. 이와 상반되는 패턴: 템플릿 메서드 패턴, 둘다 원시 명령들(a set of primitive operations)로 메서드를 구현, 샌드박스 메서드 == 하위 클래스에서 구현, 원시명령(primitive operations) == 상위 클래스에 있음 템플릿 메서드 == 상위 클래스에 있음, 원시명령(primitive operations) == 하위 클래스 구현 GOF의 파사드(facade) 패턴의 일종 여러 다른 시스템을 하나의 단순화된 API 뒤로 숨길 수 있다. 하위 클래스 샌드박스 패턴에서 상위 클래스 == 전체 게임 코드를 하위 클래스로부터 솜겨주는 일종의 파사드처럼 동작 출처sub-sandbox" }, { "title": "[게임 프로그래밍 패턴] Behavioral Patterns: Bytecode", "url": "/posts/2022/02/24/09/06/pattern11/", "categories": "pattern", "tags": "", "date": "2022-02-24 09:06:43 +0900", "snippet": "행동 패턴 장면(scene)을 시작할 차례 개체들의 행동이 필요 코드 == ‘행동’ 수많은 행동을 유지보수하기 좋은 상태로 빠르게 정의하고 고치는데 도움이되는 패턴 타입 객체 패턴: 클래스를 실제로 정의하지 않아도 유연하게 행동 종류를 만들 수 있음. 하위 클래스 샌드박스 패턴: 다양한 행동을 정의하는 데 안전하게 사용할 수 있는 기본 기능 리스트를 제공 바이트 코드 패턴: 행동 구현을 코드가 아닌 데이터로 정의할 수 있는 가장 진보된 방법 바이트 코드 명령어를 인코딩한 데이터로 행동을 표현할 수 있는 유연함 제공동기 게임 제작의 어려움 엄청난 양의 복잡한 소스 코드 구현 플랫폼의 성능도 최대한 뽑아야함. C++과 같은 중량 언어(heavyweight language)를 사용 기술을 들이는 비용 만만치 않음. 거기다 재미 또한 챙겨야한다. 반복개발 =&amp;gt; 창조적인 몰입 상태에 빠지기 어려움 마법전투! 두 마법사가 어느 한 쪽이 이길 때까지 서로에게 마법을 쏘는 대전 게임을 만든다고 가정. 마법을 고칠 때 마다, 프로그래머가 코드를 고쳐야함 약간 바꿔서 테스트하고자 할 때 =&amp;gt; 전체 빌드 필요 요즘 게임 == 출시한 뒤에도 업데이트를 통해서 버그를 고치거나 콘텐츠를 추가할 수 있어야한다. 모드 지원 == 유저 자신만의 마법 소스를 공개해야함. 데이터 &amp;gt; 코드 게임 엔진에서 사용하는 개발 언어는 마법을 구현하기에 적합하지 않다. 마법 기능과 핵심 게임 코드와 격리할 필요가 있다. 실행 파일과는 물리적으로 떼어놓도록. 데이터 행동을 데이터 파일에 따로 정의 =&amp;gt; 게임 코드에 읽어서 ‘실행’ GOF의 인터프리터 패턴 실행하고 싶은 프로그래밍 언어가 있다고 가정. 이 언어는 아래 수식을 지원함$(1+2) * (3-4)$ 이런 표현식을 읽어서 언어 문법에 따라 각각 객체로 변환해야함. 숫자 리터럴을 다음과 같이 객체가 된다. 숫자 상수는 다순히 숫자 값을 래핑한 객체. 연산자도 객체롤 바뀜 =&amp;gt; 피연산자도 같이 참조 괄호 + 우선순위 =&amp;gt; 표현식이 작은 객체 트리로 바뀜. Parsing: 파서는 문자열을 읽어서 문법 구조를 표현하는 객체 집합인 추상 구문 트리로 만든다. 인터프리터 패턴의 목적: 추상 구문 트리 =&amp;gt; 실행 표현식 or 하위표현식 =&amp;gt; 객체 트리 =&amp;gt; 객체지향 방식으로 표현식이 자기 자시능ㄹ 평가하게함. 모든 표현식 객체가 상속받을 상위 인터페이스를 만든다.class Expression{public: virtual ~Expression() {} virtual double evaluate() = 0;}; 언어 문법에서 지원하는 모든 표현식마다 Expression 인터페이스를 상속받는 클래스 정의class NumberExpression : public Expression{public: NumberExpression(double value) : value_(value) {} virtual double evaluate() { return value_; }private: double value_;}; 숫자 리터럴 표현식은 자기 값을 평가한다. 덧셈, 곱셈에는 하위표현식이 들어가 더 복잡. 자기를 평가하기 전, 포함된 하위 표현식을 재귀적으로 평가 class AdditionExpression : public Expression{public: AdditionExpression(Expression* left, Expression* right) : left_(left), right_(right) {} virtual double evaluate() { // Evaluate the operands. double left = left_-&amp;gt;evaluate(); double right = right_-&amp;gt;evaluate(); // Add them. return left + right; }private: Expression* left_; Expression* right_;}; 복잡한 수식 == 간단한 클래스로, 필요한 만큼 객체 만들어 적절히 연결 루비언어 =&amp;gt; 인터프리터 방식으로 돌아가다, 바이트코드 방식으로 바뀜 단점: 화살표들이 많음 =&amp;gt; 복잡한 프랙탈 트리 모양(a sprawling fractal tree) 코드 로딩 =&amp;gt; 작은 객체를 많이 만들고 연결 객체와 객체를 잇는 포인터는 많은 메모리를 소모. 하위 표현식에 접근 == 데이터 캐시에 치명적 가상 메서드 호출 == 명령어 캐시에 치명적 **느리다** 가상 기계어 게임 실행 =&amp;gt; 미리 컴파일한 기계어를 실행함. 기계어 장점 밀도 높음: 한 비트도 낭비하지 않음. 선형적: 명령어가 같이 모여있음. 순서대로 실행(흐름 제어문 제외) 저수준: 각 명령어 == 비교적 최소한의 작업 빠름: 하드웨어로 직접 구현됨 구현 기계어를 유저한테 제공 == 해커들에게 취약 많은 게임 콘솔과 IOS에서 로딩하거나 런타임에 생성한 기계어를 애플리케이션에서 실행하지 못하게함 =&amp;gt; JIT 컴파일러 == 코드를 즉석에서 최적화된 기계어로 바꿔줌. 기계어의 성능 &amp;lt;–절충–&amp;gt; 인터프리터 패턴의 안정성 가상 기계어와 간단한 예물레이터(가상머신, vm) 안전하게 격리 가능 vm이 실행하는 가상 바이너리 기계어는 바이트코드라고 부름 바이트코드: 유연, 데이터로 여러가지 쉽게 정의 가능 인터프리터 패턴같은 고수준 표현보다 성능이 좋음 루아 == 바이트코드로 구현된 언어 가상 머신 == 인터프리터 The Pattern 명령어 집합(instruction set) == 실행할 수 있는 저수준 작업들을 정의 명령어 == 일련의 바이트로 인코딩 가상머신 == 중간 값들을 스택에 저장, 명령어 하나씩 실행 명령어 조합 =&amp;gt; 복잡한 고수준 행동 정의언제 사용?책에 있는 패턴 중 가장 복잡하고 쉽게 적용하기 어려움.정의할 행동은 많은데, 게임 구현에 사용한 언어로는 구현하기 어려울 때 바이트코드 패턴을 사용한다. 언어가 저수준이라, 만드는데 손이 많이 가거나 오류가 생기기 쉬움. 컴파일 시간이나 다른 빌드 환경 때문에 반복 개발하기가 너무 오래 걸림 보안에 취약, 정의하려는 행동이 게임을 깨먹지 않게 하고 싶다면, 나머지 코드로부터 격리해야함.대부분의 게임이 위에 해당빠른 반복 개발 + 안정성 =&amp;gt; 얻기 어려움 바이트 코드 == 네이트 코드보다 느림. (성능 민감한 곳에 적합 x)주의사항 되는 대로 만들지 말아야함 바이트코드가 표현할 수 있는 범위를 꼼꼼히 관리해야한다. 프론트엔드가 필요 저수준 바이트코드 명령어 성능 면에서 뛰어남. 사용자가 작성할 만한 게 아님. 컴파일러: 가상머신이 이해할 수 있는 바이트코드로 변환 저작 툴을 만들 여유가 없으면 바이트 코드 패턴을 쓰기 어렵다. You’ll miss your debugger 디버거, 정적 분석기, 디컴파일러 같은 툴 == 어셈블리어와 고수준의 언어들에서만 사용할 수 있게 만들어짐 바이트 코드 VM에서는 이런 툴이 무용지물. VM 그 자체가 무엇을 하는지 알 수 있을 뿐이다. 모드로 변경할 수 있게 하고 싶다면 디버깅 기능도 같이 출시해야함 Sample Code 먼저 VM에 필요한 명령어 집합을 정의해야한다.A magical API 마법 주문을 C++ 로 구현하기 위해 필요한 API 마법은 마법사의 스탯 중 하나를 바꿈. void setHealth(int wizard, int amount);void setWisdom(int wizard, int amount);void setAgility(int wizard, int amount); 매개변수(wizard)는 마법을 적용할 대상. 세 가지 함수 =&amp;gt; 다양한 마법 효과 가능 아래는 사운드 재생, 파티클을 보여주는 것 void playSound(int soundId);void spawnParticles(int particleType);A magical instruction set API가 데이터에서 제어 가능한 무언가로 어떻게 바뀌는지 작게 시작하기위해 우선 매개변수 전부 제거 set___() : 마법사의 스탯 항상 최대값으로 이펙트효과: 하드코딩 마법은 이제 단순한 명령 집합. 명령어는 각각 어떤 작업을 하려는지 나타냄. 명령어들을 아래와 같이 열거형으로 표현할 수 있다. enum Instruction{ INST_SET_HEALTH = 0x00, INST_SET_WISDOM = 0x01, INST_SET_AGILITY = 0x02, INST_PLAY_SOUND = 0x03, INST_SPAWN_PARTICLES = 0x04}; 마법을 데이터로 인코딩하려면 이들 열거형 값을 배열에 저장하면된다. 원시 명령(primitive)의 개수에 따라 바이트 크기 변함. 마법 =&amp;gt; 바이트들의 목록 : 바이트 코드 명령 하나 실행: 어떤 원시명령인지를 보고 이에 맞는 API메서드를 호출하면됨. switch (instruction){ case INST_SET_HEALTH: setHealth(0, 100); break; case INST_SET_WISDOM: setWisdom(0, 100); break; case INST_SET_AGILITY: setAgility(0, 100); break; case INST_PLAY_SOUND: playSound(SOUND_BANG); break; case INST_SPAWN_PARTICLES: spawnParticles(PARTICLE_FLAME); break;} 인터프리터는 코드와 데이터를 연결. 마법 전체를 실행하는 VM에서는 이 코드를 다음과 같이 래핑한다. 첫 번째 가상머신 구현은 다음과 같다. class VM{public: void interpret(char bytecode[], int size) { for (int i = 0; i &amp;lt; size; i++) { char instruction = bytecode[i]; switch (instruction) { // Cases for each instruction... } } }}; 이 가상 머신은 유연하지 않다. 상대방 마법사를 건드리거나 스탯을 낮추는 마법을 만들 수 없음. 사운드도 하나만 출력 가능하다. 매개변수를 받을 필요가 있음. A stack machine 복잡한 중첩식을 실행하려면 가장 안쪽 하위 표현식부터 계산해야한다. 그 결과를 이를 담고 있던 표현식의 인수로 넘긴다. 이걸 전체 표현식이 다 계산될 때까지 반복하면 된다. 인터프리터 패턴 == 중첩 객체 트리 형태로 중첩식 표현 명령어를 1차원으로 나열해도, 하위 표현식 결과를 중첩 순서에 맞게 다음 표현식에 전달해야한다. 이를 위해 CPU처럼 스택을 이용해서 명령어 실행 순서를 제어한다. 이를 스택머신이라고 부름. 스택 기반 언어도 있음. C++은 컴파일러가 알아서 함수 인수를 스택에 쌓아 전달하지만, 스택기반 언어는 코드에서 직접 스택에 값을 넣어야 함수에 인수 전달 가능. class VM{public: VM() : stackSize_(0) {} // Other stuff...private: static const int MAX_STACK = 128; int stackSize_; int stack_[MAX_STACK];}; 스택을 통해 명령어들은 데이터를 주고 받는다.class VM{private: void push(int value) { // Check for stack overflow. assert(stackSize_ &amp;lt; MAX_STACK); stack_[stackSize_++] = value; } int pop() { // Make sure the stack isn&#39;t empty. assert(stackSize_ &amp;gt; 0); return stack_[--stackSize_]; } // Other stuff...}; 명령어가 매개변수를 받을 때는 스택에서 꺼냄.switch (instruction){ case INST_SET_HEALTH: { int amount = pop(); int wizard = pop(); setHealth(wizard, amount); break; } case INST_SET_WISDOM: case INST_SET_AGILITY: // Same as above... case INST_PLAY_SOUND: playSound(pop()); break; case INST_SPAWN_PARTICLES: spawnParticles(pop()); break;} 스택에서 값을 얻어오려면, 리터럴 명령어가 필요하다. 리터럴 명령어는 정수 값을 나타냄 종료 조건없는 재귀함수 같이 무한 회귀문제를 피하면서 리터럴 명령어 자신의 값을 얻어와야함. 명령어 목록이 바이트의 나열이라는 점을 활용해야함. 숫자를 바이트 배열에 직접 집어넣으면 된다. 숫자 리터럴을 위한 명령어 타입은 다음과 같이 정의한다. case INST_LITERAL:{ // Read the next byte from the bytecode. int value = bytecode[++i]; // 예제에서는 2바이트 이상의 정수를 디코딩하는 코드 대신 1바이트만 읽고 있음. push(value); break;} 즉, 리터럴 명령어 뒤에 해당하는 정수 값을 둠.그림으로 보는 인터프리터가 명령어 몇 개를 실행하는 과정과 스택 작동 원리 이해 스택이 비어 있는 상태에서 인터프리터가 첫 번째 명령을 실행한다. 리터럴 명령어부터 시작하여 바이트 값들을 읽어 스택에 넣는다. 마지막으로 INST_LITERAL을 실행한다.(10을 읽어서 스택에 넣음) 마지막으로 INST_SET_HEALTH를 실행. 스택에서 10 =&amp;gt; amount 매게변수 스택에서 0 =&amp;gt; wizard 매개변수 setHealth(wizard, amount) 함수 호출 하지만 규칙으로 표현하는것이 좋음.행동 = 조합 아직 몇 가지 내장 함수와 상수 매개변수만 지원할 뿐. 조합을 할 수 있게 해야함. 스탯을 지정한 값으로 바꿀 수 있는 마법 == 현재 스텟 고려 스탯을 얻어오는 명령을 추가해야함.case INST_GET_HEALTH:{ int wizard = pop(); push(getHealth(wizard)); break;}case INST_GET_WISDOM:case INST_GET_AGILITY: // You get the idea... 스탯을 복사하는 마법 또한 만들 수 있다. 다음으로는 계산 능력이 필요하다. case INST_ADD:{ int b = pop(); int a = pop(); push(a + b); break;} 마법사 체력을 민첩성과 지혜의 평균만큼 더해주는 마법 Get the wizard’s current health and remember it. Get the wizard’s agility and remember it. Do the same for their wisdom. Get those last two, add them, and remember the result. Divide that by two and remember the result. Recall the wizard’s health and add it to that result. Take that result and set the wizard’s health to that value. setHealth(0, getHealth(0) + (getAgility(0) + getWisdom(0)) / 2); 1번은 다음과 같다.LITERAL 0GET_HEALTH 이 바이트 코드는 마법사의 체력을 스택에 넣음 아래는 스택의 상태가 변하는 것을 보여주는 예이다. 스탯: 체력 45, 민첩 7, 지혜 11 LITERAL 0 [0] # Wizard indexLITERAL 0 [0, 0] # Wizard indexGET_HEALTH [0, 45] # getHealth()LITERAL 0 [0, 45, 0] # Wizard indexGET_AGILITY [0, 45, 7] # getAgility()LITERAL 0 [0, 45, 7, 0] # Wizard indexGET_WISDOM [0, 45, 7, 11] # getWisdom()ADD [0, 45, 18] # Add agility and wisdomLITERAL 2 [0, 45, 18, 2] # DivisorDIVIDE [0, 45, 9] # Average agility and wisdomADD [0, 54] # Add average to current healthSET_HEALTH [] # Set health to result 가상머신 지금까지의 VM만으로 단순하면서, 깔끔한 데이터 형태로 행동을 마음껏 정의 가능. ‘바이트 코드’나 ‘가상 머신’은 스택, 반복문, 다중 선택문만으로 간단하게 만들 수 있다. VM 구현 과정을 통해 ‘행동을 안전하게 격리‘한다는 목표를 달성함 바이트 코드 == 정의해높은 명령 몇 개를 통해서만 다른 코드에 접근할 수 있기 때문에 악의적인 코드를 실행하거나 잘못된 위치에 접근할 방법이 없음. 스택 크기를 통해 VM의 메모리 사용량을 조절할 수 있다. 시간또한 제어 가능 interpret() 반복문에서 실행되는 명령어가 일정 개수 이상이면 빠져나오게 할 수 있다. 마법 제작 툴 고수준으로 제작할 수 있는 방법을 만드는것이 목표 고수준 정의 ==변환==&amp;gt; 저수준 스택 머신 바이트코드 클릭해서 작은 상자를 드래그 앤 드롭하거나 메뉴를 선택하는 식의 행동 조립 GUI 툴에서는 사용자가 ‘잘못된’ 코드를 만들 수 없음. 바이트코드 패턴의 궁극적인 목표: 사용자가 행동을 고수준 형식으로 편하게 표현할 수 있도록 하는 데 있다. 디자인 결정 바이트 코드 VM은 보통 스택기반과 레지스터 기반으로 나뉜다. 스택기반 VM 항상 스택 맨 위만 접근 레지스터 기반 스택은 있지만, 깊숙한 곳에서도 입력 값을 읽어올 수 있다. 바이트 코드에 인덱스가 있어, 스택 어디에서나 읽어올 수 있게 . . 스택기반 VM 명령어가 짧다: 인수를 스택 맨 위에서 얻기 때문에 명령어에 데이터를 따로 인코딩하지 않아도됨.&amp;lt;/br&amp;gt;코드 생성이 간단: 순서만 잘 맞춰 명령어를 배치하면 명령어들끼리 매개변수를 주고받게한다. &amp;lt;/br&amp;gt;명령어 개수가 많다: 모든 명령어가 스택 맨 위만 볼 수 있기 때문에, 결과 등을 옮기는 등의 명령문이 여러개 필요 레지스터 기반 VM 명령어가 길다: 명령어가 스택 오프셋 값을 가지므로 비트가 더 필요&amp;lt;/br&amp;gt;명령어 개수는 줄어든다: 한 명령어에서 더 많은 일을 할 수 있다. 성능향상 기대 루아는 레지스터 기반 VM을 사용. 한 명령어가 32비트, 6비트를 명령어 종류가 차지, 나머지는 인수들이 들어간다. 가능하면 스택기반 VM이 좋음 구현과 코드 생성도 간단 명령어를 어떻게 만드느냐, vm을 어떻게 구현하느냐에 따라 더 많이 달라짐. 어떤 명령어를 만들어야 하는가? 외부 원시 명령(External primitives) VM == 외부 게임 코드에 접근 바이트코드로 어떤 행동을 표현할 수 있는지를 제어 외부 원시 명령이 없으면, VM은 CPU 사이클 낭비. 내부 원시 명령(Internal primitives) 리터럴, 연산, 비교, 그 외 스택에 값을 주고받는 명령어들로 VM 내부 값을 다룬다. 흐름 제어 명령어를 조건에 따라 실행, 여러번 반복 점프 명령어: 인덱스 기록, 실행위치 옮기는것. 추상화 데이터 재사용, 프로시저 같은 것 VM이 별도의 반환 스택을 관리. 호출 =&amp;gt; 현재 실행 인덱스를 반환 스택에 넣고, 호출된 바이트코드로 점프. 반환 =&amp;gt; VM은 반환 스택으로부터 실행 인덱스를 받아서 그 위치로 점프 값을 어떻게 표현? 문자열, 객체, 리스트 같은 여러 다른 자료형도 지원해야함.단일 자료형 간단. 태깅이나 변환, 자료형 검사 신경 x 다른 자료형을 다룰 수 없음.태그 붙은 변수 동적 타입 언어에서 흔한 방식. 모든 값은 두부분. 자료형(열거형)태그 데이터(태그에 따라 적절히 해석) enum ValueType{ TYPE_INT, TYPE_DOUBLE, TYPE_STRING};struct Value{ ValueType type; union { int intValue; double doubleValue; char* stringValue; };}; 값이 자신의 타입을 안다. 런타임에 값의 타입 확인 동적 디스패치에 중요(지원안하는 타입 연산을 막음) 메모리가 더 필요 모든 값에 비트를 추가해야함. 저수준에서는 영향이 큼 태그가 붙지 않은 공용체 정적 타입 언어가 이런 식으로 메모리에 표현 유니온을 사용하지만, 타입 태그는 없음. 알아서 해석 컴파일할 때 타입 시스템이 값을 제대로 해석하도록 보장 =&amp;gt; 런타임에 따로 검증하지 않음. 작다 빠르다 타입 검사 오버헤드 없음. 안전하지 않음 포인터에 대해 잘못 해석하면 크래시 or 해킹에 취약 바이트코드 =&amp;gt; 컴파일러를 통하지 않고 수동으로 악성 바이트코드 집어넣을 수 있음. 자바 VM이 프로그램을 로딩할 때 바이트코드 검증을 하는 이유 인터페이스 객체지향: 여러 타입 중 무엇인지를 모르는 값이 있으면 다형성으로 처리. 인터페이스는 여러 자료형을 테스트하고 변환하는 가상 메서드를 다음과 같이 제공.class Value{public: virtual ~Value() {} virtual ValueType type() = 0; virtual int asInt() { // Can only call this on ints. assert(false); return 0; } // Other conversion methods...}; 각 타입마다 구체 클래스를 정의class IntValue : public Value{public: IntValue(int value) : value_(value) {} virtual ValueType type() { return TYPE_INT; } virtual int asInt() { return value_; }private: int value_;}; 제한이 없다: 어떤 타입이든 정의 가능 객체지향적이다: 다형성 디스패치 번거롭다: 타입마다 코드 정의 비효율적: 다형성 == 포인터를 통해 동작, 힙에 할당된 객체로 래핑, 값에 접근할 때마다 가상함수 호출해야함. 할 수만 있다면 자료형은 하나만 사용하는것이 좋음 아니면 태그 붙은 변수 바이트코드는 어떻게 만들 것? 바이트 생성 == 보통 컴파일러텍스트 기반 언어를 정의할 경우 문법을 정의해야함: 사용자가 만족하는 문법은 만들기 어려움. 문법설계 == UI설계 파서 구현: 파서 생성기(ANTLR, BISON), 재귀 하향 파서를 만들면됨. 문법 오류를 처리: 오류가 있다면, 올바른 방향으로 이끌어줘야 한다. 비-프로그래머들은 쓰기 어려움UI가 있는 저작 툴을 만들 경우 UI를 구현해야함: 이에 따라 툴은 쉽고 편해짐. 게임 콘텐츠도 개선 오류가 적다: 행동을 상호작용 방식으로 한 단계씩 만들기 때문. 이식성이 낮음: 프레임워크를 정해야함. OS에 종속되어있음.관련 자료 인터프리터 패턴과 함께 데이터로 행동을 조합할 수 있는 방법 제공하는게 이 패턴 두 패턴을 둘다 사용하는 경우가 많다. 루아 == 게임 쪽에서 가장 널리 사용중인 스크립트 언어. 키즈멧(kismet) == 언리얼 에디터에 포함된 그래픽 스크립트 툴출처bytecode" }, { "title": "[게임 프로그래밍 패턴] Squencing Patterns: Update Method", "url": "/posts/2022/02/24/03/57/pattern10/", "categories": "pattern", "tags": "", "date": "2022-02-24 03:57:00 +0900", "snippet": "Update Method 컬렉션에 들어 있는 객체별로 한 프레임 단위의 작업을 진행하라고 알려줘서 전체를 시뮬레이션.Motivation스켈레톤 예제: 무작정 몬스터들을 구현하면 코드가 복잡해진다. 한 프레임에 한 걸음씩 스켈레톤이 왼쪽, 오른쪽 왔다갔다하는 코드를 간단하게 작성하면 다음과 같다. Entity skeleton;bool patrollingLeft = false;double x = 0;// Main game loop:while (true){ if (patrollingLeft) { x--; if (x == 0) patrollingLeft = false; } else { x++; if (x == 100) patrollingLeft = true; } skeleton.setX(x); // Handle user input and render game...} 코드는 보기 좀 불편하다. 마법을 쓰는 몬스터를 추가해보자 // Skeleton variables...Entity leftStatue;Entity rightStatue;int leftStatueFrames = 0;int rightStatueFrames = 0;// Main game loop:while (true){ // Skeleton code... if (++leftStatueFrames == 90) { leftStatueFrames = 0; leftStatue.shootLightning(); } if (++rightStatueFrames == 80) { rightStatueFrames = 0; rightStatue.shootLightning(); } // Handle user input and render game...} 코드는 더 복잡해진다. 코드를 한데 뭉쳐야함 해결방법: 모든 개체가 자신의 동작을 캡슐화 게임루프를 어지럽히지 않고도 쉽게 개체를 추가 삭제 가능. 추상 메서드 update()를 정의해 추상 계층을 더해야함. 게임 루프는 업데이트가 가능하다는 것만 알 뿐, 구체적인 타입은 모르는 채로 객체 컬렉션을 관리한다. 각 객체의 동작을 게임 엔진과 다른 객체로부터 분리 가능. 게임루프: 매 프레임마다 객체 컬랙션을 돌면서 update()를 호출 각 객체는 한 프레임만큼 동작을 진행. 모든 게임 객체가 동시에 동작(하는것 처럼 보이게) 게임 루프: 객체 관리 동적 컬렉션 소유 컬렉션에 객체를 추가, 삭제하기만 하면, 레벨에 객체를 쉽게 넣다 뺏다 가능. 레벨 디자이너가 원하는 대로 데이터 파일 이용해 레벨 찍어냄. The Pattern 게임 월드는 객체 컬렉션을 관리한다. 각 객체는 한 프레임 단위의 동작을 시뮬레이션하기 위한 update() 메서드를 구현 매 프레임마다 게임은 컬렉션에 들어 있는 모든 객체를 업데이트한다. When to Use It 동시에 동작해야하는 객체나 시스템이 게임에 많을 때 각 객체의 동작이 다른 객체와 거의 독립적일 때 객체는 시간의 흐름에 따라 시뮬레이션되어야 함. 게임 루프 패턴 다음으로 중요한 패턴 다수의 객체 상호작용 =&amp;gt; 업데이트 메서드 패턴 거의 필수 체스말 같은 객체들이 많을 경우, 이 패턴이 잘 안 맞을 수 있음. 체스말 == 모든 말을 동시에 시뮬 안해도 됨, 매 프레임마다 업데이트 안해도 됨.(애니메이션은 업데이트해야됨 =&amp;gt; 이 패턴이 도움됨) Keep in Mind코드를 한 프레임 단위로 끊어서 실행하는 게 더 복잡하다 유저 입력, 렌더링 등을 게임 루프가 처리하게 하면, 거의 언제나 프레임마다 실행하게 해야함. 이 방식은 동작 코드를 프레임마다 조금씩 실행되도록 쪼개어 넣으려면 코드가 복잡해져서 구현 비용이 더 든다. 저자는 도중에 반환하지 않는 직관적인 코드를 유지하면서, 동시에 게임 루프 안에서 여러 객체를 실행할 수 있는 일석이조의 방법이 있기 때문에 ‘거의’라는 표현을 씀 동시에 여러 개의 실행 ‘스레드’를 돌릴 수 있는 시스템이 필요. 객체용 코드가 리턴 대신 중간에 잠시 멈췄다 다시 실행할 수만 있다면 코드를 훨씬 직관적으로 만들 수 있다. 스레드는 이런 용도로 쓰기에는 무거움. 제너레이터(generator), 코루틴(coroutine), 파이버(fiber) 같은 경량 동시성 구조(lightweight concurrency constructs)를 지원하는 경우, 이를 사용할 수 있다. 바이트 코드 패턴 == 애플리케이션 수준에서 여러 실행 스레드를 만드는 방법 중 하나다음 프레임에서 다시 시작할 수 있도록 현재 상태를 저장해야한다 예를들면, 위 코드에서 이동방향을 따로 저장해야함. 상태 패턴을 사용하여 이전에 중단한 곳으로 되돌아갈 수 있음.모든 객체는 매 프레임마다 시뮬레이션되지만 진짜로 동시에 되는 건 아니다 업데이트 순서의 중요성 더블 버퍼 =&amp;gt; 순서가 문제되지 않게 순차적 업데이트 == 게임 로직 작업하기 편함 객체를 병렬로 업데이트하다보면 꼬일 수 있음. 체스 말, 동시에 같은 위치 유효한 상태를 유지할 수 있음. 여러 이동을 직렬화 =&amp;gt; 온라인 게임에서 유효 업데이트 도중에 객체 목록을 바꾸는 건 조심해야한다 업데이트 가능한 객체를 게임에서 추가, 삭제하는 코드가 있을 경우.객체가 새로 생기는 경우 별 문제 없이 리스트 뒤에 추가. 하지만, 새로 생성된 객체가 렌더링되지않고(플레이어가 보지못한 상태) 해당 프레임에 작동 해결: 객체 개수 미리 저장, 그만큼만. int numObjectsThisTurn = numObjects_;for (int i = 0; i &amp;lt; numObjectsThisTurn; i++){ objects_[i]-&amp;gt;update();}객체가 삭제되는 경우 몬스터가 죽었으면, 그 몬스터를 목록에서 빼야함. 삭제할 경우, 의도치않게 객체 하나를 건너뛸 수 있음.for (int i = 0; i &amp;lt; numObjects_; i++){ objects_[i]-&amp;gt;update();} 이렇기 때문에, 객체를 삭제할 때 i를 업데이트하는 방법도 있음. 다 순회한 뒤, 삭제할 수 도 있음. 제거할 객체인지 저장해서, 뛰어넘기 멀티스레드가 돌고 있으면, 업데이트 도중 비싼 스레드 동기화를 피하기 위해, 리스트 변경을 지연해야함. Sample Code 업데이트 메서드는 단순하다.class Entity{public: Entity() : x_(0), y_(0) {} virtual ~Entity() {} virtual void update() = 0; double x() const { return x_; } double y() const { return y_; } void setX(double x) { x_ = x; } void setY(double y) { y_ = y; }private: double x_; double y_;}; 추상 메서드인 update가 가장 중요. 게임 world == 개체 컬렉션을 관리 개체 컬렉션 관리 보통 컬렉션 클래스 사용.(코드 단순화를 위해 일반 배열 사용) class World{public: World() : numEntities_(0) {} void gameLoop();private: Entity* entities_[MAX_ENTITIES]; int numEntities_;}; 매 프레임마다 개체들을 덥데이트 =&amp;gt; 구현 끝.void World::gameLoop(){ while (true) { // Handle user input... // Update each entity. for (int i = 0; i &amp;lt; numEntities_; i++) { entities_[i]-&amp;gt;update(); } // Physics and rendering... }}Subclassing entities?! Entitiy 클래스를 상속 거대한 상속 == 유지보수 불가능(쪼개야함.) 클래스 상속보다 ‘객체 조합’이 낫다. 해결책: 컴포넌트 패턴 컴포넌트 패턴 사용 =&amp;gt; update 함수는 entity 클래스가 아닌 entity 객체의 컴포넌트에 있게된다. 상속구조를 복잡하게 만들지 않아도 된다. 필요한 컴포넌트만 넣으면됨. 여기서는 업데이트 메서드의 예를 보여주기위해 상속을 이용한것.(실제로는 컴포넌트를 사용하는것이 좋다.)Defining entities 순찰을 도는 해골 경비병, 번개를 쏘는 마법 석상 정의 예시class Skeleton : public Entity{public: Skeleton() : patrollingLeft_(false) {} virtual void update() { if (patrollingLeft_) { setX(x() - 1); if (x() == 0) patrollingLeft_ = false; } else { setX(x() + 1); if (x() == 100) patrollingLeft_ = true; } }private: bool patrollingLeft_;};class Statue : public Entity{public: Statue(int delay) : frames_(0), delay_(delay) {} virtual void update() { if (++frames_ == delay_) { shootLightning(); // Reset the timer. frames_ = 0; } }private: int frames_; int delay_; void shootLightning() { // Shoot the lightning... }}; 석상 코드는 더 단순해짐. 변수를 클래스로 옮겨서, 석상 인스턴스가 타이머를 각자 관리할 수 있어 원하는 만큼 많이 만들 수 있다. 게임월드에 새로운 개체를 추가하기 쉬워짐. 데이터 파일이나 레벨 에디터 같은 걸로 월드에 개체를 유연하게 추가 가능. 가변 시간 간격: Passing time update()를 부를 때마다 게임 월드 상태가 동일한 고정 단위 시간만큼 진행된다고 가정하고 있었음. 가변 시간 간격의 경우, 시간 간격을 크게 혹은 짧게 시뮬레이션해야한다. update()는 시간이 얼마나 지났는지 알아야함. void Skeleton::update(double elapsed){ if (patrollingLeft_) { x -= elapsed; if (x &amp;lt;= 0) { patrollingLeft_ = false; x = -x; } } else { x += elapsed; if (x &amp;gt;= 100) { patrollingLeft_ = true; x = 100 - (x - 100); } }} 해골 병사의 이동 거리는 지난 시간에 따라 늘어남. 주의:시간 간격이 크면, 순찰 범위를 벗어날 수 있음. Design DecisionsWhat class does the update method live on? 가장 중요한 결정은 update()를 어느 클래스에 두느냐이다.the entity class 이미 entity 클래스가 있다면, 다른 클래스를 추가하지 않아도 된다는 점에서 가장 간단한 방법이다. 이 방법은 요즘 업계(2016년쯤)에는 이 방식을 멀리하고 있음 entity 종류가 많은데 새로운 동작을 만들 때 마다 entity 클래스를 상속받아야 한다면, 코드가 망가지기 쉽고 작업하기 어렵다. 단일 상속 구조로 코드를 매끄럽게 재사용할 수 없는 순간이 옴. The component class 컴포넌트는 알아서 자기 자신을 업데이트함. 업데이트 메서드 패턴이 게임 자체를 게임 월드에 있는 다른 개체와 디커플링하는 것처럼 컴포넌트 패턴은 한 개체의 일부를 개체의 다른 부분들과 디커플링한다. 렌더링, 물리, AI는 스스로 알아서 돌아간다. A delegate class 클래스의 동작 일부를 다른 객체에 위임하는 패턴들 상태 패턴: 상태가 위임하는 객체를 바꿈, 객체 동작 변경 가능하게 타입 객체 패턴: 같은 종류의 여러 개체가 동작을 공유 위임 클래스에 update() update() 메서드는 개체 클래스에 있지만, 가상 함수가 아니며, 객체에 포워딩(forward)만 한다. void Entity::update(){ // Forward to state object. state_-&amp;gt;update();} 새로운 동작 정의: 위임 객체 변경. 완전히 새로운 상속 클래스를 정의하지 않아도 동작을 바꿀 수 있는 유연성을 얻을 수있음.(컴포넌트와 마찬가지로) How are dormant objects handled? 휴먼 객체 처리 일시적으로 업데이트가 필요 없는 객체 생김. 사용 불능 상태 화면 밖인 상태 잠금 상태 휴면상태 다수 =&amp;gt; 매 프레임마다 CPU 클럭 낭비 대안: ‘살아 있는’ 객체만 따로 컬렉션에 모아두는 것 객체가 비활성화 =&amp;gt; 컬렉션에서 제거 객체가 활성화 =&amp;gt; 컬렉션에서 추가비활성 객체가 포함된 컬렉션 하나만 사용할 경우 시간을 낭비 비활성 객체일 경우 활성상태인지를 나타내는 플래그만 검사 or 아무것도 안함 CPU 클럭 낭비 + 데이터 캐시 날림(의미 없는 객체 순회) CPU는 읽기를 최적화하기 위해 데이터를 RAM에서 속도가 훨씬 빠른 on-chip cache로 가져옴. (지금 읽는 데이터 옆에 있는 데이터도 같이) 객체를 건너뛰면, 캐시에 데이터가 없어서 다시 느린 메모리에 접근해 데이터 가져워야함=&amp;gt; 데이터 지역성 패턴 활성 객체만 모여 있는 컬렉션 추가 두 개의 컬렉션 =&amp;gt; 메모리 추가 사용 전체 개체를 모아놓은 마스터 컬렉션도 있음. 이때 활성 객체 컬렉션은 중복 데이터. 메모리보다 속가 중요하다면 허용가능. 절충=&amp;gt; 비활성 객체만 모아놓기 컬렉션 두 개의 동기화를 유지 생성, 소멸 시 두 컬렉션 모두 변경 비활성 객체가 많으면, 컬렉션을 따로.See Also 업데이트 메서드 패턴 == 게임루프, 컴포넌트와 함께 게임코드의 핵심 캐시 성능 == 데이터 지역성 패턴 유니티 프레임워크 == MonoBehaviour를 포함한 여러 클래스에서 이 패턴 사용 마이크로소프트 XNA 플랫폼은 Game, GameComponent 클래스에서 이 패턴 사용 Quintus라는 게임엔진은 주요 Sprite 클래스에서 이 패턴 사용출처Update Method" }, { "title": "[게임 프로그래밍 패턴] Squencing Patterns: Game Loop", "url": "/posts/2022/02/24/01/05/pattern9/", "categories": "pattern", "tags": "", "date": "2022-02-24 01:05:25 +0900", "snippet": "GameLoop 게임 시간 진행을 유저 입력, 프로세서 속도와 디커플링.Motivation 거의 모든 게임에서 사용 어느 것도 서로 똑같지 않음. 전형적인 게임패턴 배치모드(batch mode) 프로그램이 대부분이였음 모든 작업이 끝나면 프로그램이 멈춤 예시: 저자의 프로그램 Interview with a CPU 즉각적인 피드백을 위해 대화형(interactive) 프로그램이 만들어짐. (게임 또한 있었음.) 프로그램은 입력을 대기, 반응while (true){ char* command = readCommand(); handleCommand(command);}Event loops 최신 GUI 애플리케이션 내부도 비슷함.while (true){ Event* event = waitForEvent(); dispatchEvent(event);} 하지만 게임은 입력이벤트가 없어도, 돌아간다. 게임에선 루프는 끊임없이 돌아간다. while (true){ processInput(); update(); render();} processInput(): 이전 호출 이후의 유저 입력 처리 update(): 게임 시뮬레이션을 한단계 시뮬 (Ai, 물리) render(): 게임화면에 그림A world out of time 루프 한 바퀴 == 틱 or frame 게임루프 측정 == 초당 프레임 수(fps)를 얻을 수 있다. 루프가 빠르면 부드럽고 빠른 화면, 느리면 반대 한 프레임에 얼마나 많은 작업을 하는가가 중요 코드가 실행되는 플랫폼의 속도 또한 중요 하드 웨어, os 등 Seconds per second 어떤 하드웨어에서라도 일정한 속도로 실행될 수 있도록 하는 것이 중요`The Pattern 게임 루프는 게임하는 내내 실행됨. 유저 입력을 처리한 뒤 게임 상태를 업데이트하고 게임화면을 렌더링한다. 시간 흐름에 따라 게임플레이 속도를 조절한다. When to Use It 게임에서는 안쓰는 경우는 거의 없음. 루프 코드에 따라 ‘엔진’ 과 ‘라이브러리’를 나눈다. 라이브러리: 게임 메인 루프를 들고 있으면서, 라이브러리 함수를 호출 엔진: 스스로가 루프를 들고 있으면서 사용자 코드를 호출Keep in Mind 최적화가 중요.You may need to coordinate with the platform’s event loop 그래픽 UI와 이벤트 루프가 들어있는 OS나 플랫폼에서는 애플리케이션 루프가 두개 있는 셈. 서로 잘맞아야함. 제어권을 가져와, 루프 하나만 남겨놓을 수 있음. 오래된 윈도우 API로 게임을 만든다면 main()에 게임루프를 두고, 루프안에서 PeekMessage()를 호출해 OS로부터 이벤트를 가져와 전달 가능. GetMessage와는 달리 PeekMessage는 유저 입력이 올때까지 기다리지 않음. 플랫폼에 따라 내부이벤트 무시하기 어려울 수 있음. 웹브라우저 == 이벤트 루프가 브라우저 실행 모델 깊숙한 곳에서 모든 것을 좌우하므로, 이것을 게임루프로 삼아야함. requestAnimationFrame()같은 걸 호출, 브라우저가 코드를 콜백으로 호출해주기를 대기. Sample Code 여러 게임 시스템을 진행.Run, run as fast as you canwhile (true){ processInput(); update(); render();} 가장 간단한 이 방식은 게임 실행 속도 제어 불가능고정 시간 간격: Take a little nap 60FPS로 돌린다면, 한 프레임에 16ms 그동안 게임 진행과 렌더링을 다 할 수 있다면, 프레임 레이트를 유지할 수 있다. 아래처럼 프레임 사이 남은 시간 대기 코드는 다음과 같음.while (true){ double start = getCurrentTime(); processInput(); update(); render(); sleep(start + MS_PER_FRAME - getCurrentTime());} sleep(): 게임이 너무 빨라지지 않게 대기 너무 느려지는 것은 막지 못함. 가변 시간 간격: One small step, one giant step 문제 업데이트할 때마다 정해진 만큼 게임 시간이 진행 업데이트하는 데에는 현실 세계의 시간이 어느 정도 걸림. 2 &amp;gt; 1 이면 게임은 느려짐. 한 번에 게임 시간을 16ms 이상 진행하면, 업데이트 횟수가 적어도 따라잡기 가능 실제 시간이 얼마나 지났는지에 따라 시간 간격을 조절하면 된다. 프레임이 오래 걸릴수록, 게임 간격을 길게 필요에 따라 업데이트 단계를 조절할 수 있다. 가변 시간 간격, 유동 시간 간격이라고 함.double lastTime = getCurrentTime();while (true){ double current = getCurrentTime(); double elapsed = current - lastTime; processInput(); update(elapsed); render(); lastTime = current;} 매 프레임마다 실제 시간이 얼마나 지났는지를 elapsed에 저장. 게임 상태를 업데이트할 때 elapsed를 같이 넘겨, 지난 시간만큼 게임월드 상태를 진행 고정시간간격: 매 프레임마다 총알 속도에 맞춰 총알이 움직임 가변시간간격: 속도와 지나간 시간을 곱해, 이동거리를 구함. 시간 간격이 커지면 총알을 더 많이 움직임. 장점 다양한 하드웨어에서 비슷한 속도로 게임이 돌아감. 더 빠른 하드웨어인 경우 더 부드러운 게임플레이.단점 게임이 비결정적, 불안정 비결정적: 버그 재현 힘들다. 부동소수점=&amp;gt; 반올림 오차 가능성 게임이 더 빨리 실행되면,오차가 더 크게 쌓임.(결국 PC에 따라 같은 총알의 위치가 달라짐.) 실시간으로 실행하기 위해 게임 물리 엔진은 실제 물리 법칙의 근사치를 취함. 근사치가 튐(blowing up)을 막기 위해, 감쇠(dumping)을 적용한다. 감쇠: 시간 간격에 맞춰 세심하게 조정해야함. 감쇠값이 바뀌다보면, 물리가 불안정해짐. 고정 시간 간격: Play catch up 렌더링: 가변시간 간격에 영향을 받지않음 때가 오면 렌더링할 뿐. 모션블러 같은 경우에는 영향 받지만, 미세한 차이 물리, AI등을 고정시간 + 렌더링 간격은 유연 =&amp;gt; 프로세서 낭비 줄임 루프 이후로 실제 시간이 얼마나 지났는지를 확인 게임의 현재가 실제 시간의 현재를 따라잡을 때까지 고정 시간 간격만큼 게임 시간을 여러 번 시뮬레이션. double previous = getCurrentTime();double lag = 0.0;while (true){ double current = getCurrentTime(); double elapsed = current - previous; previous = current; lag += elapsed; processInput(); while (lag &amp;gt;= MS_PER_UPDATE) { update(); lag -= MS_PER_UPDATE; } render();} 프레임 시작시 실제 시간이 얼마나 지났는지를 lag변수에 저장. 이 값은 실제 시간에 비해 게임 시간이 얼마나 뒤쳐졌는지를 의미. 고정 시간 간격 방식으로 루프를 돌며서, 실제 시간을 따라잡을 때까지 게임을 업데이트. 다 따라잡으면 렌더링하고 다시 루프를 실행. 시간 간격(MS_PER_UPDATE)은 더 이상 시각적 프레임 레이트가 아님. 얼마나 촘촘하게 업데이트할 지에 대한 값. 짧을수록 실제 시간을 따라잡기 더 오래걸림. 길수록 게임 플레이가 끊겨보임. 60FPS보다 더 빠르게 돌아가도록, 시간 간격을 충분히 짧게 잡아 좋은 PC에서 더 나은 시뮬레이션을 보여주도록하는게 이상적 시간 간격이 너무 짧으면 안됨. 가장 느린 하드웨어에서도 update()를 실행하는 데 걸리는 시간보다는 시간 간격이 커야함. 그렇지 않으면 게임 시간은 계속 뒤쳐짐. 내부 업데이트에 보호장치: 최대 업데이트 횟수 설정 렌더링을 뒤로 뺌 =&amp;gt; CPU 시간에 여유가 생김. 느린 PC: 화면 조금 끊김. 안전한 고정 시간 간격 =&amp;gt; 여러 hw에서 일정한 속도로 게임 시뮬 유니티의 MonoBehaviour::FixedUpdate() 가 이런 방식 자투리 시간 문제: Stuck in the middle 유저 입장에서는 두 업데이트 사이에 렌더링되는 경우가 종종 있음. 업데이트: 정확, 고정간격 / 렌더링: 가능할 때마다 문제점: 항상 업데이트 후에 렌더링 되는 게 아님. 이렇기 때문에 움직임이 튀어보임. 하지만, 렌더링할 때 업데이트 프레임이 시간적으로 얼마나 떨어져 있는지 lag값을 보고 알 수 있음. 0 &amp;lt; lag &amp;lt; 업데이트 시간일 경우 업데이트 루프를 빠져나옴. (lag == 다음 프레임까지 남은 시간) 렌더링 시간에 다음 값을 넘김.render(lag / MS_PER_UPDATE); lag을 MS_PER_UPDATE로 나누어 정규화한것. render는 0.0~1.0 사이의 값을 처리한다. 렌더러는 게임 객체들과 각각의 현재 속도를 안다. 이를 통해 보간(extrapolation) 예상 위치를 렌더링 보간하지 않는것 보다는 나음. Design Decisions 다루지 못한 내용: 화면 재생 빈도와의 동기화(refresh rate), 멀티스레딩, GPU 까지 고려할 경우 루프는 더 복잡해짐.게임 루프를 직접 관리? 플랫폼이 관리? 웹브라우저는 직접 만들 가능성이 거의 없음. 기존 게임엔진 또한 엔진 루프를 그대로 사용할 가능성이 높음플랫폼 이벤트 루프 사용 간단: 루프를 작성하고 최적화 고민 x 플랫폼에 잘맞음: 두 모델의 차이를 신경 쓰지 않아도됨. 시간을 제어할 수 없음: 대부분 게임을 고려하지 않고 설계 =&amp;gt; 느릴 가능성게임 엔진 루프 사용 코드 직접 작성 안함: 게임루프 만들기 쉽지 않음. 사소한 버그와 약간의 최적화에도 큰 영향 엔진루프에서 아쉬운게 있어도 건드릴 수 없음. 직접 만든 루프 완전한 제어 플랫폼과의 상호작용 OS나 프레임워크에 시간이 주어지도록, 가끔 제어권을 넘겨줘야함. 전력소모 문제 CPU를 가능한 적게 사용하도록 해야함. 한 프레임 후에 쉬어주도록해줘야 하는 성능 상한 최대한 빨리 실행 게임 루프에서 sleep호출 하지 않음 시간이 남으면 FPS나 그래픽 품질 더 높임 전력을 많이 사용프레임 레이트 제한 모바일게임 == 게임 플레이 품질에 더 집중 프레임 레이트에 상한(30FPS, 60FPS)을 둠. 게임 루프에서 프레임 시간 안에 할 일이 전부 끝나면, 나머지 시간동안 sleep 호출게임플레이 속도 제어 게임루프 = 비동기 유저 입력 + 시간 따라잡기 입력은 쉬움, 시간은 다루기 어려움. 다양한 플랫폼 지원이 핵심 동기화 없는 고정 시간 간격 방식 그냥 게임 루프를 최대한 빠르게. 간단. 게임 속도 == 하드웨어와 게임 복잡도에 영향동기화하는 고정 시간 간격 방식 루프 마지막에 지연 or 동기화 지점 =&amp;gt; 게임 시간 컨트롤 간단. 전력 효율 높음. 매 틱마다 좀 더 작업하기 보다 쉬어줘야 전력 아낌. 게임이 너무 빠르지 않음 게임이 너무 느려질 수 있다. 한 프레임에서 게임 업데이트 + 렌더링하는 게 오래걸리면 재생(playback)이 느려짐 업데이트와 렌더링을 분리하지 않음 시간을 따라잡기 위해 렌더링 프레임을 낮추지 않다 보니 게임 플레이가 느려짐 가변 시간 간격 방식 권장되지 않음. 너무 느리거나 너무 빠른 곳에서도 맞춰 플레이 가능. 게임 플레이를 불안정하고 비결정적으로 만든다.업데이트는 고정시간, 렌더링은 가변시간 적응력이 가장 높다. 실제 시간을 따라잡아야 한다면 렌더링 프레임을 낮춤. 너무 느리거나 너무 빨라도 잘 적응 실시간 업데이트 시, 뒤처질 일은 없음. 최고사양 HW =&amp;gt; 부드러운 화면 훨씬 복잡 구현 복잡 업데이트 시간 간격을 정할 때 고사양유저를 위해 최대한 짧게 하지만 저사양 유저가 너무 느려지지 않도록 주의 참고 Fix Your Timestep MonoBehaviour lifecycle은 복잡한 유니티 프레임워크 게임 루프를 그림으로 아주 잘 설명해놓은 글 출처gameloop" }, { "title": "[게임 프로그래밍 패턴] Squencing Patterns: Double Buffer", "url": "/posts/2022/02/23/06/52/pattern8/", "categories": "pattern", "tags": "", "date": "2022-02-23 06:52:46 +0900", "snippet": "순서 패턴(Squencing Patterns) 게임 월드에서 중요한 축: “시간” 게임 월드 시간을 위한 패턴들 게임 루프 패턴: 게임 월드 시간이 돌아가는 중심축 업데이트 메서드 패턴: 객체의 시간을 다루는 패턴 더블 버퍼 패턴: 순간적인 스냅샷들의 정면(facade)을 뒤로 숨김Double Buffer 의도: 여러 순차 작업의 결과 한번에 보여줌.MotivationHow computer graphics work (briefly) 모니터: 왼-&amp;gt;오 픽셀 그림. 프레임버퍼: 픽셀을 가져오는 곳 비디오 디스플레이는 프레임 버퍼를 반복해서 읽는다. 문제: 화면 찢김(tearing), 코드에서 픽셀을 입력하는 속도보다 비디오 드라이버가 앞지름. 문제 해결: 비디오 드라이버는 한번에 전체 픽셀을 다 읽어야함 프레임 버퍼 두개 =&amp;gt; 하나는 프레임에 보이는 것으로 GPU가 언제든지 읽을 수 있는 것. 화면 깜빡임에 맞춰 버퍼 변경 =&amp;gt; 테어링 문제 해결 -결 The Pattern 버퍼 클래스: 변경이 가능한 상태인 버퍼를 캡슐화 정보를 읽을 때: 항상 current버퍼에 접근. 정보를 쓸 때 next버퍼에 접근When to Use It 순차적으로 변경해야하는 상태 변경 도중에 접근 가능해야함. 바깥에서는 작업 중인 상태에 접근하지 못하도록 상태에 값을 쓰는 도중에도 기다리지 않고 바로 접근 가능해야할 때Keep in Mind 코드 전체에 미치는 영향이 적음.교체 연산 자체에 시간이 많이 걸림 교체: 원자적(atomic)이어야함. 교체 중에는 두 버퍼 모두에 접근 불가능 대부분 포인터만 변경, 하지만 혹시 모른다. 버퍼가 두개 필요 메모리 부담예제 단순한 그래픽 시스템class Framebuffer{public: Framebuffer() { clear(); } void clear() { for (int i = 0; i &amp;lt; WIDTH * HEIGHT; i++) { pixels_[i] = WHITE; } } void draw(int x, int y) { pixels_[(WIDTH * y) + x] = BLACK; } const char* getPixels() { return pixels_; }private: static const int WIDTH = 160; static const int HEIGHT = 120; char pixels_[WIDTH * HEIGHT];}; scene 클래스는 다음과 같다. draw()를 여러번 호출하여 버퍼에 원하는 그림을 그린다. class Scene{public: void draw() { buffer_.clear(); buffer_.draw(1, 1); buffer_.draw(4, 1); buffer_.draw(1, 3); buffer_.draw(2, 4); buffer_.draw(3, 4); buffer_.draw(4, 3); } Framebuffer&amp;amp; getBuffer() { return buffer_; }private: Framebuffer buffer_;}; 게임코드는 매 프레임마다 어떤 장면을 그려야 할지를 알려준다. getBuffer(): 비디오 드라이버에서 내부 버퍼에 접근할 수 있도록. draw() 중간에 드라이버가 픽셀버퍼전체를 읽을 수 있다. 플리커링 문제 발생 class Scene{public: Scene() : current_(&amp;amp;buffers_[0]), next_(&amp;amp;buffers_[1]) {} void draw() { next_-&amp;gt;clear(); next_-&amp;gt;draw(1, 1); // ... next_-&amp;gt;draw(4, 3); swap(); } Framebuffer&amp;amp; getBuffer() { return *current_; }private: void swap() { // Just switch the pointers. Framebuffer* temp = current_; current_ = next_; next_ = temp; } Framebuffer buffers_[2]; Framebuffer* current_; Framebuffer* next_;}; 위와 같이, 버퍼 두개, 포인터 스왑을 통해 해결가능.그래픽스 외의 활용법 변경 중인 상태에 접근하는 문제 해결 원인1: 다른 스레드나 인터럽트에서 상태에 접근하는 경우(그래픽스 예제) 원인2: 어떤 상태를 변경하는 코드가, 동시에 지금 변경하려는 상태를 읽는 경우. 물리나 인공지능같이 객체가 서로 상호작용할 때 이런 경우를 쉽게 볼 수 있다. Artificial unintelligence 슬랩스틱 코미디 기반 게임에 들어갈 행동 시스템을 만든다 가정. 무대 준비 완료 + 여러 actor가 몸개그 중 class Actor{public: Actor() : slapped_(false) {} virtual ~Actor() {} virtual void update() = 0; void reset() { slapped_ = false; } void slap() { slapped_ = true; } bool wasSlapped() { return slapped_; }private: bool slapped_;}; 배우를 위한 상위 클래스는 위와 같다. 매 프레임마다 update를 호출해 배우를 업데이트 해줘야 한다. 유저 입장에서는 모든 배우가 한 번에 업데이트되는 것처럼 보여야한다. 무대는 다음과 같다.class Stage{public: void add(Actor* actor, int index) { actors_[index] = actor; } void update() { for (int i = 0; i &amp;lt; NUM_ACTORS; i++) { actors_[i]-&amp;gt;update(); actors_[i]-&amp;gt;reset(); } }private: static const int NUM_ACTORS = 3; Actor* actors_[NUM_ACTORS];}; stage클래스는 배우를 추가 가능 관리하는 배우 전체를 업데이트할 수 있는 update()메서드를 제공. 내부적으로는 하나씩 업데이트됨. 딱 한번만 반응하기 위해, reset을 바로한다. Actor를 상속받는 구체 클래스 Comedian을 정의는 다음과 같다.class Comedian : public Actor{public: void face(Actor* actor) { facing_ = actor; } virtual void update() { if (wasSlapped()) facing_-&amp;gt;slap(); }private: Actor* facing_;}; 아래와 같이 서로를 바라보게하였다.Stage stage;Comedian* harry = new Comedian();Comedian* baldy = new Comedian();Comedian* chump = new Comedian();harry-&amp;gt;face(baldy);baldy-&amp;gt;face(chump);chump-&amp;gt;face(harry);stage.add(harry, 0);stage.add(baldy, 1);stage.add(chump, 2); Harry를 때리면 Stage 클래스의 update메서드는 한 레임만에 전체 액터에게 전파된다. harry-&amp;gt;slap();stage.update(); 하지만 harry의 순서를 바꾸면, 다른 결과가 나오게된다.stage.add(harry, 2);stage.add(baldy, 1);stage.add(chump, 0); harry가 마지막에 업데이트 되니, 전파는 일어나지 않는다. 쓰는 동시에 값을 읽기 때문에 발생하는 문제 결국, 업데이트 중 다른 것에 영향을 미침. 배치 순서에 따라 현 프레임에서 반응이 나타날 수 있고, 다음 프레임에서 반응이 나타날 수 있다. Buffered slaps ‘맞은’ 상태만을 버퍼에 저장하는 방법이 있음. reset 대신에 swap을 추가. 이제, 먼저 업데이트한 다음에 상태를 교체한다. class Actor{public: Actor() : currentSlapped_(false) {} virtual ~Actor() {} virtual void update() = 0; void swap() { // Swap the buffer. currentSlapped_ = nextSlapped_; // Clear the new &quot;next&quot; buffer. nextSlapped_ = false; } void slap() { nextSlapped_ = true; } bool wasSlapped() { return currentSlapped_; }private: bool currentSlapped_; bool nextSlapped_;};void Stage::update(){ for (int i = 0; i &amp;lt; NUM_ACTORS; i++) { actors_[i]-&amp;gt;update(); } for (int i = 0; i &amp;lt; NUM_ACTORS; i++) { actors_[i]-&amp;gt;swap(); }}디자인 결정버퍼를 어떻게 교체? 교체연산은 쓰기, 읽기 둘다 사용못하게 해야함. 최대한 빠르게 포인터, 레퍼런스 빠름. 외부코드는 버퍼에대한 포인터를 저장할 수 없다는 한계. 주기적으로 다른 버퍼를 읽어야함. 버퍼에 남아 있는 데이터는 바로 이전 프레임 데이터가 아닌 2프레임 전 데이터. 이전 프레임버퍼를 사용하는 고전적인 예: 모션블러. 모션블러효과: 현재 프레임 이미지에 이전 프레임 값을 살짝 섞어 실제 카메라에서 보이는 것처럼 이미지를 뭉개줌.버퍼끼리 데이터를 복사 유저가 다른 버퍼를 재지정하게 할 수 없다면, 복사해야함. 다음 버퍼에는 딱 한 프레임 전 데이터가 들어 있을 경우. 두 버퍼를 교체하는것보다 좋다. 교체시간이 오래걸림. 전체 복사를 다 복사하기 때문. 얼마나 정밀하게 버퍼링할 것? 버퍼가 어떻게 구성되어 있는가? 데이터 덩어리? 객체 컬렉션 안에 분산? 그래픽 예제: 전자 액터 예제: 후자 버퍼가 한 덩어리 간단히 교체 가능. 포인터 대입 두번만으로 버퍼 교체 가능 여러 객체가 각종 데이터 들고 있으면 교체가 더 느리다. 전체 객체 컬렉션을 순회하면서 교체해야함. 상대적 오프셋을 응용하면 최적화 가능. 아래 코드에서 static 함수이기 때문에 한번의 호출로 모든 객체의 상태를 변경할 수 있다. class Actor{public: static void init() { current_ = 0; } static void swap() { current_ = next(); } void slap() { slapped_[next()] = true; } bool wasSlapped() { return slapped_[current_]; }private: static int current_; static int next() { return 1 - current_; } bool slapped_[2];};출처" }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: State", "url": "/posts/2022/02/23/01/21/pattern7/", "categories": "pattern", "tags": "", "date": "2022-02-23 01:21:43 +0900", "snippet": "State 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴, 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임. 유한 상태 기계(FSM), 계층형 상태 기계, 푸시다운 오토마타 또한 다룸.We’ve All Been There 간단한 횡스크롤 플랫포머를 만든다고 가정. 주인공이 사용자 입력에 따라 반응하도록 구현해야한다.무작정 구현하면 코드는 복잡해진다. B버튼을 누르면 점프하는 코드는 다음과 같다. void Heroine::handleInput(Input input){ if (input == PRESS_B) { yVelocity_ = JUMP_VELOCITY; setGraphics(IMAGE_JUMP); }} 이 코드는 ‘공중 점프’를 허용한다.(계속 공중에 떠 있을 수 있다.) isJumping_ 필드를 추가하면 간단히 고칠 수 있다. (토글할 필요가 있다) void Heroine::handleInput(Input input){ if (input == PRESS_B) { if (!isJumping_) { isJumping_ = true; // Jump... } }} 주인공이 땅에 있을 때 아래 버튼을 누르면 엎드리고, 버튼을 떼면 다시 일어서는 기능은 다음과 같을 것이다. void Heroine::handleInput(Input input){ if (input == PRESS_B) { // Jump if not jumping... } else if (input == PRESS_DOWN) { if (!isJumping_) { setGraphics(IMAGE_DUCK); } } else if (input == RELEASE_DOWN) { setGraphics(IMAGE_STAND); }} 이 코드의 버그 엎드리기 위해 아래 버튼을 누른 뒤, B버튼을 눌러 엎드린 상태에서 점프하고나서 공중에서 아래버튼을 떼면, 점프 중에 땅에 서 있는 모습으로 보임. 플레그 변수가 더 필요하다. void Heroine::handleInput(Input input){ if (input == PRESS_B) { if (!isJumping_ &amp;amp;&amp;amp; !isDucking_) { // Jump... } } else if (input == PRESS_DOWN) { if (!isJumping_) { isDucking_ = true; setGraphics(IMAGE_DUCK); } } else if (input == RELEASE_DOWN) { if (isDucking_) { isDucking_ = false; setGraphics(IMAGE_STAND); } }} 점프 중, 아래 버튼을 눌러 내려찍기 공격을 할 수 있게 하는 코드는 다음과 같다. void Heroine::handleInput(Input input){ if (input == PRESS_B) { if (!isJumping_ &amp;amp;&amp;amp; !isDucking_) { // Jump... } } else if (input == PRESS_DOWN) { if (!isJumping_) { isDucking_ = true; setGraphics(IMAGE_DUCK); } else { isJumping_ = false; setGraphics(IMAGE_DIVE); } } else if (input == RELEASE_DOWN) { if (isDucking_) { // Stand... } }} 이번에도 버그가 생긴다. - 또 플래그 변수를 넣어야한다. 이런 식으로 코드를 건드리면 계속해서 망가진다. 좋은 개발자는 어떤 코드가 버그가 생기기 쉬운지에 대한 감각이 있다. 분기가 복잡하거나 상태가 변경 가능한 코드들은 버그가 쉽게 생긴다.Finite State Machines to the Rescue 위 에서 다룬 동작들을 플로차트로 그려보면 다음과 같다. 위와 같은 플로차트를 유한 상태 기계(FSM)이라 한다. FSM은 오토마타 이론에서 나왔다. 오토마타 중 튜링 기계가 유명하다. 핵심은 상태, 입력, 전이 가질 수 있는 ‘상태’가 한정: 서기, 점프, 엎드리기, 내려찍기 한번에 ‘한가지’ 상태만 될 수 있다.: 주인공은 점프와 동시에 서있을 수 없다. 동시에 두가지 상태가 되지 못하도록 막는게 FSM을 쓰는 이유 중 하나. ‘입력’이나 ‘이벤트’가 기계에 전달: 버튼 누르기와 버튼 떼기. 각 상태에는 입력에 따라 다음 상태로 바뀌는 ‘전이’가 있다.: 입력이 들어왔을 때, 현재 상태에 해당하는 전이가 있다면 전이가 가리키는 다음 상태로 변경된다. 서 있는 동안 아래 버튼을 누르면 엎드리기 상태로 전이한다. 현재 상태에서 들어온 입력에 대한 전이가 없을 경우 입력을 무시한다.Enums and Switches 위에서 다룬 Heroin 클래스의 문제점은, 불리언 변수 값 조합이 유효하지 않을 수 있다는 점이다. 점프와 엎드리기 동시에 참 불가. 여러 플래그 변수 중 하나만 참일 경우 열거형(enum)을 사용하는 것이 좋다. 열거형 사용 enum State{ STATE_STANDING, STATE_JUMPING, STATE_DUCKING, STATE_DIVING}; 먼저 상태에 따라 분기하게 했다. 이제 플래그 여러개 대신 state_ 필드 하나만 있어도 됨. void Heroine::handleInput(Input input){ switch (state_) { case STATE_STANDING: if (input == PRESS_B) { state_ = STATE_JUMPING; yVelocity_ = JUMP_VELOCITY; setGraphics(IMAGE_JUMP); } else if (input == PRESS_DOWN) { state_ = STATE_DUCKING; setGraphics(IMAGE_DUCK); } break; case STATE_JUMPING: if (input == PRESS_DOWN) { state_ = STATE_DIVING; setGraphics(IMAGE_DIVE); } break; case STATE_DUCKING: if (input == RELEASE_DOWN) { state_ = STATE_STANDING; setGraphics(IMAGE_STAND); } break; }} 분기 문을 다 없애진 못했지만, 업데이트해야 할 상태변수를 하나로 줄였고, 하나의 상태를 관리하는 코드는 한곳에 있다. 열거형은 상태 기계를 구현하는 가장 간단한 방법이다. 열거형만으로 부족할 수 있다. 이동을 구현하고, 엎드려있으면 기가 모여, 놓는 순간 특수 공격을 쏠 수 있게 만들면, 엎드려서 기를 모으는 시간 또한 기록해야한다. 이와 관련 있는 패턴: 매서드 패턴 chargeTime 추가 이를 위해 Heroin에 chargeTime_필드 추가 void Heroine::update(){ if (state_ == STATE_DUCKING) { chargeTime_++; if (chargeTime_ &amp;gt; MAX_CHARGE) { superBomb(); } }} 엎드릴 때마다 시간을 초기화해야하니 handleInput() 또한 수정해야한다. void Heroine::handleInput(Input input){ switch (state_) { case STATE_STANDING: if (input == PRESS_DOWN) { state_ = STATE_DUCKING; chargeTime_ = 0; setGraphics(IMAGE_DUCK); } // Handle other inputs... break; // Other states... }} 기 모으기 공격을 추가하기 위해 함수 두 개를 수정하고 chargeTime_을 추가했다. 이렇게 chargeTime_을 추가하는 것은 좋지 않다. 모든 코드와 데이터를 한곳에 모아둘 수 있는 게 낫다. The State Pattern 모든 분기문을 동적 디스패치(C++에서는 가상함수)로 바꾸려 하는 것은 과하다. 때로는 if문으로 충분 하지만 위의 예제라면, 객체지향, 상태 패턴을 사용하는게 좋다. A state interface 다중 선택문에 있던 동작을 인터페이스의 가상 메서드로.class HeroineState{public: virtual ~HeroineState() {} virtual void handleInput(Heroine&amp;amp; heroine, Input input) {} virtual void update(Heroine&amp;amp; heroine) {}};Classes for each state 상태별로 인터페이스를 구현하는 클래스 정의. 메서드: 어떤 행동을 하는지 정의. case 별로 클래스를 만든다. chargeTime_같은 경우 더 분명하게 보여준다.(엎드린 상태에서만 유의미)class DuckingState : public HeroineState{public: DuckingState() : chargeTime_(0) {} virtual void handleInput(Heroine&amp;amp; heroine, Input input) { if (input == RELEASE_DOWN) { // Change to standing state... heroine.setGraphics(IMAGE_STAND); } } virtual void update(Heroine&amp;amp; heroine) { chargeTime_++; if (chargeTime_ &amp;gt; MAX_CHARGE) { heroine.superBomb(); } }private: int chargeTime_;};Delegate to the state 주인공 클래스에 현재 상태 객체 포인터 추가, 상태 객체에 위임(다중 선택문 제거)class Heroine{public: virtual void handleInput(Input input) { state_-&amp;gt;handleInput(*this, input); } virtual void update() { state_-&amp;gt;update(*this); } // Other methods...private: HeroineState* state_;}; 상태 변경 == state_에 다른 객체 할당 전략패턴, 타입 객체 패턴과 비슷, 하위 객체에 동작을 위임하지만 의도에서 차이.(전략 == 일부 동작으로 부터 디커플링, 타입객체 == 같은 타입 객체 레퍼 공유, 상태 == 동작 변경)Where Are the State Objects? 상태를 변경: state_에 새로운 상태 객체 할당. 실제 인스턴스가 필요 Static states 상태 객체에 필드가 따로 없으면, 인스턴스는 하나만 있으면됨. 여러 FSM이 동시에 돌더라도 상태 기계는 다 같음. 필드가 없고, 메서드도 하나라면, 정적함수 사용가능. (state_는 함수 포인터)class HeroineState{public: static StandingState standing; static DuckingState ducking; static JumpingState jumping; static DivingState diving; // Other code...};if (input == PRESS_B){ heroine.state_ = &amp;amp;HeroineState::jumping; heroine.setGraphics(IMAGE_JUMP);}Instantiated states 정적 객체만으로 부족할 때 chargeTime_필드가 캐릭마다 다를 경우 전이할 때마다 상태 객체 생성 FSM이 상태별로 인스턴스를 가짐. 새로 할당하는 것 == 이전 상태 해제 void Heroine::handleInput(Input input){ HeroineState* state = state_-&amp;gt;handleInput(*this, input); if (state != NULL) { delete state_; state_ = state; }}HeroineState* StandingState::handleInput(Heroine&amp;amp; heroine, Input input){ if (input == PRESS_DOWN) { // Other code... return new DuckingState(); } // Stay in this state. return NULL;} 저자는 매번 상태 객체를 할당하기 위해 메모리와 CPU를 낭비하지 않아도 되는 정적 상태를 쓰는 편. 동적할당 메모리 단편화 =&amp;gt; 오브젝트 풀 패턴 Enter and Exit Actions 상태 패턴의 목표: 같은 상태에 대한 모든 동작과 데이터를 클래스 하나에 캡슐화하는 것HeroineState* DuckingState::handleInput(Heroine&amp;amp; heroine, Input input){ if (input == RELEASE_DOWN) { heroine.setGraphics(IMAGE_STAND); return new StandingState(); } // Other code...} 입장 기능을 추가하여 그래픽을 제어하도록할 수 있다.class StandingState : public HeroineState{public: virtual void enter(Heroine&amp;amp; heroine) { heroine.setGraphics(IMAGE_STAND); } // Other code...}; 주인공 클래스에서 새로운 상태에 들어 있는 enter함수를 호출하도록 상태 변경 코드를 수정.void Heroine::handleInput(Input input){ HeroineState* state = state_-&amp;gt;handleInput(*this, input); if (state != NULL) { delete state_; state_ = state; // Call the enter action on the new state. state_-&amp;gt;enter(*this); }} 이제 처음 코드를 다음과 같이 단순화할 수 있다.HeroineState* DuckingState::handleInput(Heroine&amp;amp; heroine, Input input){ if (input == RELEASE_DOWN) { return new StandingState(); } // Other code...} 주인공 클래스에서 상태를 변경하기만 하면 그 상태로 그래픽을 처리할 수 있다. 실제로는, 상태그래프에는 동일한 상태로 여러 번 전환된다. 이 때 이전에는 전이시 모든 곳에 중복코드를 넣지만 enter를 통해 그를 최소화한다. 상태가 새로운 상태로 교체되기 직전에 호출되는 퇴장 또한 이렇게 구현 가능하다.What’s the Catch? FSM의 장점은 동시에 단점 상태 기계는 엄격하게 제한된 구조를 강제함 복잡하고 얽힌 코드 정리 FSM에는 미리 정해높은 상태와 현상태만 하드코딩되어 있는 전이만 존재 FSM: 튜링완전하지 않음. 오토마타 이론은 추상 모델을 이용해 더 복잡한 문제를 계산한다. 튜링완전: 시스템이 튜링 기계를 구현할 수 있을 정도로 충분히 강력하다.Concurrent State Machines 총을 들 수 있게 만든다고 가정. 이 때 구현한 모든 동작이 돌아가게 해야하고 총도 쏠 수 있어야한다. FSM은 이 때 무장, 비무장으로 두 개 만들어야한다. 무기 추가 =&amp;gt; 계속 늘어남. 해결: 상태기계를 둘로 나눔. 무엇을 들고 있는가에 대한 상태 기계를 따로 정의. 주인공은 이를 각각 참조. class Heroine{ // Other code...private: HeroineState* state_; HeroineState* equipment_;}; 입력을 상태에 위임할 때 양쪽에 전달 첫 상태에서 입력을 씹어서 다음 상태 기계까지 입력이 가지 않도록 가능 void Heroine::handleInput(Input input){ state_-&amp;gt;handleInput(*this, input); equipment_-&amp;gt;handleInput(*this, input);} 각각의 상태가 서로 전혀 연관이 없으면 이 방법은 잘 들어맞는다. 여러 상태기계가 상호작용할 경우 바람직한 방법은 아니지만, 문제 해결가능Hierarchical State Machines 땅위에 있는 상태 등을 상속받아, 고유 동작 처리 계층형 상태 기계 상속받은 메서드를 오버라이드하는 것과 같음. 상속: 두 코드가 강하게 커플링 class OnGroundState : public HeroineState{public: virtual void handleInput(Heroine&amp;amp; heroine, Input input) { if (input == PRESS_B) { // Jump... } else if (input == PRESS_DOWN) { // Duck... } }};class DuckingState : public OnGroundState{public: virtual void handleInput(Heroine&amp;amp; heroine, Input input) { if (input == RELEASE_DOWN) { // Stand up... } else { // Didn&#39;t handle input, so walk up hierarchy. OnGroundState::handleInput(heroine, input); } }}; 메인 클래스에 상태를 하나만 두지 않고 상태 스택을 만들어 명시적으로 현재 상태의 상위 상태 연쇄를 모델링 할 수 있다. 현재 상태가 스택 최상위인 형태. 스택 위에서부터 아래로. Pushdown Automata 상태 스택을 활용하여 FSM을 확장하는 다른 방법 FSM에는 히스토리 개념이 없다. 직전 상태가 무엇인지 몰라 쉽게 돌아갈 수 없음. 어느 상태에서 공격을 했는지? 이전 상태로 되돌아가야함. 공격하기 이전의 상태를 저장하고 불러오는게 좋다. 이 때 푸시다운 오토마타를 이용한다. 푸시다운 오토마타: 상태를 스택으로 관리 FSM은 이전 상태를 덮어쓰고 새로운 상태로 전이하는 방식. 부가적인 명령어 두가지 새로운 상태를 스택에 push: 스택의 최상위 == 현재, 이전 상태는 그 밑에. 최상위 스택을 pop: 빠진 상태는 제거, 바로 밑 상태가 현재 총소기 상태를 구현할 때. 어떤 상태든 발사버튼 =&amp;gt; 총쏘기 스택에 넣 총 쏘기 애니메이션 끝 =&amp;gt; 스택에서 뺌 이전 상태가 됨. So How Useful Are They? FSM의 한계 게임 AI에서는 행동트리(behavior tree)나 계획 시스템(planning system)을 더 많이 쓰는 추세. 사용할만한 곳 내부 상태에 따라 객체 동작이 바뀔 때 이런 상태가 그다지 많지 않은 선택지로 분명하게 구분될 때 객체가 입력이나 이벤트에 따라 반응할 때 입력 처리, 메뉴 화면 전환, 문자 해석, 네트워크 프로토콜, 비동기 동작을 구현하는데 사용출처State" }, { "title": "[백준][C++] 11000: 강의실 배정(greedy)", "url": "/posts/2022/02/23/00/42/11000/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-02-23 00:42:35 +0900", "snippet": "문제11000: 강의실 배정풀이 이 문제는 그리디 알고리즘의 기초 문제인 회의실 배정 문제의 변형이다. 이 문제는 최소의 넓이를 구하는 문제이다. 여기서 넓이란, 사용하는 강의실의 개수를 말한다.최소 강의실 개수 강의실 개수가 최소이려면? 최대한 빽빽하게 시간을 잡으면된다. 즉, 강의 사이의 끝시간과 시작시간이 짧으면된다.정렬 시작과 끝을 짧게 만들기 위해서는 일단, 앞에서부터 차근차근 배정하는것이 좋다. 그러므로 시작시간을 기준으로 정렬을 했다. 자료구조 정렬된 리스트에서, 우리는 짧게 얇게 시간표를 만들어야한다. 그러기 위해서 따로 강의실 자료구조를 만들어 처리하는게 좋다. 그다음 하나하나씩 가져와 강의실 중 가장 빨리 끝나는 강의실 뒤에 강의를 넣는것이다. 이렇게하면 한 강의실에 최대한 많은 강의를 넣을 수 있다. 한 강의실에 최대한 많은 강의를 넣게되면 사용하는 강의실 개수 또한 최소화된다는 것 또한 생각해보면 알 수 있다. 그러므로 자동으로 정렬하는 자료구조인 map, set, priority queu 등을 사용해야한다. 증명? 이게 잘 작동할까? 시작시간을 기준으로 정렬했다. 그리고 순서대로 자료구조에 집어넣었다. 그리고 가장 빨리 끝나는 강의실 뒤에 이어 붙였다. 이 때 사실 가장 빨리 끝나는 강의실이 아니더라도 이어 붙일 수 있는 아무 강의실이나 이어 붙여도 된다. 이후의 강의들은 시작시간이 더 나중이기 때문에 현재 고민 중인 강의실은 전부 선택할 수 있기 때문이다. 만약 끝 시각을 기준으로 정렬하게되면, 이게 망가진다. 이후의 강의들의 시작시간이 더 앞서있어서 못 이어붙일 수 있게되기 때문이다. 그러므로 사실 아무 강의실에다 집어넣을 수 있지만 가장 빨리 끝나는 곳에 넣게되면, 그리디 문제에서 흔히 말하는 손해는 없기 때문에, 이는 잘 작동하는 것이다. 코드int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T; cin &amp;gt;&amp;gt; T; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; vp(T); for (int i = 0; i &amp;lt; T; i++) { cin &amp;gt;&amp;gt; vp[i].first &amp;gt;&amp;gt; vp[i].second; } sort(vp.begin(), vp.end()); priority_queue&amp;lt;int&amp;gt; pq; int ans = 1; pq.push(-vp[0].second); for (int i = 1; i &amp;lt; vp.size(); i++) { if(-pq.top() &amp;lt;= vp[i].first) { pq.pop(); } pq.push(-vp[i].second); } cout &amp;lt;&amp;lt; pq.size();}반성 처음에 map을 사용하여 문제를 해결하려고 했다. map을 사용할 때, 중복된것을 처리해야하는데, 그렇지 않고 size() 를 답으로 제출하니 계속 틀렸었다. 무엇을 답으로 내야하는지 잊어버린것이다. map을 사용하려면 map에 추가할 때 소수점 자리수를 추가하여 전부 다른 값이 오도록하거나, 키를 적절히 제거한 후 second 값들을 전부 더해야한다. " }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: Singleton", "url": "/posts/2022/02/22/06/18/pattern6/", "categories": "pattern", "tags": "", "date": "2022-02-22 06:18:34 +0900", "snippet": "Singleton 오직 한 개의 클래스 인스턴스만을 갖도록 보장, 이에 대한 전역적인 접근점 제공. 저자는 이번 장에서는 어떻게 하면 이 패턴을 안 쓸 수 있을지를 설명한다. 이 패턴은 단점이 더 많다. 인스턴스에 접근하는데 싱글턴 즉, 전역 변수는 쉬운 해결책이다.The Singleton Design PatternRestricting a class to one instance 인스턴스가 여러 개면 제대로 작동하지 않는 상황이 종종 있다. 외부 시스템과 상호작용하면서, 전역 상태를 관리하는 클래스 같은 게 그렇다. 싱글턴으로 만들면, 클래스가 인스턴스를 하나만 가지도록 컴파일 단계에서 강제할 수 있다. Providing a global point of access 로깅, 콘텐츠 로깅, 게임 저장 등 여러 내부 시스템에서 파일 시스템 래퍼 클래스를 사용한다. 파일 시스템 클래스 인스턴스를 따로 생성할 수 없으면, 싱글턴을 사용하여 해결할 수 있다, 누구든지, 어디서든 인스턴스에 접근 가능=&amp;gt; 싱글턴. 구현은 다음과 같다.class FileSystem{public: static FileSystem&amp;amp; instance() { // Lazy initialize. if (instance_ == NULL) instance_ = new FileSystem(); return *instance_; }private: FileSystem() {} static FileSystem* instance_;}; instance_ 정적 멤버 변수는 클래스 인스턴스를 저장한다. 생성자가 private이므로 오직 내부에서만 생성가능하다. instance()는 필요할 때까지 인스턴스 초기화를 지연한다. 요즘 구현은 이렇다.class FileSystem{public: static FileSystem&amp;amp; instance() { static FileSystem *instance = new FileSystem(); return *instance; }private: FileSystem() {}}; C++11에서는 정적 지역 변수 초기화 코드가 멀티스레드 환경에서 딱 한 번 실행되어야한다. 즉, 위와 같이 구현하면 초기화는 스레드 안전하다. Why We Use It장점 한 번도 사용하지 않으면 인스턴스를 생성하지 않는다. CPU와 메모리 사용량 감소. 런타임에 초기화 싱글턴의 대안 중 하나인 정적 멤버 변수 정적 멤버 변수는 자동 초기화 문제가 있다. 즉, 프로그램 실행 후 알 수 있는 정보를 활용할 수 없음. 정적 변수 초기화 순서 또한 컴파일러에서 보장하지 않는다.(순환 의존만 없다면, 싱글턴의 게으른 초기화는 이를 해결) 마이어스 싱글턴으로 자동 초기화 걱정없이 정적변수로 싱글턴을 만들 수 있다. 싱글턴을 상속할 수 있다. 단위 테스트용 모의 객체(Mock object)를 만들 때 유용하다. 추상 인터페이스 =&amp;gt; 플랫폼별 클래스 Why We Regret Using It 길게 보면 비용을 지불하게된다. 단점은 다음과 같다.It’s a global variable 전역 변수와 정적 변수를 많이 사용하게 되면, 게임이 점차 커지고 복잡해짐에 따라 설계와 유지보수가 병목이 된다. 하드웨어 한계보다 생산성한계 때문에 출시가 늦어질 가능성이 더 높아졌다.전역 변수의 단점 코드를 이해하기 어렵게한다. 전역변수를 건드리지 않으면, 함수코드와 매개변수만 보면된다. 컴퓨터 과학에서는 전역 상태에 접근하거나 수정하지 않는 함수를 ‘pure’ 함수라고 한다. 순수함수는 이해하기 쉽고 컴파일러가 쉽게 최적화할 수 있다.=&amp;gt; 순수 함수형 언어: 하스켈 전역 변수는 커플링을 조장한다. 인스턴스에 대한 접근을 통제함으로써 커플링을 통제할 수 있다. 전역 변수는 멀티스레딩 같은 동시성 프로그래밍에 알맞지 않다. 교착상태, 경쟁 상태 등 스레드 동기화 버그가 생기기 쉽다. 싱글턴 == 클래스로 캡슐화된 전역 상태It solves two problems even when you just have one 싱글턴은 두 문제를 해결한다. 보통 ‘전역 접근’이 싱글턴 패턴을 선택하는 이유이다. ex)로깅 클래스를 생각해보자 모든 함수에 Log 클래스 인스턴스를 추가하는 것은 번잡하고 읽기 어렵다. 싱글턴을 사용하면 되지만, 하나만 만들 수 있다는 제한이 생긴다. 로그 파일을 나누어서 저장하는게 찾기 쉽다. 여러 파일에 나누면, 분야별로 로거를 만들어야한다. Log 가 싱글턴이면 이럴 수 없다. Log::instance().write(&quot;Some event.&quot;); 이제 Log 클래스를 사용하는 모든 코드를 손봐야한다. Lazy initialization takes control away from you 제어 불가능한 2가지 이유 게임에서 게으른 초기화는 좋지 않다. 게임 도중에 화면 프레임이 떨어질 수 있다. 메모리 단편화(fragmentation)를 막기 위해 힙에 메모리를 할당하는 방식을 세밀하게 제어하는게 보통이다. 적절한 초기화 시점을 찾아야한다. 대신 아래와 같이 구현하면 해결할 수 있다.class FileSystem{public: static FileSystem&amp;amp; instance() { return instance_; }private: FileSystem() {} static FileSystem instance_;}; 대신 그냥 전역 변수보다 나은점을 몇개 포기해야한다. 정적 인스턴스를 사용하면 다형성을 사용할 수 없다. 클래스는 정적 객체 초기화 시점에서 생성된다. 인스턴스가 필요없어도 메모리를 해제할 숭 없다. 이는 정적 클래스와 같다. 차라리 정적 함수를 사용하는것이 낫다. 더 분명하게 정적 메모리에 접근한다는것을 보여줌 Foo::bar() What We Can Do InsteadSee if you need the class at all 클래스가 꼭 필요한가? 싱글턴은 보통 객체 관리용으로 존재한다.(manager, system, engine) 서툴게 만든 싱글턴은 다른 클래스에 기능을 더해주는 ‘helper’인 경우가 많음. 객체 스스로를 챙기게 하는 게 바로 OOP 관리자 클래스를 없애고, 합침. To limit a class to a single instance 전역접근: 구조가 취약하짐 특정 코드에서만 접근하게 or private 멤버 변수 class FileSystem{public: FileSystem() { assert(!instantiated_); instantiated_ = true; } ~FileSystem() { instantiated_ = false; }private: static bool instantiated_;};bool FileSystem::instantiated_ = false; 이 클래스는 어디서나 인스턴스를 생성할 수 있다. 하지만, 인스턴스가 둘 이상 되는 순간 단언문에 걸린다. 이는 하나의 인스턴스를 보장한다. 런타임에 인스턴스 개수를 확인한다는게 단점. 단언문: 코드에 제약 To provide convenient access to an instance 쉬운접근성: 원치 않는 곳에서도 쉽게 접근할 수 있다는 비용 변수는 최대한 적은 범위로 노출하는게 좋다. 기억해야할 코드양이 줄어든다. Pass it in 객체를 넘겨주는것이 가장 쉬우면서 최선인 경우 “dependency injection” 이라고 부름, 필요로하는 의존 객체를 전역에서 찾는 대신 매개변수로 받아 사용하는 방식(의존성 주입) ex)객체를 렌더링하는 함수를 생각해보자 렌더링하려면 렌더링 상태를 담고 있는 그래픽 디바이스 대표 객체에 접근할 수 있어야 한다. 이럴 때, 일반적으로 모든 렌더링 함수에서 context 같은 이름의 매개변수를 받음. 하지만 로그같은 경우, 핵심이 아니기 때문에 인수에 추가하기 어색함. 로그 == 횡단 관심사(cross-cutting concern), 이를 깔끔하게 다루는 것은 구조를 잡을 때 계속 고민해야 할 문제, 정적 타입 언어에서 특히 그럼, 관점지향 프로그래밍의 등장 이유 Get it from the base class 많은 게임에서 클래스를 대부분 한 단계만 상속할 정도로 상속 구조를 얕고 넓게 가져간다. ‘leaf’에 해당하는 하위클래스가 대부분 많은 클래스에서 같은 객체, 즉 GameObject 상위 클래스의 객체에 접근가능하다. class GameObject{protected: Log&amp;amp; getLog() { return log_; }private: static Log&amp;amp; log_;};class Enemy : public GameObject{ void doSomething() { getLog().write(&quot;I can log!&quot;); }}; 위처럼 구현하면, 로그 객체에 접근할 수 있다. protected 매서드를 활용해 구현하는 방식은 하위 클래스 샌드박스 패턴에서 확인할 수 있다. GameObject가 생성해, 정적 인스턴스로 들고 있는것이 가장 쉽다. 아니면 Log 객체를 얻을 수 있는 초기화 함수 제공, 서비스 중개자 패턴을 사용해도 좋다.Get it from something already global. 전역 상태를 모두 제거하는 것은 어렵다. 결국에는 Game이나 World같이 전체 게임 상태를 관리하는 전역 객체와 커플링되어 있다. 기존 전역 객체에 빌붙는 방법 Log, FileSystem, Audio, Player를 각각 싱글턴으로 만드는 대신 다음과 같은 코드를 작성할 수 있다. class Game{public: static Game&amp;amp; instance() { return instance_; } // Functions to set log_, et. al. ... Log&amp;amp; getLog() { return *log_; } FileSystem&amp;amp; getFileSystem() { return *fileSystem_; } AudioPlayer&amp;amp; getAudioPlayer() { return *audioPlayer_; }private: static Game instance_; Log *log_; FileSystem *fileSystem_; AudioPlayer *audioPlayer_;}; 순수주의자들에 의하면 디미터의 법칙에 위배된다고 한다. 디미터의 법칙: 다른 객체가 어떠한 자료를 갖고 있는지 속사정을 몰라야한다는 것을 의미. 이제 Game 클래스 하나만 전역에서 접근할 수 있다. 다른 시스템에 접근하려면 다음 함수를 호출하면 된다. Game::instance().getAudioPlayer().play(VERY_LOUD_BANG); 나중에 Game 인스턴스를 여러 개 지원하도록 구조를 바꿔도, Log 등은 영향받지 않는다. 더 많은 코드가 Game과 커플링된다는 단점이 생김. 이 문제는 여러 방법을 조합해 해결할 수 있다. Game클래스를 모르는 코드는 넘겨주거나, 상위 클래스로부터 얻기 등을 통해야한다. Get it from a Service Locator 여러 객체에 대한 전역 접근을 제공하는 용도로만 사용하는 클래스를 따로 정의하는 방법도 있다. 이는 서비스 중개자 패턴에서 다룬다.What’s Left for Singleton 진짜 싱글턴 패턴이 필요한 때 게임에 그대로 적용하기에는 어렵다. 인스턴스 하나 제한 =&amp;gt; 정적 클래스 클래스 생성자에 정적 플래그 =&amp;gt; 런타임에 인스턴스 개수 검사 하위 클래스 샌드박스 패턴: 클래스가 같은 인스턴스들이 공용 상태를 전역으로 만들지 않고도 접근할 수 있는 방법을 제공 서비스 중개자 패턴: 객체를 전역으로 접근할 수 있게 하되, 객체를 훨씬 유연하게 설정할 수 있는 방법을 제공 출처singleton디미터의 법칙" }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: Prototype", "url": "/posts/2022/02/22/03/48/pattern5/", "categories": "pattern", "tags": "", "date": "2022-02-22 03:48:10 +0900", "snippet": "PrototypeThe Prototype Design Pattern Spawner 를 통해 Monster가 생성된다고 가정하자. 이 Spawner는 Monster 종류마다 따로 있다. - 이 때 brute-force로 구현하고자하면 아래와 같은 상속구조를 가지도록 할 수 있다. 프로토타입으로 이를 구현하면, 이를 좀 간결하게 구현할 수 있다. 어떤 객체가 자기와 비슷한 객체를 스폰할 수 있게된다. Monster 객체를 자신과 비슷한 객체를 생성하는 프로토타입 객체로 만드는것. class Monster{public: virtual ~Monster() {} virtual Monster* clone() = 0; // Other stuff...}; Monster 하위 클래스에서, 새 객체를 리턴하도록 구현해야한다.class Ghost : public Monster {public: Ghost(int health, int speed) : health_(health), speed_(speed) {} virtual Monster* clone() { return new Ghost(health_, speed_); }private: int health_; int speed_;}; 이를 상속받는 클래스를 사용하면, 이제 종류별로 만들 필요 없이 하나만 만들면 된다.class Spawner{public: Spawner(Monster* prototype) : prototype_(prototype) {} Monster* spawnMonster() { return prototype_-&amp;gt;clone(); }private: Monster* prototype_;}; Spawner는 Monster 객체를 생산하는 역할만 한다. 아래와 같이 사용할 수 있다.Monster* ghostPrototype = new Ghost(15, 3);Spawner* ghostSpawner = new Spawner(ghostPrototype); 장점 클래스와 상태를 클론한다. 프로토타입으로 사용하는 객체를 잘 설정하면, 여러 상태를 가진 몬스터(빠른, 약한, 강한)를 생성하는 스포너를 만들 수 있다. How well does it work? 깊은 복사(deep clone), 얕은 복사(shallow clone) 등 구현할 때 생각할만한 것들이 많다. 요즘 나오는 게임엔진은 이처럼 몬스터마다 클래스를 따로 만들지 않는다. 클래스 상속구조가 복잡하면, 유지보수가 힘들다. 요즘은 Component 와 Type Object을 사용하여 각각의 클래스를 만들지 않고 다양한 종류의 entity를 모델링한다. Spawn functions 각 몬스터마다 별도의 스포너 클래스를 만드는 대신 스폰 함수를 만들 수 있다.Monster* spawnGhost(){ return new Ghost();} 몬스터 종류마다 클래스를 만드는 것보다 코드가 적다.// 함수포인터 typedef : https://stackoverflow.com/questions/4295432/typedef-function-pointertypedef Monster* (*SpawnCallback)();class Spawner{public: Spawner(SpawnCallback spawn) : spawn_(spawn) {} Monster* spawnMonster() { return spawn_(); }private: SpawnCallback spawn_;}; 다음과 같이 객체를 생성한다.Spawner* ghostSpawner = new Spawner(spawnGhost);Templates 특정 몬스터 클래스를 생성하는 함수들을 하드코딩하기 싫다면, 몬스터 클래스를 템플릿 타입 매개변수로 전달하면된다.class Spawner{public: virtual ~Spawner() {} virtual Monster* spawnMonster() = 0;};template &amp;lt;class T&amp;gt;class SpawnerFor : public Spawner{public: virtual Monster* spawnMonster() { return new T(); }}; 아래와 같이 사용할 수 있다.Spawner* ghostSpawner = new SpawnerFor&amp;lt;Ghost&amp;gt;();First-class types C++ 의 타입들은 first-class가 아니라 위처럼 타입을 넘겨야한다. JS, python, ruby등과 같은 동적 타입 언어(dynamically-typed language)는 더 직접적으로 해결할 수 있다. 그냥 원하는 몬스터를 런타임 객체를 그냥 전달. 사실 저자는 이 디자인 패턴이 이상적으로 사용할 수 있는 곳이 없다고 생각한다. 저자는 언어 패러다임으로서의 프로토타입에대해 이후 기술한다.The Prototype Language Paradigm OOP가 데이터와 코드를 묶어주는 ‘객체’를 직접 정의할 수 있게 한다. 상태와 동작을 함께 묶는것. Self 셀프는 클래스는 없지만 OOP에서 할 수 있는걸 다 할 수 있는 언어이다. 클래스 기반 언어보다 더 객체 지향이다. 클래스기반 언어 상태가 인스턴스 안에 들어있다. 동작은 클래스에 있다.(메서드 호출 시 인스턴스의 클래스를 찾음) 상태와 메서드는 다르다. 셀프에는 이런 구별이 없다. - 무엇이든 객체에서 바로 찾을 수 있다. - 인스턴스는 상태와 동작 둘다 가짐. C++에서는 가상 메서드를 호출할 때, 먼저 인스턴스에서 vtable 포인터를 구하고, 다시 vtable로부터 메서드를 찾는다. vtable: 컴파일 시 가상함수가 정의된 클래스가 있으면, 가상 함수 테이블이 만들어져, 바이너리 ‘rdata’ 영역에 기록되며, 해당 클래스로 만들어진 객체에서 함수를 호출할 때 해당 클래스의 vtable을 참조해서 함수를 호출한다. 클래스 기반 언어 약간의 단점: 상속 장점: 다형성을 통한 코드 재사용과 중복 코드 최소화 셀프에서는 클래스의 장점을 얻을 수 있는 위임(delegation) 개념이 있다. 해당 객체에 필드나 메서드가 없으면, 상위(parent) 객체를 찾는다. 상위 객체는 그냥 다른 객체 레퍼런스 상위레벨에서 찾는걸 계속 반복한다. 즉, 위임하는것을 반복한다. 클래스 == 자기 자신의 인스턴스 factory 셀프에서는 프로토타입과 같이 복제(clone)한다. 즉, 모든 객체가 프로토타입 디자인 패턴을 지원하는것. How did it go? 언어를 구현하는건 비교적 쉽지만 사용자는 사용하기 복잡하다. 이해하기 어려움. What about JavaScript? 자스는 프로토타입 기반. 셀프로부터 영감 받아 만들어진것. 객체 == 아무 속성 값이나 가짐 속성 == 필드나 메서드(필드로서 저장된 함수) 객체 == ‘프로토타입’이라고 부르는 다른 객체를 지정 가능 자기 자신에 없는 필드를 프로토타입에 위임 가능 하지만 클래스 기반 언어에 더 가까움. 복제(clone) 기능이 없기 때문. 자스는 자료형을 정의하는 객체로부터 new를 호출하는 생성자 함수를 통해 객체를 생성한다. 상태는 인스턴스 그 자체에 저장한다. 동작은 자료형이 같은 객체 모두가 공유하는 메서드 집합을 대표하는 별도 객체인 프로토타입에 저장되고, 위임을 통해 간접 접근됨.Prototypes for Data Modeling 사실상 프로토타입은 사용하기 어려움. 옛날에는 모든걸 절차적으로 생성했다.(용량을 줄이기 위해) 요즘 게임 콘텐츠는 모두 데이터에 정의됨. 프로그래밍 언어를 사용하는 이유: 복잡성을 제어할 수 있는 수단을 가지고 있음. 게임 데이터도 규모가 일정 이상되면, 코드와 비슷한 기능이 필요하다. 데이터 모델링, 프로토타입과 위임을 활용해 데이터를 재사용하는 기법 데이터 몬스터와 아이템 속성을 파일 어딘가에 정의한다고 해보자. Json을 많이 사용함. 키/값 구조로 이루어진 데이터 개체로 맵, 속성목록(property bag) 라고 불림 데이터 개체 관련 용어 =&amp;gt; 범용 디자인 패턴 아래와 같이 몬스터 구성할 수 있다. { &quot;name&quot;: &quot;goblin grunt&quot;, &quot;minHealth&quot;: 20, &quot;maxHealth&quot;: 30, &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;], &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]}{ &quot;name&quot;: &quot;goblin wizard&quot;, &quot;minHealth&quot;: 20, &quot;maxHealth&quot;: 30, &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;], &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;], &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]}{ &quot;name&quot;: &quot;goblin archer&quot;, &quot;minHealth&quot;: 20, &quot;maxHealth&quot;: 30, &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;], &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;], &quot;attacks&quot;: [&quot;short bow&quot;]} 이러면 개체에 중복이 많다. 유지보수를 어렵게하는 원인 JSON에는 추상 자료형이라는 개념이 없다. 객체에 ‘프로토타입’필드가 있어서, 여기에서 위임하는 다른 객체의 이름을 찾을 수 있다고 가정하자. 첫 번째 객체에서 원하는 속성이 없으면, 프로토타입 필드가 가리키는 객체에서 대신찾는다. 즉, 프로토타입 필드는 실제 데이터가 아닌 메타데이터이다. 이제 아래와 같이 단순하게 만들 수 있다.{ &quot;name&quot;: &quot;goblin grunt&quot;, &quot;minHealth&quot;: 20, &quot;maxHealth&quot;: 30, &quot;resists&quot;: [&quot;cold&quot;, &quot;poison&quot;], &quot;weaknesses&quot;: [&quot;fire&quot;, &quot;light&quot;]}{ &quot;name&quot;: &quot;goblin wizard&quot;, &quot;prototype&quot;: &quot;goblin grunt&quot;, &quot;spells&quot;: [&quot;fire ball&quot;, &quot;lightning bolt&quot;]}{ &quot;name&quot;: &quot;goblin archer&quot;, &quot;prototype&quot;: &quot;goblin grunt&quot;, &quot;attacks&quot;: [&quot;short bow&quot;]} 이제 반복 입력할 필요가 없다. 일회성 특수 개체가 자주 나오는 게임에 잘맞는 방식이다. 보스와 유니크 아이템은 일반 몹과 아이템을 약간 다듬어 만들 때가 많으므로, 프로토타입 방식의 위임을 사용하기 좋다.(조금 더 게임을 풍성하게)출처Prototypevtable" }, { "title": "[note] mediapipe와 ipc", "url": "/posts/2022/02/21/23/58/ipc1/", "categories": "note", "tags": "note", "date": "2022-02-21 23:58:30 +0900", "snippet": "목차 목차 1. mediapipe 1.1. opencv camera 1.2. mediapipe index 1.2.1. MAX_NUM_HANDS 1.2.2. MULTI_HAND_LANDMARKS 2. ipc 2.1. winAPI C++ 2.1.1. CreateFileMapping 2.1.1.1. fdwProtect 2.1.1.2. dwMaximumSizeHigh, Low 2.1.1.3. pszName 2.1.1.4. CreateFileMapping: example 2.1.2. MapViewOfFile 2.1.2.1. dwDesiredAccess 2.1.2.2. offset 2.1.2.3. MapViewOfFile: example 2.1.3. UnmapViewOfFile 2.1.4. CloseHandle 2.2. boost-interprocess C++ 2.2.1. shared_memory_object 2.2.2. mapped_region() 2.2.3. region.get_address() 2.2.3.1.write 2.2.3.2. read 2.2.4. remove() 2.2.5. remove_shared_memory_on_destroy() 2.2.6. managed_shared_memory 2.2.7. atomic_func() 2.3. mmap python 2.4. sysv_ipc python 3. 참고1. mediapipe1.1. opencv cameracap = cv2.VideoCapture(0)width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)print(&#39;original size: %d, %d&#39; % (width, height))cap.set(cv2.CAP_PROP_FRAME_WIDTH, width/3)cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height/3)width = cap.get(cv2.CAP_PROP_FRAME_WIDTH)height = cap.get(cv2.CAP_PROP_FRAME_HEIGHT)print(&#39;changed size: %d, %d&#39; % (width, height))1.2. mediapipe index1.2.1. MAX_NUM_HANDS 감지할 손의 최대 개수with mp_hands.Hands( model_complexity=0, max_num_hands=1, min_detection_confidence=0.5, min_tracking_confidence=0.5) as hands:1.2.2. MULTI_HAND_LANDMARKS 21개의 hand landmarks 각 landmark의 normalized x, y, 수 z: depth, 손목의 깊이를 원점으로, 랜드마크 깊이를 나타냄, 값이 작을 수록 카메라에 가까움 x와 거의 같은 스케일2. ipc ipc은 프로세스가 프로세스와 통신하는 방법이다. sysv, posix 두 표준이 있다. 간단하게 sysv는 정수키값을 사용하는 방식이고, posix는 이름 string을 사용하는 방식이다. 여러 종류의 ipc 기법들이 있지만 공유 메모리를 사용하였다.2.1. winAPI C++출처 메모리 맵 파일: 가상 메모리처럼 프로세스 주소 공간을 예약 예약한 영역에 물리 저장소를 커밋하는 기능 가상 메모리와의 차이점: 시스템의 페이징 파일을 사용하는 대신 디스크 상에 존재하는 어떤 파일이라도 물리 저장소로 사용 가능 다른 프로세스간의 데이터를 공유할 수 있게 해준다.(IPC) 파일을 마치 메모리인 것처럼 사용 대용량 파일을 한꺼번에 메모리에 올려 고성능 I/O 참고: 파일 대신 다음과 같은 구조체를 사용하여 공유할 수 있다.typedef struct{ void *hFileMap; void *pData; char MapName[256]; size_t Size;} SharedMemory; 할당 CreateFileMapping: 파일의 크기, 접근 방식 =&amp;gt; 파일 매핑 커널 오브젝트 생성 MapViewOfFile: 프로세스의 주소 공간에 파일 매핑 오브젝트의 전체나 일부를 매핑 참고: CreateFile = 메모리 맵 파일로 사용할 디스크 상의 파일 생성, 열기 해제 UnMapViewOfFile: 프로세스의 주소 공간으로부터 파일 매핑 오브젝트의 매핑을 해제 CloseHandle:파일 커널 매핑 오브젝트, 파일 커널 오브젝트 닫기2.1.1. CreateFileMappingHANDLE CreateFileMapping( HANDLE hFile, // 물리 저장소로 사용할 파일의 핸들(CreateFile시) PSECURITY_ATTRIBUTES psa, // 커널 오브젝트의 보안 관련 파라미터 DWORD fdwProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, PCTSTR pszName);2.1.1.1. fdwProtect PAGE_WRITECOPY: Copy-on-write, 새로운 페이지로 복사한 후 쓰기 PAGE_READONLY: GENERIC_READ 보호 속성으로 설정 - PAGE_READWRITE: GENERIC_READ|GENERIC_WRITE 로 설정2.1.1.2. dwMaximumSizeHigh, Low 매핑할 파일의 최대 크기 high: 매핑할 범위를 지정하는 상위 바이트 low: 매핑할 범위를 지정하는 하위 바이트 64비트: 4GB보다 작을 경우 dwMaximumSizeHigh는 항상 0, high를 설정하여 그 이상의 크기도 핸들가능 32비트: 2GB까지만 가능? 매핑 파일로 지정한 파일의 크기가 기준이면, 두 파라미터에 02.1.1.3. pszName 고유한 객체 이름 부여 (이를 통해 다른 프로세스가 접근 가능)2.1.1.4. CreateFileMapping: exampleshm-&amp;gt;hFileMap = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, shm-&amp;gt;Size, shm-&amp;gt;MapName)2.1.2. MapViewOfFile MapViewOfFile: 파일을 주소공간에 매핑할 때 전체를 한번에 할 수 있고, 일부분만 할 수 있다. 이렇게 매핑된 영역을 view 라 한다. 파일의 데이터에 접근하기 위한 영역을 프로세스 주소 공간에 확보하는 커밋단계 파일 매핑 오브젝트의 전체 크기는 고려 x, 단지 view에 필요한 크기만 고려 함수 성공시 매핑된 뷰의 시작주소 반환(void형 타입, 실패시 NULL)PVOID MapViewOfFile( HANDLE hFileMappingObject, // createFileMapping으로 얻은 핸들 DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, // offset DWORD dwFileOffsetLow, // offset DWORD dwNumberOfBytesToMap // 얼마만큼 매핑할것인지 );2.1.2.1. dwDesiredAccess FILE_MAP_READ: createFileMapping에서 PAGE_READONLY FILE_MAP_WRITE: createFileMapping에서 PAGE_READWRITE FILE_MAP_COPY: 새로운 페이지에서 데이터 쓰기 FILE_MAP_EXECUTE: 데이터를 코드로 수행 FILE_MAP_ALL_ACCESS: READ WRITE COPY 2.1.2.2. offset 반드시 시스템 할당 단위의 배수 (64KB) dwNumberOfBytesToMap 이 0일 경우, offset으로부터 파일의 끝까지를 view로2.1.2.3. MapViewOfFile: exampleshm-&amp;gt;pData = MapViewOfFile( shm-&amp;gt;hFileMap, FILE_MAP_ALL_ACCESS, 0, 0, shm-&amp;gt;Size)2.1.3. UnmapViewOfFileBOOL UnmapViewOfFile(PVOID pvBaseAddress); pvBaseAddress: 해제할 영역의 주소 MapViewOfFile함수의 반환값과 동일한 값을 사용해야한다. if (shm-&amp;gt;pData) { UnmapViewOfFile(shm-&amp;gt;pData); }2.1.4. CloseHandle if (shm-&amp;gt;hFileMap) { CloseHandle(shm-&amp;gt;hFileMap); }2.2. boost-interprocess C++출처 namespace 가 길기 때문에 boost::interprocess는 생략했다.2.2.1. shared_memory_object 이 객체의 생성자는 3개의 파라미터가 있다. 첫번째 파라미터는 생성할것인지와 열것인지를 설정하는 것이다.(open_or_create) 두번째 파라미터는 공유 메모리의 고유 이름이다. 세번째 파라미터는 공유 메모리 접근하는 방식이다. (read_write) truncate()는 read_write일 경우에만 사용가능하다. truncate()를 호출하여 나중에 메모리 크기를 조정할 수 있다. truncate() 호출 전에는 메모리 사이즈 0 shared_memory_object shdmem(open_or_create, &quot;Local\\\\MPipe&quot;, read_write);2.2.2. mapped_region() 다른 어플리케이션과 통신하려면 각 어플리케이션은 공유 메모리와 자신의 메모리 공간을 일치 시켜야함. 특정 어플의 주소공간에 다른 객체들을 맵핑시키는데 사용 가능하다.(ex. file_mapping의 경우 특정 파일을 위한 공유 메모리를 나타냄. 그렇기 때문에 이 타입의 객체는 파일, 이 객체는 전체 파일을 로드하지 않고 일부분만 주소공간과 맵핑하게 해주는 함수가 mapped_region())#include &amp;lt;boost/interprocess/mapped_region.hpp&amp;gt; mapped_region region(shdmem, read_write); std::cout &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &quot;0X&quot; &amp;lt;&amp;lt; region.get_address() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; region.get_size() &amp;lt;&amp;lt; std::endl; 첫번째 파라미터는 shared_memory_object 객체 두번째 파라미터는 접근 권한을 나타낸다.2.2.3. region.get_address()2.2.3.1.writemapped_region region(shdmem, read_write);int *i1 = reinterpret_cast&amp;lt;int*&amp;gt;(region.get_address());*i1 = 99;2.2.3.2. readmapped_region region2(shdmem, read_only);int *i2 = reinterpret_cast&amp;lt;int*&amp;gt;(region2.get_address());std::cout&amp;lt;&amp;lt;*i2&amp;lt;&amp;lt;std::endl;2.2.4. remove() 공유메모리 삭제하기 위한 정적 함수2.2.5. remove_shared_memory_on_destroy() RAII 개념 객체 생성시 인자로서 존재하는 공유 메모리 이름을 전달하면, 이 객체가 파괴될때 소멸자에서 가지고 있던 공유메모리 함께 제거#include &amp;lt;boost/interprocess/shared_memory_object.hpp&amp;gt; bool removed = shared_memory_object::remove(&quot;Loca\\\\MPipe&quot;); remove()가 호출되지 않으면 어플이 종료되어도 공유메모리는 삭제되지 않는다. 유닉스, 리눅스의 경우 시스템 재시작시 자동으로 공유메모리 삭제 윈도우나 mac은 remove() 호출이 없다면 시스템 재시작 후에도 파일로서 계속 존재, 재사용 가능 윈도우의 경우 공유 메모리를 사용하던 어플에서 최종 사용자가 종료될 때 자동으로 공유 메모리를 삭제할 수 있다 (windows_shared_memory 클래스 사용)2.2.6. managed_shared_memory shared_memory_object는 공유메모리에 바이트 단위로 읽고 쓰는 기능을 제공한다. 객체를 생성해서 저장하고 가져오는 방식을 사용하기위한 객체가 managed_shared_memory 객체는 공유메모리상에 만들어지고, 다른 어플에서도 그 객체를 사용할 수 있다.#include &amp;lt;boost/interprocess/managed_shared_memory.hpp&amp;gt;managed_shared_memory managed_shm(open_or_create, &quot;Local\\\\MPipe&quot;, 512);int *i = managed_shm.construct&amp;lt;int&amp;gt;(&quot;Integer&quot;)(99);std::cout&amp;lt;&amp;lt;*i&amp;lt;&amp;lt;std::endl;std::pair&amp;lt;int*, std::size_t&amp;gt; p = managed_shm.find&amp;lt;int&amp;gt;(&quot;Integer&quot;);if (p.first) { std::cout&amp;lt;&amp;lt;*p.first&amp;lt;&amp;lt;std::endl;}managed_shm.destroy&amp;lt;int&amp;gt;(&quot;Integer&quot;); shared_memory_object는 데이터를 읽고 쓸 때 공유메모리의 개별 바이트들로 직접 접근했지만, managed_shared_memory는 construct()같은 함수를 사용한다. construct&amp;lt;&amp;gt;(&quot; &quot;)의 템플릿 인자는 데이터 타입 그리고 파라미터는 객체를 구분하기 위한 이름이 들어간다. construct&amp;lt;&amp;gt;()는 프록시 객체를 리턴하기 때문에 생성된 객체를 초기화할 수 있다. construct 호출 시 이미 존재하는 경우 0이 리턴된다. 기존에 존재하는 managed shared memory에서 존재하는 객체를 재사용하려면 find_or_construct()를 사용한다.(객체 초기화 x) 실패할 경우 bad_alloc 예외가 발생한다. managed_shm.destroy&amp;lt;&amp;gt;(); 를 사용하여 객체를 삭제한다. 이 때 인자는 객체의 이름이며, 성공시 true를ㅌ리턴한다.(destroy_ptr()은 객체, 객체 배열 삭제를 위해 객체 포인터를 인자로 넘긴다.) managed_shared_memry는 find()를 통해 특정 객체를 찾는다. 객체의 이름을 인자로 넘기면, 객체의 포인터를 반환한다. (실패시 0) 반환값 = &amp;lt;객체 포인터, 객체의 사이즈(객체 배열의 크기)&amp;gt; managed_shm.construct&amp;lt;int&amp;gt;(&quot;Int&quot;)[10](99) : [] 를 사용하여 배열로 공유메모리에 생성 가능하다. 이 때 초기값은 개별로 줄 수 없다. 2.2.7. atomic_func() 각 어플에서 동일한 공유메모리에 접근할때, 생성, 검색, 삭제 등은 자동적으로 동기화 된다. 만약 공유 메모리에 서로 다른 이름의 객체를 생성하려고 하면 그 연산이 적절히 직렬화된다. 다른 어플에 의한 동작에 방해받지 않고 동시에 실행시키려면 atomic_func()함수를 사용하면된다. named_mutex 등을 이용하여 동기화를 적절하게 할 수 있다.2.3. mmap python mmap을 통해 공유 메모리에 접근할 수 있다. write에는 바이트 타입이 들어가야한다. write는 호출시 데이터를 덮어쓰고, 공유메모리의 다음 주소를 가리키게 한다. shm = mmap.mmap(0, 512, &quot;Local\\\\MPipe&quot;) if shm: for idx in range(0, 21): shm.write(struct.pack(&#39;f&#39;, hand_landmarks.landmark[idx].x)) shm.write(struct.pack(&#39;f&#39;, hand_landmarks.landmark[idx].y)) shm.write(struct.pack(&#39;f&#39;, hand_landmarks.landmark[idx].z))2.4. sysv_ipc python shm = sysv_ipc.SharedMemory(777) shm.write(struct.pack(&#39;f&#39;, hand_landmarks.landmark[idx].x), offset)3. 참고ipc의 종류와 특징wrapping c/c++ for pythonwindows_IPCwinapi-MemoryMap1winapi-MemoryMap2boost-interprocesslinux-ipc" }, { "title": "[box2d] box2d 문서", "url": "/posts/2022/02/21/23/57/box2d1/", "categories": "game, game-box2d", "tags": "box2d", "date": "2022-02-21 23:57:09 +0900", "snippet": "Box2d 1. box2d 2.4.1 1.1. object 1.2. module 1.3. Units 1.4. Factories and Definitions 2. Hello Box2D 2.1. Creating a World 2.2. Creating a GroundBox 2.2.1. step1 2.2.2. step2 2.2.3. step3 2.2.4. step4 2.2.5. about fixture 2.3. Creating a Dynamic Body 2.4. Simulating the world 2.4.1. time step 2.4.2. constraint solver 2.4.3. simulation loop 2.5. Cleanup 3. Common Module 3.1. settings 3.2. Memory Management 3.3. Math 4. Collision Module 4.1. shape 4.1.1. Circle Shapes 4.1.2. PolyGon Shapes 4.1.3. Edge Shapes 4.1.4. Chain Shapes 4.2. Geometric queries 4.2.1. Shape Point Test 4.2.2. Shape Ray Cast 4.3. Pairwise Functions 4.3.1. Overlap 4.3.2. Contact manifolds 4.3.3. Distance 4.3.4. Time of impact 4.4. Dynamic Tree 4.5. Broad-phase 5. Dynamics Module 5.1. Bodies 5.1.1. b2_staticBody 5.1.2. b2_kinematicBody 5.1.3. b2_dynamicBody 5.1.4. Body Definition 5.1.4.1. Body Type 5.1.4.2. Position and Angle 5.1.4.3. Damping 5.1.4.4. Gravity Scale 5.1.4.5. Sleep Parameters 5.1.4.6. Fixed Rotation 5.1.4.7. Bullets 5.1.4.8. Activation 5.1.4.9. User Data 5.1.5. Body Factory 5.1.6. Using a Body 5.1.7. Mass Data 5.1.8. State Information 5.1.9. Position and Velocity 5.1.10. Fiorces and Impulses 5.1.11. Coordinate Transformations 5.1.12. Acessing Fixtures, Joints, and Contacts 5.2. Fixtures 5.2.1. Fixture Creation 5.2.2. Density 5.2.3. Friction 5.2.4. Restitution 5.2.5. Filtering 5.2.6. Sensors 5.3. Joints 5.4. Contacts 5.5. World 5.5.1. Creating and Destroying a World 5.5.2. Using a World 5.5.2.1. Simulation 5.5.2.2. Exploring the World 5.5.2.3. AABB Queries 5.5.2.4. ?Ray Casts? 6. Loose Ends 6.1. User Data 6.2. Custom User Data 6.3. Implicit Destruction 6.4. Pixels and Coordinate Systems 6.5. Debug Drawing 6.6. Limitations 7. links1. box2d 2.4.1 C++로 작성된 강체 시뮬레이션 라이브러리 b2라는 접두어의 타입을 가지고 있음.1.1. object shape: 원이나 폴리곤 같은 2차원 기하객체 rigid body: 물체를 구성하는 두입자의 거리가 절대로 바뀌지 않는 물체, 단순화된, 가정된 형태 fixture: body에 shape를 연결, 밀도, 마찰, 반발력과 같은 물체 속성 추가 constraint: bodies에서 자유도를 제거하는 물리적 연결. 2d body: 2개의 이동축과 1개의 회전축. 즉, 3개의 자유도를 가진다. 만약 body를 벽에 고정한다면 벽에 body를 constraint한것. 그 고정점을 기준으로 body를 회전만 시킬 수 있으므로 이는 2개의 자유도를 제거한것과 같다. constract constraint: 강체의 침투(강체가 부딪혔을 때 움푹파이는 정도)를 막기 위해, friction and restitution을 시뮬레이션 할 수 있게한다. (직접 만들 수 없고, Box2D가 알아서 생성) joint: 2가지 이상의 body를 하나로 만들어주는 constraint. Box2D는 revolute, prismatic, distance와 같은 joint 타입을 제공한다. 몇몇 joint는 limits and motors를 가지고 있다. joint limit: 조인트의 움직이는 범위를 제한(사람의 팔꿈치 처럼) joint motor: 조인트 모터는 조인트의 허용되는 각도에 따라 연결된 바디의 움직임을 유발한다. (모터를 팔꿈치를 회전시키기 위해 사용할 수 있다.) world: 프로그래밍상의 물리공간. 여러 물리공간을 만들 수 있지만 권장되지 않는다. solver: 물리공간은 solver를 가진다. 좀 더 나은 타이머를 사용할 수 있게 해주며, 접촉과 joint constraints을 해결해준다. (Box2D에서는 N개의 제약을 하나씩 수행하는 iterative solver를 가짐) continuous collision: solver는 물체를 점진적(discrete time steps)으로 이동시킴. 간섭(intervention)이 없으면 turnneling effect가 발생할 수 있음 turnneling effect: 입자가 벽을 넘어 마치 공이동을 하는것처럼 보이는것(파동의 성질) Box2D에서는 이를 처리하기위해 특별한 알고리즘을 포함하고 있음. collision 알고리즘: 두 body의 움직임을 보간(iterpolate) 하여 첫번째 충돌시간(TOI)를 찾는다. body를 첫 충돌시점으로 이동시킨다음 충돌을 해결하는 하위 단계 solver를 사용하여 해결 1.2. modulecommon -&amp;gt; collision -&amp;gt; dynamicscommon -&amp;gt; dynamics 3가지 모듈(Common, Collision, Dynamics)로 구성된다. Common: allocation, mathm, settings와 관련된 코드를 가진다. Collision: shapes, broad-phase, collision function/queries를 정의한다. Dynamic: simulation world, bodies, fixture, joints를 제공.1.3. Units 부동소수점, tolerances(허용오차) 사용, 허용오차는 미터, 킬로그램, 초(mks)단위에 잘 동작하도록 조정되어있다. - 그렇기 때문에 움직이는 물체의 크기는 대략 0.1~10미터 사이로 유지해야한다. - 환경(environment)과 actors를 렌더링할 때 스케일링 시스템을 사용해야한다. - Box2D테스트 베드는 OpenG 뷰포트 변환을 사용하여 이를 수행한다. 주의! 픽셀을 한 단위로하면 잘못된 시뮬레이션과 이상한 동작으로 이어진다. 특히 0.1~10 미터 사이에서 잘 동작한다. static shapes은 50미터까지 잘 동작한다. 전체 world size가 2km 보다 커지면 정밀도를 잃게되어 불안정해진다. b2World::ShiftOrigin을 통해 더 큰 world를 지원한다. Box2D는 degrees가 아니라 radians을 사용한다. 즉, 바디의 회전은 라디안으로 값을 저장하고 증가 또는 축소함으로써 이루어진다. 각도의 크기가 커질경우 정규화해야한다. (b2Body::SetTransform) length units을 변경하기위해서는 b2_lengthUnitsPerMeter를 수정해야한다. b2_user_settings.h에 있는 B2_USER_SETTING를 통해 병합충돌을 피할 수 있다. (b2_settings.h)1.4. Factories and Definitions 빠른 메모리관리는 Box2D 설계에서 핵심적인 역할을 한다. 그래서 b2Body 또는 b2Joint 를 생성할 때, (b2World)[https://box2d.org/documentation/classb2_world.html]에서 factory functions을 호출할 필요가 있다. 이러한 타입을 다른 방식으로 할당해서는 안된다. CreateBody CreateJoint b2Body* b2World::CreateBody(const b2BodyDef* def)b2Joint* b2World::CreateJoint(const b2JointDef* def)// &amp;lt;-&amp;gt;void b2World::DestroyBody(b2Body* body)void b2World::DestroyJoint(b2Joint* joint) body 또는 joint를 생성할 때, 구축하는데 필요한 모든 정보를 정의해서 제공해야한다. 이를 통해 객체 생성에서의 오류를 방지할 수 있다. 함수의 파라미터수를 줄일 수 있다. 합리적인 기본값을 제공할 수 있다. 접근자(accessors)의 수를 줄일 수 있다. fixtures(shapes)는 body의 부모가 되어야하므로 b2Body에서 팩토리 매서드를 사용하여 생성 및 소며로딘다. CreateFixture b2Fixture* b2Body::CreateFixture(const b2FixtureDef* def)b2Fixture* b2Body::CreateFixture(const b2Shape* shape, float density)void b2Body::DestroyFixture(b2Fixture* fixture) Factories 는 정의에 대한 참조를 유지하지 않는다. 따라서 스택에 정의를 생성하고 임시 리소스에 보관할 수 있다.2. Hello Box2D 커다란 large ground box와 small dynamic box에 대한 예제 이 코드에는 그래픽이 포함되어있지 않다. 시간에 따른 상자 위치의 콘솔에 텍스트 출력만 표시된다.2.1. Creating a World 모든 Box2D 프로그램은 b2World객체 생성으로 시작한다. b2World: 메모리, 객체, 시뮬레이션을 관리하는 physics hub이다. physics world를 스택, 힙, data section에 할당할 수 있다. Box2D world를 생성하는 것은 아래와 같이 gravity vector를 정의하기만 하면 된다.(중력의 방향과 중력값)b2Vec2 gravity(0.0f, -10.0f);b2World world(gravity); 주의! scope를 조심해야한다. (할당과 해제)2.2. Creating a GroundBox Bodies 는 다음과 같은 단계를 거쳐 구축된다. body의 position, damiping, etc. 을 정의 world object를 사용하여 body 생성 fixtures 정의 (shape, friction, density, etc.) fixtures을 body에 생성(붙임) 2.2.1. step1 ground body 생성해야한다. 이를 위해 body정의가 필요하다. body 정의를 사용하여 ground body의 초기 position를 지정해야한다.b2BodyDef groundBodyDef;groundBodyDef.position.Set(0.0f, -10.0f);2.2.2. step2 body 정의를 world object로 넘겨 ground body를 생성한다. world object는 body정의에 대한 참조를 유지하지 않는다. body는 기본적으로 static이다. static bodies는 다른 static bodies과 충돌하지 않으며 움직일 수 없다. b2Body* groundBody = world.CreateBody(&amp;amp;groundBodyDef);2.2.3. step3 ground polygon을 생성해야한다. SetAsBox shortcut을 사용하여 ground polygon을 box shape로 형성하고, box가 부모 몸체의 원점에 중심이 되도록해야한다. SetAsBox() b2PolygonShape b2PolygonShape groundBox;groundBox.SetAsBox(50.0f, 10.0f); setAsBox는 half width 그리고 half height (extents를 인자로 받는다. 즉, 위 코드는 100 units width(x-axis), 20units tall(y-axis)를 가지는 ground box인 것이다. box2D는 mks 단위로 조정됬으므로, extents를 meters로 고려할 수 있다. Box2D는 일반적으로 객체가 일반적인 실제 객체 크기일 때 가장 잘 작동한다. (ex. box2d를 사용하여 glaciers, dust 파티클의 움직임을 모델링하는것은 좋은 생각이 아님) 2.2.4. step4 shape fixture를 생성하는것이 마지막 단계이다. 간단한 방법으로 fixture 기본값을 사용하는것이다. 두번째 파라미터는 shape의 입방미터당 킬로그램이며 밀도를 나타낸다. static body는 기본값으로 0이다.groundBody-&amp;gt;CreateFixture(&amp;amp;groundBox, 0.0f); box2D는 shape에 대한 참조를 유지하지 않는다. data를 새로운 b2Shape 객체로 복사(clone)한다.2.2.5. about fixture 모든 fixture는 부모 body가 있어야한다. (static 이더라도) 하지만, 모든 static fixtures를 single static body에 붙일 수 있다. fixture를 사용하여 body에 shape를 붙일 때, shape의 좌표는 body의 local이 된다. 그래서 body가 움직이면, shape 또한 움직인다. fixtures의 world transform은 부모 body에서 상속받는다. fixture는 body 와 독립된 transform 을 가지고 있지 않다. 그래서 body에서 shape를 움직이지 않는다. body에 있는 모양을 이동하거나 수정하는 것은 지원되지 않는다. 이유: 모양이 변형되는 body는 강체(rigid body) 가 아니지만, box2D는 rigidbody engine이다. Bodx2D에서 만들어진 많은 가정은 강체 모델을 기반이므로, 이를 위반하면 많은것들이 제대로 작동하지 않게된다. 2.3. Creating a Dynamic Body ground body를 만든 것처럼 똑같이 dynamic body를 만들 수 있다. 치수를 제외한 차이점은 dynamic body의 mass 속성을 설정해야한다는 것이다. 첫번째로 CreateBody 를 사용하여 body를 생성해야한다. 기본적으로 bodies는 static이므로 b2BodyType을 설정해야한다.b2BodyDef bodyDef;bodyDef.type = b2_dynamicBody;bodyDef.position.Set(0.0f, 4.0f);b2Body* body = world.CreateBody(&amp;amp;bodyDef); Caution: You must set the body type to b2_dynamicBody if you want the body to move in response to forces. 다음으로 fixture 정의를 통해 polygon shape를 생성하고 달아줘야한다.b2PolygonShape dynamicBox;dynamicBox.SetAsBox(1.0f, 1.0f);b2FixtureDef fixtureDef;fixtureDef.shape = &amp;amp;dynamicBox;fixtureDef.density = 1.0f;fixtureDef.friction = 0.3f; 여기서 주목할 점은 density가 1(default = 0) 그리고 friction을 0.3f로 설정한 점이다. Caution: A dynamic body should have at least one fixture with a non-zero density. Otherwise you will get strange behavior. 이제 fixture 정의를 가지고 fixture를 생성할 수 있다. 이 때 자동적으로 body의 mass가 업데이트된다. 또한, 다수의 fixtures를 추가할 수 있다. 이 경우 각각은 전체 mass에 기여한다.body-&amp;gt;CreateFixture(&amp;amp;fixtureDef);2.4. Simulating the world ground box 그리고 dynamic box를 초기화했으므로, 이제 시뮬레이션 할 준비만 몇가지 하면 된다.2.4.1. time step Box2D는 적분기(integrator) 라는 컴퓨팅 알고리즘을 이용한다. 적분기: 물리 방정식을 이산시간에 대해서 시뮬레이션하는 알고리즘 이산시간: 시간을 일정한 간격으로 잘라 사용하는 것을 의미 이산시간은 전통적인 게임루프(플립북에서 대상이 움직이는 하나의 scene)과 같이 진행된다. 그래서 Box2D를 위한 time step이 필요하다. 일반적으로 게임에서 물리엔진은 60프레임, 60Hz 또는 1/60초 만큼 빠른 time step을 사용한다. 더 큰 time steps를 설정할 수 있지만, 이 경우 생성한 world 객체에 대한 정의를 주의깊게 준비해야한다. time steps는 고정된 것이 좋다. 가변 time step은 다양한 결과를 야기시킨다. 이것은 디버깅하기도 어려우므로, 진행하는 프레임에 time step을 엮는것은 권장되지 않는다. 아래와 같이 간단하게 time step을 설정할 수 있다.float timeStep = 1.0f / 60.0f;2.4.2. constraint solver 추가적으로 적분기에 constraint solver를 이용할 수 있다. constraint solver: 시뮬레이션 constraint에 대해서 해결책을 제공. 하나의 constraint은 완전하게 해결 할 수 있다. 그러나 하나의 constraint을 해결할 때 또 다른 제한이 방해할 수 있다. 좋은 해결책은 모든 제한에 대해서 여러번 반복하는것. constraint solver의 2개의 단계 속도 단계(velocity phase): solver는 body를 정확하게 움직이기 위해 충격(impulses)을 계산한다. 위치 단계(position phase): solver는 겹침(overlap) 과 조인트 분리의 오차를 줄이기 위해서 body의 position을 조정한다. 각각의 단계는 자기자신의 iteration count를 가지고 있으며, 위치 단계에서는 만약 오차가 작다면 반복을 일찍 종료한다. Box2D는 속도 단계의 iteration count는 8을 권장하며, 위치 단계의 iteration count는 3을 권장한다. 이를 조정하는 것은 성능과 정확성 사이의 trade-off 임을 알아야한다. 적은 숫자: 속도를 증가, 정확도는 감소 간단한 예제이므로 아래와 같이 설정하였다.int32 velocityIterations = 6;int32 positionIterations = 2; time step 과 iteration count는 완전히 상관이 없으며, 한 iteration은 sub-step이 아니다. 하나의 solver iteration은 time step내의 모든 constraint를 한번씩은 통과해야한다. (최소한 한번)2.4.3. simulation loop 시뮬레이션 루프는 게임루프에 통합된다. 게임 루프 전체의 각각의 단계에서 b2World::step을 호출할 수 있다. 일반적으로 게임 루프 프레임과 물리 time step에 의존하기 때문에 상황마다 다르지만 일반적으로 한번만 호출하면 충분하다. 이 예제는 그래픽이 없고, 아래의 코드는 dynamic body의 위치와 회전을 출력한다. 아래는 총 1 초의 시뮬레이션 시간 동안 60 개의 시간 단계를 시뮬레이션하는 시뮬레이션 루프이다.for (int32 i = 0; i &amp;lt; 60; ++i){ world.Step(timeStep, velocityIterations, positionIterations); b2Vec2 position = body-&amp;gt;GetPosition(); float angle = body-&amp;gt;GetAngle(); printf(&quot;%4.2f %4.2f %4.2f\\n&quot;, position.x, position.y, angle);} 출력 결과는 상자가 떨어지고 ground box에 착륙하는 것을 보여준다0.00 4.00 0.000.00 3.99 0.000.00 3.98 0.00...0.00 1.25 0.000.00 1.13 0.000.00 1.01 0.002.5. Cleanup world 가 scope를 벗어나게되거나 포인터에서 delete가 호출되어 삭제될 때, 모든 bodies, fixtures, joint는 메모리에서 해제된다. 이처럼 무효화되기 때문에. world의 객체들을 가리키는 모든 포인터들을 잘 관리해야한다. 이를 통해 성능을 얻었고, 코드도 간결해졌다.3. Common Module settings, memory management, vector math3.1. settings box2D에 정의 된 타입들을 통해 구조의 크기를 쉽게 결정가능하다. b2Settings.h 에 정의된 상수들, 일반적으로 조정할 필요가 없다. 부동소수점 연산을 하기 때문에 round-off 오류를 위한 수치 허용오차가 정의되어있음 (일부는 상대적, 절대적 허용오차는 MKS단위 사용) b2Version 구조체로 box2d의 현재 버전을 알아낼 수 있다.3.2. Memory Management 많은 수의 작은 객체(50-300바이트)를 할당하는 경향이 있는 box2d. 작은 객체에 대해 malloc, new 를 통해 시스템 힙을 사용하는 것은 비효율적이며 단편화를 일으킬 수 있다. 이러한 객체에 대한 힙 메모리를 효율적으로 제공할 수 있는 할당자가 필요 small object allocator (SOA): b2BlockAllocator SOA는 다양한 크기의 확장 가능한 여러 풀을유지한다, 메모리에 대한 요청이 이루어지면 SOA는 요청된 크기에 가장 적합한 메모리 블록을 반환한다. 블록이 해제되면 풀로 반환된다. 이러한 작업은 모두 빠르며 힙 트래픽이 발생하지 않는다. Box2D는 SOA를 사용하기 때문에 절대로 body, fixture, joint를 new와 malloc을 하면 안된다.(하지만 b2World는 할당 가능) b2World: body, fixture, joint를 생성할 수 있는 factories 제공하는 클래스 [참고] time step 실행도중 Box2D는 임시 작업 공간 메모리가 필요하다. 그러므로 b2StackAllocator 라는 스택할당자를 사용하여 단계별 힙 할당을 방지한다. (스택할당자와 상호작용할 필요 없다.)3.3. Math 간단한 벡터, 행렬 연산 모듈을 포함한다. Box2D 내부 요구 사항에 맞게 설계되어있다.4. Collision Module shapes, dynamic tree, broad-phase(큰 시스템에서 충돌처리 가속을 위한)4.1. shape 충돌 기하학을 설명, 물리 시뮬레이션과 독립적으로 사용됨. 최소한 rigid bodies과 어떻게 연결되는지 방법을 이해애야한다. b2Shape 클래스로 구현되어있고, 아래와 같은 함수들이 정의되어있다. shape가 겹쳤는지 테스트. shape에 대한 ray cast 수행 shape의 AABB 계산 shape의 mass 속성 계산 게다가, 각각의 shape는 type member, radius가 있다. radius: 다각형(polygons)에도 적용가능. shape는 body에 대한 정보가 없으며, dynamics system과 별개이다. shape는 크기와 성능에 최적화된 컴팩트한 형태로 저장된다. 따라서 shape는 쉽게 움직이지 않는다. - 수동적으로 정점 위치를 설정해야한다. - 하지만 fixture를 사용하여 형상을 body에 붙이면, shape는 host body와 함께 이동한다. shape가 body에 연결되지 않은 경우, 그것의 정점이 world-space로 표현된다. shape가 body에 연결되면, 해당 꼭짓점이 local-coordinates 표현된다.4.1.1. Circle Shapes circle 은 position 과 radius 를 가지고 있다. circle 로 속이 빈 원을 만들 수 없다.b2CircleShape circle;circle.m_p.Set(2.0f, 3.0f);circle.m_radius = 0.5f;4.1.2. PolyGon Shapes Polygon 은 convex polygons이다. (볼록 다각형) Polygon은 속이 비어있지 않는다. 다각형에는 3개 이상의 꼭짓점이 필요하다. 다각형의 정점은 CCW(반시계 당향)으로 저장된다. ccw: z축이 평면 바깥쪽을 가리키는 오른손 좌표계에 관한 것. 좌표계 규칙에 따라 화면에서 시계방향으로 나타날 수 있다. 폴리곤 멤버는 public 이지만, 폴리곤을 생성하려면 초기화 함수를 사용해야한다. 초기화 함수: 법선 벡터를 생성하고 유효성 검사를 수행 꼭짓점 배열을 전달하여 다각형 모양을 만들 수 있다. 배열의 최대 크기는 기본값이 8인 b2_maxPolygonVertices에 의해 제어된다. b2PolygonShape::Set 함수는 convex hull을 자동으로 계산하고 적절히 감는 순서를 설정한다(winding order). convex hull 함수는 정점을 제거하거나 재정렬할 수 있다. (b2_linearSlop 보다 가까운 정점은 병합되어진다.)// This defines a triangle in CCW order.b2Vec2 vertices[3];vertices[0].Set(0.0f, 0.0f);vertices[1].Set(1.0f, 0.0f);vertices[2].Set(0.0f, 1.0f);int32 count = 3;b2PolygonShape polygon;polygon.Set(vertices, count); polygon shape 는 box를 생성하는 몇가지 편의 기능이 있다.void SetAsBox(float hx, float hy);void SetAsBox(float hx, float hy, const b2Vec2&amp;amp; center, float angle); Polygons은 b2Shape의 radius를 상속한다. radius는 polygon 주위에 skin을 만든다. skin은 stacking scenarios에서 다각형을 약간 분리하는데 사용된다. 이렇게 하면 코어 폴리곤에 대해 연속 충돌을 처리할 수 있다. polygon skin은 polygon을 분리된 상태로 유지함으로써 tunneling을 방지한다. 그 결과 두 shape 사이에 작은 간격이 생기게된다. 이러한 간격을 숨기기위해 다각형이 보다 더 크게 시각적으로 표현할 수 있다. Not that polygon skin is only provided to help with continuous collision. The purpose is not to simulate rounded polygons.4.1.3. Edge Shapes edge shape는 선분(line segments)이다. 이는 게임을 위한 자유형식의 static 환경을 만드는데 도움이 되도록 제공된다. 주요 제한은 원 및 다각형과 충돌할 수 있지만 edge와는 충돌할 수 없다는 것이다. Box2D에서 사용하는 충돌 알고리즘은 충돌하는 두 모양 중 적어도 하나에 볼륨이 있어야한다. 가장자리 모양에는 적어도 하나의 볼륨이 있어야한다. edge에는 volume이 없으므로 edge-edge 충돌이 불가 // This an edge shape.b2Vec2 v1(0.0f, 0.0f);b2Vec2 v2(1.0f, 0.0f);b2EdgeShape edge;edge.SetTwoSided(v1, v2); 많은 경우 게임 환경은 여러 edge shape의 끝을 연결하여 구성한다. 이 경우 가장자리 체인을 따라 미끄러질 때 예기치 않은 artifact가 일어날 수 있다. ghost collisions: polygon이 내부 충돌 법선(internal collision normal)을 생성하는 내부 정점과 충돌할 때 발생한다. 다행히 edge shape는 인접한 ghost vertices를 저장하여 ghost collisions을 제거하는 방법을 제공한다. 고스트 충돌을 처리하기 위한 box2D알고리즘은 단측 충돌만 지원한다. ?첫번째 정점에서 두번째 정점을 볼때 정면이 오른쪽이며 ccw감기 순서와 일치한다. // This is an edge shape with ghost vertices.b2Vec2 v0(1.7f, 0.0f);b2Vec2 v1(1.0f, 0.25f);b2Vec2 v2(0.0f, 0.0f);b2Vec2 v3(-1.7f, 0.4f);b2EdgeShape edge;edge.SetOneSided(v0, v1, v2, v3); v3과 v0: 고스트 일반적으로 이 방법은 사용안한다. (wasteful and tedious) chain shapes를 사용한다.4.1.4. Chain Shapes 사슬 모양은 많은 edge를 함께 연결하여 static game worlds를 구성하는 효율적인 방법을 제공한다. 사슬 모양은 자동적으로 ghost collisions를 제거하고 일방적인 충돌을 제공한다. (provide one-sided collision) ghost collision을 신경쓰지 않는다면 그냥 edge 두개를 만들면 된다. (효율성은 비슷) chain shape를 만들기 위한 가장 간단한 방법은 loops를 생성하는 것이다. 정점 배열을 제공하기만 하면된다.b2Vec2 vs[4];vs[0].Set(1.7f, 0.0f);vs[1].Set(1.0f, 0.25f);vs[2].Set(0.0f, 0.0f);vs[3].Set(-1.7f, 0.4f);b2ChainShape chain;chain.CreateLoop(vs, 4); edge normal은 감는 순서(winding order)에 따라 다르다. 시계 반대 방향 순서는 법선을 바깥쪽으로 향하게 하고, 시계반대 방향 순서는 법선을 안쪽으로 향하게 한다. scrolling game world에서 여러 체인을 함께 연결하고 싶은 경우 b2EdgeShape에서처럼 고스트 정점을 사용하여 체인을 연결할 수 있다. b2ChainShape::CreateChain(const b2Vec2* vertices, int32 count, const b2Vec2&amp;amp; prevVertex, const b2Vec2&amp;amp; nextVertex); 체인 모양은 자체 교차(self-intersection)을 지원하지 않는다. (작동할 수도 않을 수도 있다.) 또한 매우 가까운 정점은 문제를 일으킬 수 있다.(모든 edge가 b2_linearSlop(5mm)보다 긴지 확인해야한다.) 체인의 각 edge는 child shape로 처리되며 인덱스로 접근할 수 있다. 체인이 body와 연결되면, 각 edge 는 넓은 위상 충돌 트리(broad-phase collision tree)에서 고유한 경계 box 를 가진다. // Visit each child edge.for (int32 i = 0; i \\&amp;lt; chain.GetChildCount(); ++i){ b2EdgeShape edge; chain.GetChildEdge(&amp;amp;edge, i); ...}4.2. Geometric queries 단일 shape에 대해 여러 기하학적 쿼리(geometric queries)를 수행할 수 있다.4.2.1. Shape Point Test shape transform과 world point을 인자로 받아 shape가 겹치는지 테스트할 수 있다.b2Transform transform;transform.SetIdentity();b2Vec2 point(5.0f, 2.0f);bool hit = shape-&amp;gt;TestPoint(transform, point); edge와 chain은 항상 false (chain이 loop여도)4.2.2. Shape Ray Cast shape에 ray를 투사하여 첫 번째 교차점과 법선벡터를 얻을 수 있다. (first intersection and normal vector) raycast가 한번에 하나의 edge만을 검사하기 때문에 chain shape에 child index가 포함된다. 주의: ray가 convex shape 내부에서 시작할 경우, 아무것도 적중되지 않음. (solid 객체) b2Transfrom transform;transform.SetIdentity();b2RayCastInput input;input.p1.Set(0.0f, 0.0f);input.p2.Set(1.0f, 0.0f);input.maxFraction = 1.0f;int32 childIndex = 0;b2RayCastOutput output;bool hit = shape-&amp;gt;RayCast(&amp;amp;output, input, transform, childIndex);if (hit){ b2Vec2 hitPoint = input.p1 + output.fraction * (input.p2 - input.p1); ...}4.3. Pairwise Functions Collision 모듈에는 한 쌍의 shape를 취하고 일부 결과를 계산하는 함수가 포함되어있다.4.3.1. Overlap b2TestOberlap: 두 shape가 겹치는지?b2Transform xfA = ..., xfB = ...;bool overlap = b2TestOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB); 체인 shape인 경우, child indices를 제공해야한다.4.3.2. Contact manifolds Box2D에는 overlapping shapes를 계산하는 기능이 있다. 원-원 or 원-다각형 : 하나의 접점과 법선만 얻을 수 있다. 다각형-다각형: 두점을 얻을 수 있다. 이러한 점은 동일한 법선 벡터를 공유하므로, Box2D는 이들을 manifold structure로 그룹화한다. 일반적으로 manifold structure를 직접 계산할 필요 x, 하지만 시뮬레이션에서 생성된 결과를 사용할 가능성이 높다, contact solver는 이를 활용하여 stacking stability를 개선한다. b2Manifold structure: 법선벡터와 최대 2개의 접점을 가진다. 법선과 점은 local coordinates로 유지된다자 contact solver의 편의를 위해 각 point는 법선 및 접선(마찰) 충격을 저장한다 (the normal and tangential(friction) impulses) b2Manifold에 저장된 데이터는 내부 사용에 최적화되어있다. 이 데이터가 필요한 경우 일반적으로 b2WorldManifold 를 사용하여 접촉 법선(contact normal) 과 points를 생성하는것이 가장 좋다. b2Manifold와 shape transforms과 반경(radii)을 제공할 필요가 있다. b2WorldManifold worldManifold;worldManifold.Initialize(&amp;amp;manifold, transformA, shapeA.m_radius,transformB, shapeB.m_radius);for (int32 i = 0; i \\&amp;lt; manifold.pointCount; ++i){ b2Vec2 point = worldManifold.points[i]; ...} world manifold는 original manifold의 point count를 사용한다. 시뮬레이션 중에 shape가 이동하고 manifolds가 변경되어질 수 있다. (points이 추가되거나 제거) b2GetPointStates를 사용하여 이를 감지할 수 있다.b2PointState state1[2], state2[2];b2GetPointStates(state1, state2, &amp;amp;manifold1, &amp;amp;manifold2);if (state1[0] == b2_removeState){ // process event}4.3.3. Distance b2Distance 함수는 두 shape 사이의 거리를 계산하는데 사용할 수 있다. distance function은 b2DistanceProxy로 변환하려면 두 shape 모두 필요하다. 반복호출에 대해 distance function을 warm start하는데 사용되는 일부 캐싱도 있다. 4.3.4. Time of impact 만일 두 shape가 빠르게 움직이는 경우 단일 time step에서 서로를 터널링할 수 있다. b2TimeOfImpact 함수는 두 개의 움직이는 shape가 충돌하는 시간을 결정하는 데 사용된다. 이를 TOI(time of impact)라고 한다. 이것의 목적은 터널 방지이다. 특히, 움직이는 물체가 static level geometry 외부로 터널링되는 것을 방지하도록 설계되었다. 이 함수는 두 shape의 회전 및 변환에 대해 처리하지만 회전이 충분히 크면 함수가 충돌을 놓칠 수 있다. 하지만, 이 함수는 여전히 non-overlapped time을 보고하고 모든 translational collisions을 잡아낸다. time of impact 함수는 초기 분리 축(initial separating axis)을 식별하고, shape가 해당 축에서 교차하지 않도록한다. 이것은 최종 위치에서 명확한 충돌을 놓칠 수 있다. 이 접근 방식은 일부 충돌을 놓칠 수 있지만 매우 빠르고 터널 방지에 적합하다. 회전 크기에 제한을 두는 것은 어려우며, 작은 회전에 대해 충돌이 누락되는 경우가 있다. 일반적으로 이러한 놓친 충돌은 게임 플레이에 해를 끼치지 않아야한다.(충돌하는 경향이 있음.) 이 함수는 두개의 shape(b2DistanceProxy로 변환된) 과 두 개의 b2Sweep 구조가 필요하다. sweep structure는 shape의 초기 및 최종 변환을 정의한다. 만일 고정 회전(fixed rotations)을 사용하면, shape cast를 수행할 수 있다. 이 경우, the time of impact function은 모든 충돌을 놓치지 않는다. 4.4. Dynamic Tree b2DynamicTree는 많은 shape를 효율적으로 구성하는데 사용된다. 이 클래서는 어떤 shape인지 모르지만, 사용자 데이터 포인터가 있는 AABBs(axis-aligned bounding boxes)에서 작동한다. dynamic tree는 계층적 AABB 트리이다. 트리의 각 내부 노드에는 두개의 자식을 가진다. 리프노드는 단일 사용자 AABB(single user AABB)이다. 트리는 퇴화 입력(degenerate input)의 경우에도 균형을 유지하기 위해 회전을 사용한다. 트리 구조는 효율적인 ray casts 그리고 영역 쿼리를 허용한다. 예를 들어, scene에 여러 shape가 있을 수 있다. 여기서 ray casst를 수행하려면, brute force 방법으로 각 shape에 대해 ray cast 하는 방법을 사용할 수 있다. 이런 방법은 비효율적이다. (shape가 서로 떨어져 있을 경우) 그러므로 dynamic tree를 유지하고, 이 tree에 대해 raycast를 수행하여 많은 개수의 shape를 스킵할 수 있다. region query: tree를 사용하여 쿼리 AABB와 겹치는 모든 리프 AABB를 찾음. 많은 shape를 스킵할 수 있기 때문에 빠르다. 일반적으로 이 트리를 직접 사용하지 않는다. b2World 클래스를 사용하여 레이 캐스트 및 지역 쿼리를 수행한다. 4.5. Broad-phase 물리 단계에서 충돌처리는 narrow-phase와 broad-phase로 나눌 수 있다. narrow-phase: shape 쌍에서 접점을 계산 N개의 shape: N*N/2 개의 쌍에 대해 narrow-phase를 수행해야한다. b2BroadPhase 클래스는 이러한 쌍을 관리하기 위해 dynamic tree를 사용하여 부하를 줄인다. 이것은 narrow-phase 호출의 수를 크게 줄여준다. broad-phase: 일반적으로 직접 상호작용하지 않는다.(내부적으로 box2D가 생성하고 관리) b2BroadPhase는 Box2D의 시뮬레이션 루프에 맞게 설계되었다. 5. Dynamics Module 다이나믹 모듈은 Box2D의 가장 복잡한 부분이다. 대부분 사용자가 상호작용하는 모듈. Common과 Collision 모듈 위에 있는 모듈 아래와 같은 클래스를 가지고 있다. fixture rigid body contact joint world listener 클래스 사이에 많은 종속성이 있다. (다른 클래스를 참조)5.1. Bodies position 과 velocity를 가지고 있다. forces, torques, impulses (힘, 토크, 충격)을 bodies에 적용할 수 있다. Body의 종류: static, kinematic, dynamic body는 fixtures(shapes)의 척추 bodies는 fixture를 운반하면서 world에서 움직인다. Body는 항상 강체이다. 즉, 동일한 강체에 부착된 fixtures는 서로에 대해 상대적으로 움직이지 않고, 서로 충돌하지 않는다. fixtures에는 collision geometry 와 밀도(density)가 있다. 일반적으로 body는 fixtures에서 mass 속성을 얻는다. 그러나 body를 만든 후 mass 속성을 override할 수 있다. 일반적으로 생성한 모든 bodies에 대해 pointers을 유지한다. 그러므로 body position을 쿼리하여 그래픽 개체의 위치를 업데이트할 수 있다. 또한 포인터에 대한 작업이 완료되면 파괴할 수 있다. 5.1.1. b2_staticBody 시뮬레이션에서 움직이지 않음 무한한 mass를 가진것 처럼 동작 mass와 inverse mass값 == 0 사용자가 수동적으로 이동 가능 속도 == 0 다른 static, kinematic body와 충돌하지 않는다.5.1.2. b2_kinematicBody 속도에 따라 시뮬레이션 중에 움직임 forces에 반응하지 않음 수동적으로 움직일 수 있지만 일반적으로 속도를 설정하여 이동시킴 무한한 mass를 가진것처럼 동작하지만 mass와 inverse mass 값 == 0 다른 static, kinematic과 충돌하지 않는다.5.1.3. b2_dynamicBody 완전히 시뮬레이션되는 body 사용자가 수동으로 이동할 수 있지만, 일반적으로 forces에 따라 움직임 어떠한 body와도 충돌 가능하다. 0이 아닌 질량을갖는다 만약 0으로 설정하면 자동적으로 1kg의 질량을 갖고 회전하지 않는다.5.1.4. Body Definition body를 생성하기 전에 body definition을 생성해야한다. (b2BodyDef) 초기화 하는데 필요한 데이터를 가진다. 이 정의에서 body로 데이터를 복사한다. 정의에 대한 포인터는 유지하지 않는다. 정의를 재활용하여 여러 body를 생성할 수 있다. 5.1.4.1. Body Type static, kinematic, and dynamic. 나중에 이를 변경하는것인 비용이 비싸므로 생성시에 설정 필수적이다.b2BodyDef bodyDef;bodyDef.type = b2_dynamicBody;5.1.4.2. Position and Angle 생성시 body위치를 초기화 world 원점에서 생성하고, body를 움직이는것보다 성능이 좋다. 원점에서 여러 body를 생성하면 성능이 저하된다. body’s origin: Fixtures 그리고 joints은 body 원점을 기준으로 부착된다. 질량 중심 위치(cenger of mass): 부착된 shape의 질량분포(mass distribution)에서 결정되거나 b2MassData로 명시적으로 설정할 수 있다. Box2D의 내부 계산의 대부분은 질량 중심 위치를 사용한다. 예를들어, b2Body는 질량중심에 대한 선형속도를 저장한다. body의 각도를 라디안 단위로 지정할 수 있으며, 이는 질량중심위치의 영향을 받지 않는다. 나중에 mass 속성들을 변경하면, body의 질량중심이 이동할 수 있지만, 원점 위치는 변경되지 않고, 부착된 shapes 과 joints 또한 이동하지 않는다.b2BodyDef bodyDef;bodyDef.position.Set(0.0f, 2.0f); // the body&#39;s origin position.bodyDef.angle = 0.25f * b2_pi; // the body&#39;s angle in radians. rigid body는 참조 프레임이다. 해당 프레임에서 fixtures 및 joints를 정의할 수 있다. 이것들은 local 프레임에서 절대 움직이지 않는다. 5.1.4.3. Damping bodies의 world 속도를 줄이기 위해 사용된다. friction은 접촉할 때 발생함(damping과 다름) 마찰을 대체 할 수 없음, 두가지 모두 사용해야함. Damping 매개변수는 0~ INF 사이 0: 감쇠가 없음 INF: 전체 감쇠 일반적으로 0 과 0.1 사이의 값을 사용한다.b2BodyDef bodyDef;bodyDef.linearDamping = 0.0f;bodyDef.angularDamping = 0.01f; Damping은 안정성과 성능에 대한 근사치 작은 감쇠값: timestep 과 무관 더 큰 감쇠값: timestep 에 따라 효과가 달라짐 5.1.4.4. Gravity Scale 단일 body의 중력을 조절 (증가하면 안정성이 떨어짐)// Set the gravity scale to zero so this body will floatb2BodyDef bodyDef;bodyDef.gravityScale = 0.0f;5.1.4.5. Sleep Parameters 시뮬레이션 횟수가 적을 수록 좋기 때문에 body를 중단하게 함. Box2D가 body(or group)이 정지했다고 판단하면 body는 CPU 오버헤드가 거의 없는 절전상태에 들어간다. awake 상태의 body와 충돌하면 깨어나게된다. Bodies에 연결된 joint 나 접점이 파괴된 경우에도 body가 깨어난다. 수동으로 깨울 수 있다. Body 정의에서 잠을 잘 수 있는지 와 생성할 때의 상태를 지정할 수 있다.b2BodyDef bodyDef;bodyDef.allowSleep = true;bodyDef.awake = true;5.1.4.6. Fixed Rotation 캐릭터와 같은 강체가 회전하지 않게 하기 위한 설정 하중이 가해져도 회전하지 않는다.b2BodyDef bodyDef;bodyDef.fixedRotation = true; 이 플래그는 회전 관성(rotational inertia) 그리고 그 역(inverse)이 0으로 설정되도록 한다.5.1.4.7. Bullets 이산 시뮬레이션에서 강체는 한 timestap에서 더 많이 이동할 수 있다. 터널링에 관한 것 기본적으로 Box2D는 연속 충돌 감지(CCD)를 사용하여 dynamic이 static을 터널링하는 것을 방지한다. 이전 위치에서 새 위치로 shape는 sweeping하여 수행한다. 엔진은 sweeping동안 새로운 충돌을 찾고, 충돌시간(TOI)을 계산한다. body가 첫번째 TOI로 이동된 다음, solver가 하위 단계를 수행하여 전체 timestep을 완료한다.(하위 단계 내에서 추가 TOI이벤트가 있을 수 있다.) 일반적으로 ccd는 dynamic에서 사용되지 않는다. 이는 성능을 합리적으로 유지하기 위해 수행된다. 일부 게임에서 dynamic body에 ccd가 필요할 경우가 있다. (ex. 고속 총알을 dynamic body에, 이 경우 ccd가 없으면 뚫릴 수 있음) 빠르게 움직이는 객체는 bullets이라는 라벨을 붙일 수 있다. bullet은 static, dynamic body 모두에 ccd를 수행한다. b2BodyDef bodyDef;bodyDef.bullet = true; 이 플래그는 dynamic body일 경우에만 유효하다.5.1.4.8. Activation 충돌이나 역학(collision or dynamics)에 참여하지 않을 수 있다. 이 상태는 body가 다른 body에 의해 깨어나지 않고, body의 fixture가 broad-phase에 배치되지 않는다는 점을 제외하고는 sleep과 유사하다. 즉, 충돌, 레이 캐스트에 참여하지 않는다. 이 설정은 나중에 변경할 수 있다.b2BodyDef bodyDef;bodyDef.active = true; joint는 비활성 body에 연결될 수 있지만, 시뮬레이션되지 않는다. body를 활성화 할 때 joint가 왜곡되지 않도록 주의해야한다. body를 활성화하는 것은 body를 처음부터 생성하는 것 만큼 비용이 많이 든다. 따라서 streaming worlds에서 이를 활용하면 안된다. 이 경우 생성/ 파괴를 사용하여 메모리를 절약해야한다. 5.1.4.9. User Data 사용자 데이터는 void pointer이다. 응용 프로그램 객체를 연결할 수 있는 연결고리이다, 일관성있게 객체 타입을 연결해야한다.b2BodyDef bodyDef;bodyDef.userData.pointer = reinterpret_cast&amp;lt;uintptr_t&amp;gt;(&amp;amp;myActor);5.1.5. Body Factory body는 world class에서 제공하는 body factory를 사용하여 생성 및 파괴된다. 이를 통해 world는 효율적으로 메모리 관리를 할 수 있다.b2World* myWorld;b2Body* dynamicBody = myWorld-&amp;gt;CreateBody(&amp;amp;bodyDef);// ... do stuff ...myWorld-&amp;gt;DestroyBody(dynamicBody);dynamicBody = nullptr; 주의: body를 생성할 때 new, malloc을 사용해서는 안된다. box2D는 body definition 또는 그 데이터에 대한 참조를 유지하지 않는다. (사용자 데이터 포인터는 유지) 따라서 임시 body 정의를 생성하고, 동일한 body 정의를 재사용할 수 있다. body를 삭제하면 부착된 fixtures, joints는 자동적으로 삭제된다.5.1.6. Using a Body 생성한 후에, 많은 작업을 수행할 수 있다. 질량 속성 설정, 위치 및 속도 접근, forces 적용, 점 및 벡터 변환 등5.1.7. Mass Data 물체에는 질량(스칼라), 질량 중심(2-vector), 회전 관성(스칼라) 가 있다. static body의 경우 질량 및 회전 관성 == 0 물체의 회전이 고정되어 있으면 회전 관성 == 0 일반적으로 body에 fixture를 추가할 때 body의 mass 속성이 자동으로 설정된다. 런타임에 body의 질량을 조정할 수 있다.void b2Body::SetMassData(const b2MassData* data); body의 mass를 직접 설정한 후 fixture에 의해 지시된 natural mass로 되돌릴 경우 아래와 같은 함수를 사용한다.void b2Body::ResetMassData(); body의 mass data와 관련된 함수는 다음과 같다.float b2Body::GetMass() const;float b2Body::GetInertia() const;const b2Vec2&amp;amp; b2Body::GetLocalCenter() const;void b2Body::GetMassData(b2MassData* data) const;5.1.8. State Information body state 접근하는 함수들void b2Body::SetType(b2BodyType type);b2BodyType b2Body::GetType();void b2Body::SetBullet(bool flag);bool b2Body::IsBullet() const;void b2Body::SetSleepingAllowed(bool flag);bool b2Body::IsSleepingAllowed() const;void b2Body::SetAwake(bool flag);bool b2Body::IsAwake() const;void b2Body::SetEnabled(bool flag);bool b2Body::IsEnabled() const;void b2Body::SetFixedRotation(bool flag);bool b2Body::IsFixedRotation() const;5.1.9. Position and Velocity 속도와 위치에 접근하는 함수들 이것은 렌더링할 때 일반적이다. 위치를 설정할 수 있지만, 시뮬레이션 결과를 얻는것이 일반적bool b2Body::SetTransform(const b2Vec2&amp;amp; position, float angle);const b2Transform&amp;amp; b2Body::GetTransform() const;const b2Vec2&amp;amp; b2Body::GetPosition() const;float b2Body::GetAngle() const; Local 그리고 world 좌표에서 질량 중심 위치에 접근할 수 있다. 내부 시뮬레이션은 대부분 질량 중심을 사용한다. (보통 사용자가 접근하지 않는다.) 일반적으로 body transform 을 사용할 수 있다. ex. body가 정사각형일 경우 질량중심은 정사각형 중심에 있다. (body의 원점은 모서리일 수 있다.) const b2Vec2&amp;amp; b2Body::GetWorldCenter() const;const b2Vec2&amp;amp; b2Body::GetLocalCenter() const; 선형 및 각속도에 접근할 수 있다. 선형 속도(linear velocity): 질량 중심에 대한것, 질량 특성이 변경되면 변경될 수 있다.5.1.10. Fiorces and Impulses 힘, 토크, 충격을 body에 적용 이 경우 하중이 가해지는 world point 를 넘겨줘야한다. 이로 인해 질량 중심에 대한 토크가 발생한다.void b2Body::ApplyForce(const b2Vec2&amp;amp; force, const b2Vec2&amp;amp; point);void b2Body::ApplyTorque(float torque);void b2Body::ApplyLinearImpulse(const b2Vec2&amp;amp; impulse, const b2Vec2&amp;amp; point);void b2Body::ApplyAngularImpulse(float impulse); 힘, 토크, 충격을 가하면 body가 깨어나게 된다. (For example, you may be applying a steady force and want to allow the body to sleep to improve performance.) 이를 막기 위해 아래와 같은 코드를 추가할 수 있다.if (myBody-&amp;gt;IsAwake() == true){ myBody-&amp;gt;ApplyForce(myForce, myPoint);}5.1.11. Coordinate Transformations body class에는 local 과 world space사이에서 점과 벡터를 변환하는 데 도움이 되는 몇가지 유틸리티 함수가 있다. 책추천: “Essential Mathematics for Games and Interactive Applications” by Jim Van Vert 이러한 함수들은 inline일 경우 효율적이다.b2Vec2 b2Body::GetWorldPoint(const b2Vec2&amp;amp; localPoint);b2Vec2 b2Body::GetWorldVector(const b2Vec2&amp;amp; localVector);b2Vec2 b2Body::GetLocalPoint(const b2Vec2&amp;amp; worldPoint);b2Vec2 b2Body::GetLocalVector(const b2Vec2&amp;amp; worldVector);5.1.12. Acessing Fixtures, Joints, and Contacts body의 fixtures에 접근할 수 있다. (반복문을 통해)for (b2Fixture* f = body-&amp;gt;GetFixtureList(); f; f = f-&amp;gt;GetNext()){ MyFixtureData* data = (MyFixtureData*)f-&amp;gt;GetUserData(); // do something with data ...} body의 joint 리스트 또한 유사하다. 연관된 contacts 리스트도 제공한다. 이를 사용해 현재 접촉에 대한 정보를 얻을 수 있다. 이 리스트에는 이전 timestep 동안 존재했던것들이 없을 수 있다. 5.2. Fixtures shape는 body에 대해 알지 못한다. 물리 시뮬레이션과 독립적으로 사용될 수 있다. 따라서 body에 shape를 붙이기 위해 b2Fixture 클래스를 사용한다. 여러 fixture가 있는것을 compound body라고 한다. fixture는 아래와 같은 데이터를 가지고 있다. a single shape broad-phase proxies density, friction, and restitution collision filtering flags back pointer to the parent body user data sensor flag 5.2.1. Fixture Creation fixture 정의를 생성하고, body에서 생성한다. 부모 body가 제거되면, 자동으로 fixture도 제거된다. (따로 포인터로 저장할 필요 없다.)b2Body* myBody;b2FixtureDef fixtureDef;fixtureDef.shape = &amp;amp;myShape;fixtureDef.density = 1.0f;b2Fixture* myFixture = myBody-&amp;gt;CreateFixture(&amp;amp;fixtureDef); 깨지기 쉬운 물체를 모델링하기 위해 fixture를 body에서 제거할 수 있다.myBody-&amp;gt;DestroyFixture(myFixture);5.2.2. Density fixture 밀도는 mass의 속성을 계산하는데 사용된다. 밀도는 0 또는 양수이다. 일반적으로 모든 fixture에 대해 유사한 밀도를 사용해야한다. (stacking 안정성 향상) 밀도를 설정할 때 body의 질량은 조정되지 않는다. (ResetMassData 호출해야한다.)b2Fixture* fixture;fixture-&amp;gt;SetDensity(5.0f);b2Body* body;body-&amp;gt;ResetMassData();5.2.3. Friction friction은 물체가 사실적으로 서로를 따라 미끄러지도록 하는 데 사용된다. Box2D는 static, dynamic friction을 지원하지만 둘다 동일한 매개변수를 사용한다. 마찰은 Box2D에서 정확하게 시뮬레이션된다. 마찰 강도는 수직력(normal force)에 비례한다.(쿨롱 마찰) 마찰 매개변수는 일반적으로 0과 1 사이에서 설정되지만, 음수가 아닌 값일 수 있다. 마찰 값이 0이면 마찰이 꺼짐 1이면 강해짐 두 shape 사이에서 마찰이 계산될 때 Box2D는 두 상위 fixture의 마찰 매개변수를 결합한다.(기하평균) 따라서 하나가 마찰이 0일 경우 접점은 마찰이 없다. b2Fixture* fixtureA;b2Fixture* fixtureB;float friction;friction = sqrtf(fixtureA-&amp;gt;friction * fixtureB-&amp;gt;friction); b2Contact::SetFriction 을 사용하여 혼합된 마찰을 override할 수 있다. b2ContactListener callback 에서 수행된다. 5.2.4. Restitution 복원은 물체를 튕기기 위해 사용된다. 복원 값은 0~1 사이로 설정된다. 테이블에 공을 떨어뜨릴 때 만약 0의 값을 가지고 있으면 공은 튀지 않는다. 이를 비탄성 충돌이라고 부른다. 값이 1 이면 공의 속도가 정확히 반영된다. 이를 완전 탄성 충돌이라고 부른다. 아래의 코드로 결합될 수 있다.b2Fixture* fixtureA;b2Fixture* fixtureB;float restitution;restitution = b2Max(fixtureA-&amp;gt;restitution, fixtureB-&amp;gt;restitution); 이와 같은 결합으로 bouncy floor가 아니더라도 bouncy ball을 만들 수 있다. b2Contact::SetRestitution을 사용하여 기본 혼합을 override할 수 있다. b2ContactListener callback 에서 수행된다. 다중 접촉에 대해서 복원은 대략적인 시뮬레이션을 수행한다. Box2D가 반복 솔버를 사용하기 때문. Box2D는 충돌 속도가 작은 경우에도 비탄성충돌을 사용한다. (jitter를 방지하는데 사용 b2_velocityRhreshold) 5.2.5. Filtering collision filtering을 사용하면 fixtures 사이의 충돌을 방지할 수 있다. 예를들어, 자전거를 타는 캐릭터, 자전거가 지형과 충돌, 캐릭터가 지형과 충돌하기를 원하지만 캐릭터와 자전거가 충돌하지 않게(겹쳐져야하므로) 범주 및 그룹을 사용하여 이러한 충돌 필터링을 지원한다. Box2D는 16개의 충돌 범주를 지원한다. 각 fixture에 대해 카테고리를 지정할 수 있다. 또한 이 fixture가 충돌할 수 있는 다른 카테고리를 지정할 수 있다. 예를 들어, 멀티플레이어 게임에서 모든 플레이어는 서로 충돌하지 않고 몬스터는 서로 충돌하지 않지만, 플레이어와 몬스터는 충돌하게 지정 가능하다. 이것은 비트 마스킹으로 수행된다.b2FixtureDef playerFixtureDef, monsterFixtureDef;playerFixtureDef.filter.categoryBits = 0x0002;monsterFixtureDef.filter.categoryBits = 0x0004;playerFixtureDef.filter.maskBits = 0x0004;monsterFixtureDef.filter.maskBits = 0x0002; 충돌이 발생하는 규칙은 다음과 같다.uint16 catA = fixtureA.filter.categoryBits;uint16 maskA = fixtureA.filter.maskBits;uint16 catB = fixtureB.filter.categoryBits;uint16 maskB = fixtureB.filter.maskBits;if ((catA &amp;amp; maskB) != 0 &amp;amp;&amp;amp; (catB &amp;amp; maskA) != 0){ // fixtures can collide} 충돌 그룹을 사용하면 통합 그룹 인덱스를 지정할 수 있다. 동일한 그룹 인덱스를 가진 모든 fixture가 항상 충돌(양수 인덱스)하거나 충돌하지 않도록(음수 인덱스) 할 수 있다. 이것은 일반적으로 자전거 부품과 같이 관련성이 있는 항목에 사용된다. 아래의 예에서 fixture1 과 fixture2는 항상 충돌하지만 fixture3과 4는 절대 충돌하지 않는다. fixture1Def.filter.groupIndex = 2;fixture2Def.filter.groupIndex = 2;fixture3Def.filter.groupIndex = -8;fixture4Def.filter.groupIndex = -8; 다른 그룹 인덱스의 fixture간의 충돌은 카테고리 및 마스크 비트에 따라 필터링된다. 즉, 그룹 필터링은 카테고리 필터링보다 우선순위가 높다. 추가적으로 알아야하는 필터링은 다음과 같다. static body에 붙은 fixture는 오직 dynamic 과 충돌 kinematic body에 붙은 fixture는 오직 dynamic 과 충돌 같은 body에 붙은 fixtures는 결코 서로 충돌하지 않는다. 추가적으로 joint로 연결된 body의 fixture간의 충돌을 선택적으로 활성화/비활성화 할 수 있다. 때때로 fixture가 이미 생성된 후에 filtering을 변경해야할 수 있다. GetFilterData, SetFilterData를 사용하여 b2Filter 구조를 가져오고 설정할 수 있다. 필터 데이터를 변경해도 다음 time step까지 접촉점(contacts)이 추가되거나 제거되지 않는다. (world class) 5.2.6. Sensors 두개의 fixture가 겹치지만 충돌 응답이 없어야 할 때. 센서는 충돌을 감지하지만 응답을 생성하지 않는 fixture이다. 모든 fixture를 센서로 표시할 수 있다. static, kinematic, dynamic 센서와 solid fixture를 혼합하여 사용할 수 있다. 센서는 최소한 하나의 body가 동적일 때만 접점을 형성(감지)한다. 센서는 접점을 생성하지 않는다. 두가지 방법으로 센서 상태를 가져올 수 있다. b2Contact::IsTouching b2ContactListener::BeginContact and b2ContactListener::EndContact 5.3. JointsJoint DefinitionJoint FactoryUsing JointsDistance JointRevolute JointPrismatic JointPulley JointGear JointMouse JointWheel JointWeld JointRope JointFriction JointMotor JointWheel Joint5.4. ContactsContact ClassAccessing ContactsContact Listenershaperigid bodyfixtureconstraintcontact constraintjointjoint limitjoint motorworldsolvercontinuous collisionb2_staticBodyb2_kinematicBodyb2_dynamicBodycontact pointcontact normalcontact separationcontact manifoldnormal impulsetangent impulsecontact idsBegin Contact EventEnd Contact EventPre-Solve EventPost-Solve EventContact Filtering5.5. World b2World 클래스에는 bodies 그리고 joints이 포함된다. 이것은 시뮬레이션의 모든 측면을 관리하고, 비동기 쿼리를 할 수 있게해준다. (AABB쿼리, 레이캐스트) Box2D와의 대부분의 상호 작용은 b2World 객체와 함께 수행된다.5.5.1. Creating and Destroying a World 중력 벡터와 body가 sleep 상태로 변할 수 있는지에 대한 여부만 넘겨주면 된다. 일반적으로 포인터를 사용하여 생성, 해제 한다.b2World* myWorld = new b2World(gravity, doSleep);// ... do stuff ...delete myWorld;5.5.2. Using a World world 클래스에는 body와 조인트를 생성하고 파괴하는 팩토리가 있다. 그 외에 여러 상호작용을 지원한다.5.5.2.1. Simulation world 클래스는 시뮬레이션을 구동하는데 사용된다. time step 과 velocity, position iteration count 를 지정해야한다.float timeStep = 1.0f / 60.f;int32 velocityIterations = 10;int32 positionIterations = 8;myWorld-&amp;gt;Step(timeStep, velocityIterations, positionIterations); time step 후에 body와 joints에 대한 검사를 수행할 수 있다. actor를 업데이트하고 렌더링할 수 있도록 body에서 position을 가져올 수 있다. 게임 루프 어느 곳에서든 timestep을 수행할 수 있다. 예를들어, 해당 프레임의 새로운 body에 대한 충돌 결과를 얻으려면 time step이전에 body를 생성해야한다. 고정된 timestep을 사용해야한다. (더 큰 time step은 low frame rate 시나리오에서 성능을 높일 수 있다.) 일반적으로 1/30 보다 작은 time step을 사용한다. (1/60은 고품질 시뮬레이션) 반복횟수는 제약 조건 솔버가 world의 모든 contacts 과 joints을 sweep하는 횟수를 제어한다. 더 많은 반복은 더 나은 시뮬레이션을 생성한다. (하지만 60hz에서 10번 반복이 30hz에서 20회 반복보다 더 좋다) stepping 후에는 body에 적용하고 있는 모든 forces를 제거해야한다. clearforces 함수를 통해 수행할 수 있다. myWorld-&amp;gt;ClearForces();5.5.2.2. Exploring the World body, contact, joint 리스트들을 가져와 탐색할 수 있다. 아래의 코드는 모든 body를 깨우는 코드이다.for (b2Body* b = myWorld-&amp;gt;GetBodyList(); b; b = b-&amp;gt;GetNext()){ b-&amp;gt;SetAwake(true);} 실제 코드에 적용하려면 좀 더 복잡해진다. 예를들어 아래는 오류가 발생할 수 있다.for (b2Body* b = myWorld-&amp;gt;GetBodyList(); b; b = b-&amp;gt;GetNext()){ GameActor* myActor = (GameActor*)b-&amp;gt;GetUserData().pointer; if (myActor-&amp;gt;IsDead()) { myWorld-&amp;gt;DestroyBody(b); // ERROR: now GetNext returns garbage. }} 만약 위처럼 조회하던 중에 body가 파괴되면(죽은 캐릭터를 파괴), next 포인터는 쓰레기값을 리턴한다. 이를 해결하기 위해서는 body를 파괴하기전에 next 포인터를 복사하는것이다.b2Body* node = myWorld-&amp;gt;GetBodyList();while (node){ b2Body* b = node; node = node-&amp;gt;GetNext(); GameActor* myActor = (GameActor*)b-&amp;gt;GetUserData().pointer; if (myActor-&amp;gt;IsDead()) { myWorld-&amp;gt;DestroyBody(b); }} 위 코드는 현재의 body를 안전하게 제거하지만, 만약 여러 body를 제거하려면 다음과 같이 코드를 짜야한다. (GameCrazyBodyDestroyer에서 body가 삭제되면, 다시 world 쿼리)b2Body* node = myWorld-&amp;gt;GetBodyList();while (node){ b2Body* b = node; node = node-&amp;gt;GetNext(); GameActor* myActor = (GameActor*)b-&amp;gt;GetUserData().pointer; if (myActor-&amp;gt;IsDead()) { bool otherBodiesDestroyed = GameCrazyBodyDestroyer(b); if (otherBodiesDestroyed) { node = myWorld-&amp;gt;GetBodyList(); } }}5.5.2.3. AABB Queries 경우에 따라 영역에 있는 모든 shape를 확인하고 싶을 때가 있다. b2World 클래스는 이를 위해 광범위한 데이터 구조를 사용해 log(N)방법을 사용한다. 쿼리하기 위해서 world 좌표를 가진 AABB와 b2QueryCallback을 구현해야한다. 예를 들어 다음 코드는 지정된 AABB와 겹치는 모든 fixture 를 찾고 관련된 모든 body를 깨운다.class MyQueryCallback : public b2QueryCallback{public: bool ReportFixture(b2Fixture* fixture) { b2Body* body = fixture-&amp;gt;GetBody(); body-&amp;gt;SetAwake(true); // Return true to continue the query. return true; }};// Elsewhere ...MyQueryCallback callback;b2AABB aabb;aabb.lowerBound.Set(-1.0f, -1.0f);aabb.upperBound.Set(1.0f, 1.0f);myWorld-&amp;gt;Query(&amp;amp;callback, aabb); You cannot make any assumptions about the order of the callbacks.5.5.2.4. ?Ray Casts? 레이 캐스트를 통해 가시선 검사(line-of-sight check), 총 발사(fire gun) 등을 수행할 수 있다. 콜백 클래스를 구현하고, 시작점과 끝점을 제공하여 광선 투사를 수행해야한다. world 클래스는 광선 투사를 수행한다. world 클래스는 구현한 클래스에 광선에 맞은 fixture를 보고한다. 콜백은 fixture, 교차점, 단위 법선 벡터 및 광선에 따른 fractional distance를 함께 제공한다. 콜백의 순서에 대해 어떠한 가정도 할 수 없다. 반환된 fraction을 통해 레이 캐스트의 연속을 제어한다. fraction이 0일 경우, 레이 캐스트가 종료되어야함을 나타낸다. 1일 경우 적중이 발생하지 않아, 계속되어야함을 나타낸다. 만일 인수목록에서 fraction을 반환하면, 광선이 현재 교차점으로 잘린다. 따라서 모든 shape를 레이 캐스팅하거나, 어느 한 shape를 레이캐스팅하거나, 적절한 fraction을 반환하여 가장 가까운 shape를 레이캐스팅할 수있다. fixture를 필터링하기 위해 -1의 분수를 반환할 수 있다. 이러면 fixture가 존재하지 않는 것처럼 레이 캐스트가 진행된다. // This class captures the closest hit shape.class MyRayCastCallback : public b2RayCastCallback{public: MyRayCastCallback() { m_fixture = NULL; } float ReportFixture(b2Fixture* fixture, const b2Vec2&amp;amp; point, const b2Vec2&amp;amp; normal, float fraction) { m_fixture = fixture; m_point = point; m_normal = normal; m_fraction = fraction; return fraction; } b2Fixture* m_fixture; b2Vec2 m_point; b2Vec2 m_normal; float m_fraction;};// Elsewhere ...MyRayCastCallback callback;b2Vec2 point1(-1.0f, 0.0f);b2Vec2 point2(3.0f, 1.0f);myWorld-&amp;gt;RayCast(&amp;amp;callback, point1, point2); Caution: Due to round-off errors, ray casts can sneak through small cracks between polygons in your static environment. If this is not acceptable in your application, trying slightly overlapping your polygons.6. Loose Ends6.1. User Data6.2. Custom User Data6.3. Implicit Destruction6.4. Pixels and Coordinate Systems6.5. Debug Drawing6.6. Limitations7. linkshttps://box2d.org/documentation/https://self-toeic.tistory.com/entry/Box2D-220-%ED%95%9C%EA%B8%80%ED%99%94-Chapter1-Introduction-Box2D-v220-User-Manualhttps://analog-green.tistory.com/511http://kimilb412-2.blogspot.com/2014/02/https://www.youtube.com/watch?v=IcVtjuwxlj4https://www.youtube.com/watch?v=kEClRFKyGkw&amp;amp;t=730shttp://www.iforce2d.net/b2dtut/introduction" }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: Observer", "url": "/posts/2022/02/21/00/23/pattern4/", "categories": "pattern", "tags": "", "date": "2022-02-21 00:23:49 +0900", "snippet": "Observer Model-View-Controller 아키텍처의 기반이 되는것이 Observer 패턴 MVC는 Smalltalkers에 의해 발명되었다.Achievement Unlocked 게임에 업적 시스템을 추가한다고 가정. 게임의 업적은 게임 플레이의 다양한 측면에 의해 유발된다. 업적 코드를 모두에 연결하지 않고 작동: 옵저버 패턴이 필요한 이유 객체와 객체간의 관심사를 분리해야한다. 다리에 딸어지는 업적코드는 다음과 같이 구현할 수 있다. 물리 엔진이 알림을 주게하는것. 보낼 알람을 결정해야하므로 완전한 분리가 아님. 이 알림을 받아, 떨어지는 객체가 무엇인지, 이전의 장소가 어디였는지를 확인할 수 있다. void Physics::updateEntity(Entity&amp;amp; entity){ bool wasOnSurface = entity.isOnSurface(); entity.accelerate(GRAVITY); entity.update(); if (wasOnSurface &amp;amp;&amp;amp; !entity.isOnSurface()) { notify(entity, EVENT_START_FALL); }} 이 알림은 누가 받든지 상관하지 않는다.작동원리The Observer 다른 객체가 흥미로운 작업을 수행할 때를 알려는 클래스가 필요하며, 인터페이스는 다음과 같다.class Observer{public: virtual ~Observer() {} virtual void onNotify(const Entity&amp;amp; entity, Event event) = 0;}; 일반적인 매개변수는 알림을 보낸 객체와 다른 세부정보인 데이터이다. 업적 시스템은 다음과 같다.(엔티티에 무슨일이 일어났는지 열거형을 사용하여 하드 코딩함)class Achievements : public Observer{public: virtual void onNotify(const Entity&amp;amp; entity, Event event) { switch (event) { case EVENT_ENTITY_FELL: if (entity.isHero() &amp;amp;&amp;amp; heroIsOnBridge_) { unlock(ACHIEVEMENT_FELL_OFF_BRIDGE); } break; // Handle other events, and update heroIsOnBridge_... } }private: void unlock(Achievement achievement) { // Unlock if not already unlocked... } bool heroIsOnBridge_;};The subject 대상: 알림 메서드는 관찰중인 객체에 의해 호출된다. observers의 리스트를 가지고 있어야한다. 알림을 보내야한다. class Subject{private: Observer* observers_[MAX_OBSERVERS]; // 실제 코드에선 동적 컬렉션을 사용하는것이 좋다. int numObservers_;}; 대상은 해당 리스트를 수정하기 위해 API를 노출해야한다.class Subject{public: void addObserver(Observer* observer) { // Add to array... } void removeObserver(Observer* observer) { // Remove from array... } // Other stuff...}; 이를 통해 알림 받는 객체를 제어할 수 있다. 대상은 observer와 상호작용하지만 커플링되어있지 않음. 리스트를 가지고 있는것은 중요하다. observer들이 서로 암묵적으로 연결되지 않도록한다. 하나의 observer: 하나를 추가하면 다른 하나는 비활성화 == 간섭이 일어남 알림은 다음과 같이 보낸다. class Subject{protected: void notify(const Entity&amp;amp; entity, Event event) { for (int i = 0; i &amp;lt; numObservers_; i++) { observers_[i]-&amp;gt;onNotify(entity, event); } } // Other stuff...};Observable physics 위에 작성한것을 물리 엔진에 붙일 수 있다.class Physics : public Subject{public: void updateEntity(Entity&amp;amp; entity);}; 실제 코드에서는 상속을 사용하지 않는다. 대상은 물리엔진이 아니라, “떨어지는 이벤트” 객체가 된다. observer는 다음과 같이 자신을 등록할 수 있다. physics.entityFell().addObserver(this); , 이것이 바로 “observer” 시스템과 “event” 시스템의 차이점 (전자는 흥미로운 일을 관찰, 후자는 흥미로운 일을 나타내는 대상을 관찰) 일부 인터페이스의 인스턴스에 대한 포인터 목록을 유지관리하는 하나의 클래스가 subject성능너무 느리다? 옵저버 패턴은 “events”, “messages”, “data binding” 라고 평가받는다.(부정적) 이러한 시스템 중 일부는 느릴 수 있다.(각 알림에 대해 대기열을 지정하는 등 동적 할당을 수행 하는 작업이 포함) 하지만 이 패턴은, 알림을 보내는 작업은 단순히 리스트를 보고 몇몇 가상 메서드를 호출하는 것이다. 정적으로 디스패치된 호출보다는 약간 느리지만, 성능이 가장 중요한 코드를 제외한 모든 코드에서 이 비용은 무시할 수 있다. 이 패턴은 hot code paths에 가장 적합하므로, 일반적으로 동적 디스패치를 감당할 수 있다. 그 외의 오버헤드는 없다. message를 위한 객체 할당이 없음 대기열이 없음 동기 메서드 호출에 대한 간접 참조일 뿐. 너무 빠르다? 동기식이기 때문에 주의해야한다. 대상은 옵저버를 직접 호출한다. 즉, 모든 옵저버의 알림 메서드를 호출할 때 까지 작업을 하지 않는다. 느린 옵저버는 대상을 멈추게 한다. 너무 느려질 경우 다른 스레드나 작업 대기열로 푸시해야한다. 하지만 스레딩 및 명시적 잠금을 혼합하는것은 주의해야한다. 교착상태(deadlock)가 일어날 수 있기 때문. 스레드가 많은 엔진에서는 Event Queue를 사용하는 비동기식 통신이 더 나을 수 있다.너무 많은 동적할당? GC가 있는 managed language라도 메모리 할당은 중요하다. 많은 게임 개발자는 할당에 대해 덜 걱정하고, 조각화(fragmentation)에 대해 더 걱정한다. 게임이 지속적으로 실행되어야하는 경우 점점 파편화되가는 힙이 문제가 될 수 있다. Object Pool을 사용하면 이를 피할 수 있다. 실제 구현에서 옵저버 리스트는 동적으로 할당된 컬렉션으로 구현한다. 연결될 때만 메모리를 할당한다. 알림을 보내는데 메모리 할당은 일어나지 않는다.(단순한 메서드 호출) 게임 시작시 옵저버를 연결하는 것이 좋다. Linked observers 동적할당자(vector) 없이 옵저버 추가 및 제거 Interface는 구체적인 상태 저장 클래스보다 선호되므로 일반적으로 좋은것. 그러나 우리가 약간의 상태를 넣을 의향이 있다면, 할당문제를 해결할 수 있다. 별도의 리스트 대신, 링크드 리스트의 노드를 사용. 배열을 제거하고 헤드에 대한 포인터를 추가class Subject{ Subject() : head_(NULL) {} // Methods...private: Observer* head_;}; Observer에 다음 Observer에 대한 포인터를 가지도록 확장한다.class Observer{ friend class Subject;public: Observer() : next_(NULL) {} // Other stuff...private: Observer* next_;}; 대상은 옵저버를 추가 및 제거하기 위한 API를 소유하지만, 관리할 리스트는 이제 Observer 클래스에 있다. 그 리스트를 건드릴 수 있게 friend로 subject를 삼는다. 새 옵저버를 등록하는 것은 리스트에 연결하는것이며, 쉬운 방법은 앞쪽에 삽입하는것이다. 뒤에 추가하는것보다 간단. 이 경우, 끝을 찾기위해 리스트를 탐색하거나 꼬리 포인터를 추가해야한다. 앞에 추가하는 것의 부작용: 가장 최근에 등록한 것이 먼저 알림을 받는다. (동일한 대상을 관찰하는 두 옵저버가 서로에 대한 순서 종속성이 없는것이 좋긴하다.) void Subject::addObserver(Observer* observer){ observer-&amp;gt;next_ = head_; head_ = observer;} 제거는 다음과 같다.void Subject::removeObserver(Observer* observer){ if (head_ == observer) { head_ = observer-&amp;gt;next_; observer-&amp;gt;next_ = NULL; return; } Observer* current = head_; while (current != NULL) { if (current-&amp;gt;next_ == observer) { current-&amp;gt;next_ = observer-&amp;gt;next_; observer-&amp;gt;next_ = NULL; return; } current = current-&amp;gt;next_; }} 더블 포인터를 사용하면 더 깔끔하다. 알림은 다음과 같이 보낸다.void Subject::notify(const Entity&amp;amp; entity, Event event){ Observer* observer = head_; while (observer != NULL) { observer-&amp;gt;onNotify(entity, event); observer = observer-&amp;gt;next_; }} 전체 목록을 살펴보고, 그 안의 모든 옵저버에게 알림. 이렇게 하면, 모든 옵저버가 동일한 우선순위를 가지며, 서로 독립적이다. 옵저버가 알림을 받으면 계속 탐색하는지 멈춰야하는지를 나타내는 플래그를 반환할 수 있도록 조정할 수 있다 =&amp;gt; 책임사슬 패턴에 근접 장점: 대상이 동적메모리를 가지지 않고 원하는 만큼 옵저버를 가질 수 있고, 등록 및 등록 취소가 배열만큼 빠르다. 단점: 옵저버는 한 번에 하나의 대상만 관찰할 수 있다. 각 대상이 배열을 가지면, 옵저버가 동시에 둘 이상의 리스트에 있을 수 있기 때문. 하지만, 대상이 여러 옵저버를 갖는것이 더 일반적이다. A pool of list nodes 노드가 옵저버 자체가 아닌것. 옵저버에 대한 포인터를 가진 리스트 노드 객체 여러 노드가 모두 같은 옵저버를 가리킬 수 있기 때문에 옵저버는 동시에 둘 이상의 대상 리스트에 포함되어 있을 수 있다. 앞에서 본 링크드 리스트와는 다르게 이제 대상을 동시에 관찰할 수 있다. 링크드 리스트는 두가지 형태이다. 데이터가 포함된 노드 객체(앞서 본 예제)형태 그리고, “intrusive” 링크드 리스트로 침입 리스트를 덜 유연하게 하지만 효율적 (리스트에서 객체를 사용하는 것이 해당 객체 자체의 정의를 침해, Linux 커널과 같은 곳에서 인기있음.) 동적 할당을 피하는 방법은 간단하다. 모든 노드의 크기와 타입이 동일하기 때문에, 해당 노드의 오브젝트 풀을 미리 할당하면, 필요에 의해 재사용할 수 있다. Remaining Problems 옵저버 패턴은 정확하고 효율적으로 구현하더라도 올바른 솔루션이 아닐 수 있다. 두 문제가 남아 있다. 기술적인것 유지관리 기술적인것: Destroying subjects and observers 대상이나 옵저버를 삭제할 경우 포인터… 할당 해제된 메모리에 대한 댕글링 포인터 문제 대부분 구현에서 옵저버가 대상에 대한 참조를 가지고 있지 않기 때문에, 대상을 파괴하는 것은 더 쉽다. 하지만 그래도 문제가 발생할 수 있다. 남아 있는 옵저버들은 알림을 대기하며, 알림이 일어나지 않을 것이라는 사실을 모른다. 해결방법 어떤 대상에서든 옵저버를 등록해제 하는 작업은 옵저버가 옵저버는 관찰중인 대상을 알고 있으므로 일반적으로 소멸자에 대한 호출을 추가하면 된다. 대상이 파괴되는 직전에 파괴된다는 알림을 보내도록하고,이를 받는 옵저버에서 적절히 처리하면된다. 더 안전한 방법은 옵저버가 파괴될 때 모든 대상에서 자동으로 옵저버를 등록취소하도록 하는것. 약간의 복잡성이 생긴다. 각 옵저버가 관찰대상의 리스트가 필요하다는것을 의미한다. Don’t worry, I’ve got a GC GC가 있더라도, 참조가 제거되지 않으면 가비지가 누적된다. lapsed listener problem 이라 부르는 것. 등록 취소의 필요성 What’s going on? 의도한 목적의 직접적인 결과 두 코드 조각 간의 결합을 느슨하게 한다. 간접적으로 통신. 만약 옵저버 체인에 버그가 있을 경우, 런타임에 옵저버를 확인해야한다. 정적 추론 대신에, 명령적이고 동적인 행동에 대해 추론해야한다. 이를 대처하는 방법: 프로그램의 일부를 이해하기 위해 양쪽에 대해 자주 생각해야하는 경우 옵저버 패턴을 사용하지 않으면 된다. 다른 하나에 대한 지식이 적어도 다른 하나에 대해 작업을 할 수 있을 경우에만 옵저버 사용. 관찰자 패턴은 대부분 관련이 없는 덩어리들을 하나의 큰 덩어리로 병합하지 않고 서로 대화할 수 있도록 하는 좋은 방법이다. 하나의 기능에 전념하는 단일 코드 덩어리 안에서는 덜 유용 Observers Today 대부분 이제 주로 함수형 프로그래밍에 익숙해졌음. 알림을 받기 위해 전체 인터페이스를 구현해야 하는 것은 오늘날에 맞지 않음 서로 다른 대상에 대해 서로 다른 알림 방법을 사용하는 단일 클래스를 가질 수 없다. 여러 대상을 관찰할 경우, 어느쪽이 호출했는지 알 수 있어야한다. 현대적인 접근방식: 옵저버가 한 메서드나 함수에 대한 참조 일급함수가 있는 언어, 클로저가 있는 언어에서는 이것이 일반적인 방법이다. 클래스 기반이 아닌 함수 기반으로 만드는것이 좋다. C++에서도 옵저버를 멤버 함수 포인터를 등록할 수 있는 시스템이 더 좋다. 구현예시 Observers Tomorrow 이벤트 시스템, 옵저버 패턴과 유사한 패턴은 오늘날 매우 일반적이다. 옵저버의 많은 코드는 동일하게 보일 수 있다. 일부 상태가 변경되었다는 알림 새 상태를 반영하도록 일부 UI 청크를 불가피하게 수정 최근의 많은 애플리케이션 프레임워크는 “데이터 바인딩”을 사용한다. 급진적인 모델과 달리 데이터 바인딩은 명령형 코드를 완전히 제거하려고 하지 않으며, 거대한 선언적 데이터 플로우 그래프를 중심으로 전체 애플리케이션을 설계하지 않는다. UI요소 또는 계산된 속성을 조정하여 일부 값에 대한 변경 사항을 반영하는 바쁜 작업을 자동화하는것. 다른 선언적 시스템과 마찬가지로 데이터 바인딩은 게임 엔진 코어에 맞추기에는 너무 느리고 복잡하다. UI와 같은 성능에 덜 민감한 분야에서는 사용할 수 있다. 출처Observer" }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: Flyweight", "url": "/posts/2022/02/20/07/56/pattern3/", "categories": "pattern", "tags": "", "date": "2022-02-20 07:56:31 +0900", "snippet": "FlyweightForest for the Trees 실시간 게임에서 거대한 삼림 지대를 구현하는것은 어렵다. 수천 개의 폴리곤을 포함하는 상세한 지오메트리를 가진 수천개의 나무. 해당 숲을 설명하기에 충분한 메모리가 있더라도, 렌더링할 때 데이터가 버스를 통해 cpu에서 gpu로 이동해야한다. 각 나무는 연관된 비트가 있다. 줄기, 가지, 등 다각형 mesh 나무 껍질 등의 Texture 숲속에서의 위치와 방향 각 나무가 다르게 보이도록 크기 및 색조와 같은 매개변수 코드로 나타내면 다움과 같다.class Tree{private: Mesh mesh_; Texture bark_; Texture leaves_; Vector position_; double height_; double thickness_; Color barkTint_; Color leafTint_;}; 많은 데이터가 필요하며, 특히 메시와 텍스처가 크다. 이 데이터들을 가지는 숲을 한 프레임에서 GPU에 주기에는 너무 크다. 하지만 아래와 같은 특징을 가지고 있으며, 이를 해결할 트릭이 있다. 수천 그루의 나무가 있어도, 대부분 비슷해보인다. 그들은 모두 같은 메쉬, 텍스처를 사용한다. 대부분의 필드가 모든 인스턴스간에 동일하다. 객체를 반으로 분할하여 모델링할 수 있다.class TreeModel{private: Mesh mesh_; Texture bark_; Texture leaves_;}; 동일한 메시와 텍스처는 하나만 있어도 된다. 이제 각 나무의 인스턴스는 공유된 참조 TreeModel을 가지고 있게된다. 나머지 변수들은, 각 인스턴스의 상태이다.class Tree{private: TreeModel* model_; Vector position_; double height_; double thickness_; Color barkTint_; Color leafTint_;}; 이는 TypeObject 패턴과 유사하다. 둘다 객체 상태의 일부를 여러 인스턴스 간에 공유되는 다른 객체에 위임하는것을 포함한다. 하지만 의도는 다르다. . . TypeObject “type”을 고유한 객체 모델로 들어올려 정의해야하는 클래스 수를 최소화, 그로부터 얻는 메모리 공유는 보너스 Flyweight 순전히 효율성에 관한것 메인 메모리에 물건을 저장하는데 모두 훌륭하지만, 렌더링에는 두움이 되지않는다. 숲이 화면에 나타나기전에 GPU로 넘어가야한다. 이 리소스 공유를 그래픽 카드가 이해하는 방식으로 표현해야한다. A Thousand Instances GPU에 푸시해야하는 데이터 양을 최소화하기 위해, 공유 데이터를 한번만 보낼 수 있어야한다. 그 후, 개별적으로 모든 나무 인스턴스의 데이터를 푸시 마지막으로, GPU에게 하나의 모델을 사용하여 렌더링하라고 지시해야한다. 오늘날의 그래픽 API는 이를 지원한다. 인스턴스 렌더링 그래픽스 API는 두가지 데이터 스트림을 제공한다. 공통 데이터 덩어리(메시, 텍스처) 그릴때마다 첫번째 데이터 청크를 변경하는 데 사용되는 인스턴스 및 해당 매개변수의 목록. 인스턴스 렌더링을 통해 한번의 드로우 콜로 전체 숲을 표현할 수 있다. API가 그래픽카드에 의해 직접 구현된다는 사실은 Flyweight 패턴이 실제 하드웨어를 지원하는 유일한 GOF디자인 패턴일 수 있음을 의미한다.The Flyweight Pattern flyweight는 일반적으로 너무 많은 객체가 있기 때문에 더 가벼워야하는 객체가 있을때 사용한다. 인스턴스 렌더링의 기본 아이디어와 동일하다. 패턴은 객체의 데이터를 두 종류로 분리하여 문제를 해결한다. 공유할 항목(intrinsic state, context-free): 메시, 텍스 고유한 외부 상태: 나무의 위치, 크기, 색상 공유상태에 대한 명확한 별도의 TreeModel을 제시할 수 있기 때문에 패턴이라고 부를 수 있다.(기본적으로 그저 자원공유처럼 보임) 공유객체에 대해 제대로 정의된 ID가 없으면 이 패턴은 덜 명확해진다(더 영리해짐?).A Place To Put Down Roots 이 나무들이 자라는 땅은 바닥 타일기반이라고 가정. world의 표면은 작은 타일의 거대한 그리드 각 타일은 한 종류의 지형으로 덮여있다. 지형 타입은 게임플레이에 영향을 준다. 통과 속도를 결정하는 이동 비용 보트를 이용할 수 있는지에 관한 플래그 렌더링에 사용되는 텍스처 효율적으로 처리하기위해, 지형 유형을 열거형으로 나타냄enum Terrain{ TERRAIN_GRASS, TERRAIN_HILL, TERRAIN_RIVER // Other terrains...}; world는 다음과 같은 거대한 그리드를 유지한다.class World{private: Terrain tiles_[WIDTH][HEIGHT];}; 중첩배열을 사용하여 2D그리드를 저장하는것은 C/C++에서 효율적이다. Java 같은 메모리 관리 언어에서는 그렇지 않을 수 있다.(열배열에 대한 참조인 행 배열, C++은 연속된 묶음) 좋지않은 코드는 타일에대한 데이터는 아래처럼 얻는다. 단일 지형 유형에 대한 데이터가 여러 메서드에 걸쳐 번진다. 캡슐화하는것이 좋다. int World::getMovementCost(int x, int y){ switch (tiles_[x][y]) { case TERRAIN_GRASS: return 1; case TERRAIN_HILL: return 3; case TERRAIN_RIVER: return 2; // Other terrains... }}bool World::isWater(int x, int y){ switch (tiles_[x][y]) { case TERRAIN_GRASS: return false; case TERRAIN_HILL: return false; case TERRAIN_RIVER: return true; // Other terrains... }} 다음과 같이 클래스로 설정하는것이 좋다.class Terrain{public: Terrain(int movementCost, bool isWater, Texture texture) : movementCost_(movementCost), isWater_(isWater), texture_(texture) {} int getMovementCost() const { return movementCost_; } bool isWater() const { return isWater_; } const Texture&amp;amp; getTexture() const { return texture_; }private: int movementCost_; bool isWater_; Texture texture_;}; const타입을 사용하는것은 어찌보면 당연하다. 동일한 객체가 여러 문맥에서 사용되기 때문에, 수정하면 변경사항이 동시에 반영된다. 이 때문에 flyweight 객체는 거의 항상 불변이다. 그러나 world의 각 타일에 대한 인스턴스를 갖는 비용을 지불하지 않는 것이 좋다. 모든 지형상태는 “intrinsic”이거나 “context-free” 상태여야한다. 각 지형 타입을 둘이상 가질 필요가 없다. 열거형 대신 객체에대한 포인터의 그리드를 Terrain로 삼아야한다. class World{private: Terrain* tiles_[WIDTH][HEIGHT]; // Other stuff...}; 동일한 지형을 사용하는 각 타일은 동일한 지형 인스턴스를 가진다. 지형 인스턴스는 여러 위치에서 사용되기 때문에, 동적으로 할당하는 경우 수명을 관리하기 복잡하다. 그렇기 때문에, world에 직접 저장. class World{public: World() : grassTerrain_(1, false, GRASS_TEXTURE), hillTerrain_(3, false, HILL_TEXTURE), riverTerrain_(2, true, RIVER_TEXTURE) {}private: Terrain grassTerrain_; Terrain hillTerrain_; Terrain riverTerrain_; // Other stuff...}; 그런 다음, 이것들을 사용하여 다음과 같이 땅을 칠할 수 있다.void World::generateTerrain(){ // Fill the ground with grass. for (int x = 0; x &amp;lt; WIDTH; x++) { for (int y = 0; y &amp;lt; HEIGHT; y++) { // Sprinkle some hills. if (random(10) == 0) { tiles_[x][y] = &amp;amp;hillTerrain_; } else { tiles_[x][y] = &amp;amp;grassTerrain_; } } } // Lay a river. int x = random(WIDTH); for (int y = 0; y &amp;lt; HEIGHT; y++) { tiles_[x][y] = &amp;amp;riverTerrain_; }} world에서 이제 Terrain 객체를 직접 노출할 수 있다.const Terrain&amp;amp; World::getTile(int x, int y) const{ return *tiles_[x][y];} 타일의 일부 속성을 원하는 경우 해당 객체에서 바로 가져올 수 있다.int cost = world.getTile(2, 3).getMovementCost(); 포인터를 사용하는것은 보통 열거형보다 오버헤드가 크지 않다.Performance 포인터로 지형을 참조 == 간접 조회(indirect lookup)를 의미 포인터를 추적하면 캐시 미스가 발생하여 속도가 느려질 수 있다. 포인터 추적 및 개시 미스: 데이터 지역성 최적화의 황금률: 프로파일 우선 저자의 테스트로는, flyweight 을 사용하는데 불이익은 없었고, 성능은 좋았다. 이러한 성능은 하지만 메모리 배치에 영향을 받는다.(그러므로 프로파일링) 이 패턴의 장점은, 객체 지향 스타일의 이점을 제공한다는것. 참고 Factory Method 패턴: 동적으로 생성: flyweight를 미리 만들고 싶지 않을 경우, 주문형으로 인스턴스를 생성했는지 확인하고 해당 인스턴스 반환 생성자를 숨기는 패턴 객체 생성 시 생성하는 일 외에 다른 일이 동시에 필요하다면, 이를 관리하는 또 다른 객체를 만들어 생성하는 방법. Object pool: 이전에 생성된 flyweight를 반환하려면 이미 인스턴스화한 flyweight 풀을 추적해야함. 오브젝트 풀은 이를 도와줌. state 패턴: 상태 기계에서 사용되는 상태 객체에 멤버변수가 하나도 없는 경우, flyweight을 적용하면, 객체 하나를 여러 상태 기계에서 재사용할 수 있다. 출처flyweight" }, { "title": "[게임 프로그래밍 패턴] Design Patterns Revisited: Command", "url": "/posts/2022/02/20/02/01/pattern2/", "categories": "pattern", "tags": "", "date": "2022-02-20 02:01:21 +0900", "snippet": "Design Patterns Revisited Gang of Four 가 문서화한 몇가지 원본 패턴들을 설명한다. Singleton과 같은 패턴들은 과도하게 사용됨 Command와 같은 패턴은 과소평과됨.Command 올바른 곳에 사용하면 엉성한코드가 깔끔해짐. GOF에서는 아래와 같이 난해하게 설명한다. 요청을 객체로 캡슐화하여, 사용자가 다른 요청으로 클라이언트를 매개변수화하고, 요청을 대기열에 넣거나 기록하고, 취소할 수 없는 작업을 지원한다.(support undoable operations) 이 책의 저자는 아래와 같이 설명한다. Command는 구체화된 메서드 호출이다. (reified method call) reify: 실체화를 의미.(first-class or make real) 즉, 명령 패턴은 객체에 래핑된 메서드 호출을 의미한다. ex) “callback”, “first-class function”, “function pointer”, “closure”, or “partially applied function” reify: thingify를 의미함. (물건을 의미하는 라틴어 “res”에서 유래) reflection systems: 몇몇 언어의 시스템, 구체화된 타입 시스템, 그 타입이 무엇을 할 수 있는지 확인 가능 명령은 콜백에 대한 객체 지향 대체이다.Configuring Input 버튼, 키보드, 마우스 등의 입력을 받는다. 좋지 않은 예시는 다음과 같다.void InputHandler::handleInput(){ if (isPressed(BUTTON_X)) jump(); else if (isPressed(BUTTON_Y)) fireGun(); else if (isPressed(BUTTON_A)) swapWeapon(); else if (isPressed(BUTTON_B)) lurchIneffectively();} 이 함수는 일반적으로 게임루프에 의해 프레임당 한 번 호출된다. 많은 게임들은 사용자가 매핑방법을 구성하도록 한다. 이를 지원하려면 직접 호출을 교환할 수 있도록해야한다. 교체는 변수 할당과 유사하므로, 게임 동작을 나타내는 데 사용할 수 있는 객체가 필요하다. 트리거 가능한 게임 명령을 나타내는 기본 클래스는 다음과 같다.class Command{public: virtual ~Command() {} virtual void execute() = 0;}; 아무것도 반환하지 않는 단일 메서드가 있는 인터페이스가 있는 경우 Command 패턴일 가능성이 있다. 그런 다음 아래와 같이 서로 다른 게임 작업 각각에 대해 하위 클래스를 만든다.class JumpCommand : public Command{public: virtual void execute() { jump(); }};class FireCommand : public Command{public: virtual void execute() { fireGun(); }};// You get the idea... 인풋 핸들러에서 각 버튼에 대한 명령에 대해 포인터를 저장한다.class InputHandler{public: void handleInput(); // Methods to bind commands...private: Command* buttonX_; Command* buttonY_; Command* buttonA_; Command* buttonB_;}; 이제 입력 처리를 다음과 같이 변경할 수 있다.void InputHandler::handleInput(){ if (isPressed(BUTTON_X)) buttonX_-&amp;gt;execute(); else if (isPressed(BUTTON_Y)) buttonY_-&amp;gt;execute(); else if (isPressed(BUTTON_A)) buttonA_-&amp;gt;execute(); else if (isPressed(BUTTON_B)) buttonB_-&amp;gt;execute();} Null Object 패턴: 아무 작업도 수행하지 않는 버튼을 지원하려면, 메서드가 아무 작업도 수행하지 않는 클래스 정의. 각 입력이 함수를 직접호출하는 곳에 이제 간접 계층이 생겼다.Directions for Actors 위 예제는 잘 작동하지만, 상당히 제한적이다. 문제는 jump, firegun 함수 등이 있다고 가정하는것이다. 가정된 결합(커플링)은 해당 명령의 유용성을 제한한다, JumbCommand 를 사용하여 점프하는것은 오직 플레이어이다. 이 제한을 풀어야한다. 호출하는 함수가 명령할 객체를 찾는것이 아니라, 명령을 내릴 객체를 전달해야한다. class Command{public: virtual ~Command() {} virtual void execute(GameActor&amp;amp; actor) = 0;}; GameActor라는 캐릭터 객체 클래스가 있다고 가정한다. execute의 파생 명령어를 다음과 같이 한 액터의 메서드를 호출하도록 구현할 수 있다.class JumpCommand : public Command{public: virtual void execute(GameActor&amp;amp; actor) { actor.jump(); }}; 이제 이 한 클래스를 사용하여, 게임의 모든 캐릭터를 점프시킬 수 있다. 이제 올바른 객체를 호출하도록 수정해야한다. 먼저 handleInput() 은 다음과 같다.Command* InputHandler::handleInput(){ if (isPressed(BUTTON_X)) return buttonX_; if (isPressed(BUTTON_Y)) return buttonY_; if (isPressed(BUTTON_A)) return buttonA_; if (isPressed(BUTTON_B)) return buttonB_; // Nothing pressed, so do nothing. return NULL;} 어떤 액터를 전달할지 모르기 때문에 명령을 바로 실행하지 않도록 해야한다. 여기서 명령이 객체라는 사실을 활용한다. 객체를 받아서, 나중에 명령을 실행하도록 지연할 수 있다. 아래 코드와 같이 사용할 수 있다.Command* command = inputHandler.handleInput();if (command){ command-&amp;gt;execute(actor);} 이제 액터를 변경하여 플레이어가 게임의 모든 액터를 제어하도록 할 수 있다. world의 모든 actor들을 동일한 명령 패턴을 사용하여 컨트롤 가능. AI 엔진과 액터간의 인터페이스를 똑같이 구성할 수 있으며, AI 코드는 인풋과 같게 Command 객체를 리턴(방출 emit)한다. 여기에서 명령을 선택하는 AI와 명령을 수행하는 actor코드를 분리하면, 많은 유연성을 얻을 수 있다. 다른 actor에 대해 다른 AI 모듈을 사용할 수 있다. 다양한 종류의 행동에 대해 AI를 혼합하고, 일치시킬 수 있다. AI를 플레이어의 캐릭터에 고정할 수 있다(자동조종) 대기열 대기열이 할 수 있는일 : 이벤트대기열 actor를 제어하는 명령을 일급 객체로 만들어 직접적인 메서드 호출의 긴밀한 결합을 제거했다. 또한 대기열이나 명령 스트림을 생각할 수 있다. 일부 코드(입력핸들러, AI) 는 명령을 생성하여 스트림에 배치 다른 코드(디스패처, 액터)는 그 명령을 사용하고 호출한다. 대기열을 중간에 고정하여, 생산자와 소비자로 분리한것이라 생각할 수 있다. 이러한 명령을 받아 직렬화 가능하게 만들면, 네트워크를 통해 명령 스트림을 보낼 수 있다. 플레이어의 입력을 받아 네트워크를 통해 다른 시스템으로 푸시한 다음 다시 재생 가능, 이는 네트워크로 연결된 멀티플레이어 게임을 만드는데에 있어 중요한 부분 중 하나. Undo and Redo 실행취소는 마음에 들지 않는 동작을 되돌릴 수 있는 일부 전략게임에서 사용된다. Command 패턴이 없으면 실행취소를 구현하는것은 어렵다. Command를 사용하여 입력처리를 추상화하고 있으므로 플레이어가 수행하는 모든 움직임은 이미 캡슐화되어있다. 예를들면 유닛 이동은 다음과 같다.class MoveUnitCommand : public Command{public: MoveUnitCommand(Unit* unit, int x, int y) : unit_(unit), x_(x), y_(y) {} virtual void execute() { unit_-&amp;gt;moveTo(x_, y_); }private: Unit* unit_; int x_, y_;}; 이것은 이전 명령과 약간 다르다. 이것은 구체적인 이동 명령이다. 이것은 특정 시점에 할 수 있는 일을 나타낸다 이것은 플레이어가 움직임을 선택할 때마다 입력처리 코드가 이것의 인스턴스를 생성한다는 것을 의미한다. 앞선 예에서는 재사용가능한 객체로, 이벤트가 일어날 때마다 해당 메서드를 호출했다.Command* handleInput(){ Unit* unit = getSelectedUnit(); if (isPressed(BUTTON_UP)) { // Move the unit up one. int destY = unit-&amp;gt;y() - 1; return new MoveUnitCommand(unit, unit-&amp;gt;x(), destY); } if (isPressed(BUTTON_DOWN)) { // Move the unit down one. int destY = unit-&amp;gt;y() + 1; return new MoveUnitCommand(unit, unit-&amp;gt;x(), destY); } // Other moves... return NULL;} C++과 같은 GC가 아닌 언어에서 이는 명령을 실행하는 코드가 메모리를 해제해야하는 책임을 진다는 것을 의미한다. 명령이 1회용이라는 사실은 좋다. 명령 실행 취소를 정의하면된다.class Command{public: virtual ~Command() {} virtual void execute() = 0; virtual void undo() = 0;}; 메소드는 undo() 해당 메소드에 의해 변경된 게임 상태를 반전시킨다. 아래는 실행취소를 지원하는 undo 명령이다. 클래스에 이전 상태를 나타내는 변수를 추가하여 undo에 이 변수를 사용하여 복원시켰다. class MoveUnitCommand : public Command{public: MoveUnitCommand(Unit* unit, int x, int y) : unit_(unit), xBefore_(0), yBefore_(0), x_(x), y_(y) {} virtual void execute() { // Remember the unit&#39;s position before the move // so we can restore it. xBefore_ = unit_-&amp;gt;x(); yBefore_ = unit_-&amp;gt;y(); unit_-&amp;gt;moveTo(x_, y_); } virtual void undo() { unit_-&amp;gt;moveTo(xBefore_, yBefore_); }private: Unit* unit_; int xBefore_, yBefore_; int x_, y_;}; 이것은 Memento패턴을 위한 장소처럼 보이지만, 잘 작동하지는 않는다. Command는 객체 상태의 작은 부분만 수정하는 경향이 있다.(많은 정보 스냅샷 == 메모리 낭비). 변경하는 부분만 저장하는 것이 좋다. 영구 데이터 구조는 또 다른 옵션이다. 이를 통해 객체를 수정할때마다 새 객체가 반환되고, 원본은 변경되지 않는다. 이 때 명령은 명령이 수행되기 전에 객체에 대한 참조를 저장하고, 실행취소는 이전 객체로 다시 전환하는 것을 의미한다. 특정 이벤트로 undo()메소드를 호출하도록해야한다. (이미 취소된 경우, “redo”가 실행되도록) 여러 수준의 실행 취소를 지원하는 것은 그다지 어렵지 않다. 마지막 명령을 기억하는 대신, 명령 리스트와 “current” 명령에 대한 참조를 유지한다. 플레이어가 명령을 실행하면 목록에 추가하고 “current”를 가리킨다”. 플레이어가 “undo”를 선택하면, 현재 명령을 실행 취소하고 현재 포인터를 뒤로 이동한다. “redo”를 선택하면 포인터를 이동한 다음 해당 명령을 실행한다. 일부를 실행 취소한 후 새 명령을 선택하면, 현재 명령 뒤에 있는 리스트의 모든 항목이 삭제된다. 모든 데이터 수정이 명령을 통과하도록 하는 규일이이 필요하지만, 그 후에는 구현하기 쉬워진다. Redo는 게임에서 일반적이지 않지만, re-play는 일반적이다. Naive한 구현은 모든 프레임을 기록하여 리플레이하는것이지만, 너무 많은 메모리를 사용한다. 대신 모든 개체가 각 프레임에서 수행한 명령 집합을 기록하고, 사전 기록된 명령을 실행하여 시뮬레이션할 수 있다.참고 C++는 일급함수에 대한 지원이 부족하다(C++11기준) 함수포인터: 상태 비저장 펑터: 이상하고, 여전히 클래스 정의 람다: 수동 메모리 관리로 인해 작업하기 까다로움 Command 패턴은 closures가 없는 언어에서 closures를 예뮬레이트하는 방법 subclass sandbox 패턴 앞선 예제들은 액터를 명시적으로 선택했다. 경우에 따라 객체 모델이 계층적일 경우, 명확(cut and dried)하지않을 수 있음. 객체는 명령에 응답하거나 일부 종속 객체에 이를 떠넘기(pawn it off)기로 결정할 수 있다. =&amp;gt; 책임사슬 패턴 점프와 같은 명령어는 순수한 동작의 상태 비저장 청크이다. 이 경우 해당 클래스의 인스턴스가 두 개 이상 있으면, 모든 인스턴스가 동일하므로 메모리 낭비가 발생한다. =&amp;gt; 플라이 웨이트 패턴으로 해결가능하다. 이러한 것들을 싱글톤으로 만들 수 있지만 추천하지는 않는다.출처게임디자인패턴" }, { "title": "[게임 프로그래밍 패턴] Introduction", "url": "/posts/2022/02/19/22/59/pattern1/", "categories": "pattern", "tags": "", "date": "2022-02-19 22:59:30 +0900", "snippet": "아키텍처, 성능 및 게임sw 아키텍처 코드를 구성하는것이 중요. 저자에게 좋은 디자인이란, 변경한 부분을 더해도, 프로그램 전체가 그를 예상하고 작성된 것처럼 만들어진 것 아키텍처는 변화하고, 누군가는 코드베이스를 수정해야한다. 좋은 디자인은 변경사항을 쉽게 수용한다. 변경 코드를 변경하려면, 기존 코드가 수행하는 작업을 이해해야한다. 전체를 알 필요는 없지만 관련된 부분은 전부 이해해야함. 이 부분이 프로그래밍에서 가장 시간이 많이 걸리는 부분 올바른 문맥을 모두 파악한 후, 솔루션을 파악해야한다. 코드를 작성하고, 테스트를 작성하고, 코드 검토하기전 몇가지 정리 작업을 수행해야한다.디커플링 sw 아키텍처의 대부분은 학습 단계에 관한것이다. 코드 전체 부분을 이해하는데 더 빠르게하기 위한것.(코드의 양을 줄이는것) 디커플링 패턴 분리: 두 개의 코드가 결합되면, 다른 하나를 이해하지 않고는 하나를 이해할 수 없다. 분리하면, 독립적으로 추론 가능, 한 부분만 관련된 경우, 그 부분만 이해하면된다. 저자의 sw아키텍처의 핵심목표: 진행하기전에 필요한 지식의 양을 최소화하는것. 디커플링의 또 다른 정의: 코드의 한 부분에 대한 변경이 다른 부분에 대한 변경을 필요로 하지 않는다는것. 커플링이 적으면, 나머지 부분을 덜 변경할 수 있다. 비용 추상화, 모듈화, 디자인패턴, 소프트웨어 아키텍처: 생산성에 큰차이를 만들어줌 노력과 훈련이 필요 어떤 부분을 분리해야하는지 생각해야하고, 해당 지점에 추상화를 도입해야함. 확장성을 엔지니어링해야하는 위치를 결정해야함 이는 추측으로 이루어져, 여러 코드를 추가하게됨. 미래를 예측하는 것은 어렵고, 모듈화가 도움이 되지 않으면 해가된다. 더 많은 코드를 처리해야되는 상황이 일어남 무언가를 수행하는 실제 코드를 찾기 위해 모든 스캐폴딩을 추적해야함. 성능 및 속도 게임 성능이 저하: 가상 디스패치, 인터페이스, 포인터, 메시지 등은 런타임 비용이 있는 기타 메커니즘에 의존한다. 유연성: 변경하는 양을 줄이기 위한것. 더 빨리 프로토타입을 만들 수 있도록, 프로그램을 더 유연하게 만들면 성능 비용이 약간든다. (코드를 최적화하면 유연성이 떨어짐) 재미있는 게임을 빠르게 만드는것이 더 쉽다. 디자인이 안정될 때까지 코드를 유연하게 유지하고, 나중에 성능을 향상시키기 위해 일부 추상화를 제거하는것 나쁜 코드의 좋은점 게임 디자인은 많은 실험과 탐색이 필요 초기에는 버릴 것을 알고 있는 코드를 작성하는것이 일반적 게임플레이 아이디어가 작동하는게 우선. 프로토타이핑 주의사항 폐기코드를 작성하는 경우, 폐기할 수 있는지 확인해야함. -폐기코드를 사용하는것은 유지관리 할 수 없다는것을 의미하고, 다시 작성할 필요가 있다는것을 알아야함. 실제 코드가 될 필요가 없도록하는 방법: 다른 언어로 작성하는것균형잡기 프로젝트 생명주기 동안 코드를 더 쉽게 이해할 수 있는 멋진 아키텍처 빠른 런타임 성능 단기 개발속도 위의 목표들은 부분적으로 반비례한다. 좋은 아키텍처는 장기적으로 생산성을 향상, 하지만 이를 유지하기위한 비용이든다. 빠른 개발과 성능은 둘다 잡기 힘들다. 최적화에는 상당한 엔지니어링 시간이 걸린다.(고도로 최적화된 코드는 유연하지 않고, 변경하기 쉽지않다.) 빠른 개발은 코드베이스를 엉망으로 만들 가능성이 있다. 절충이 중요. 잘못된 게임디자인: 한가지 승리 전술로 무너짐.단순함 제약을 완화하는 방법 데이터 구조와 알고리즘을 올바르게 얻은 다음 거기에서 시작하는것. 단순하면 전체적인 코드가 적다. 오버헤드가 적고, 실행할 코드가 적어 성능이 좋다.(항상 그런것이 아님, 루프 나 재귀등) 좋은 솔루션은 코드의 추가(an accretion of code)가 아니라 코드의 증류(a distillation of code) 정신적 노력이 가장 적게 드는 솔루션은 해당 사용 사례를 한 번에 하나씩 코딩하는 것.조언 추상화 및 분리는 프로그램을 더 빠르고 쉽게 발전시킴, 하지만 문제의 코드에 이러한 유연성이 필요하다고 확신하지 않는한 시간을 낭비하게함. 개발 주기 전반에 걸처 성능에 대해 생각하고 설계하되, 가능한 늦게 까지 코드에 가정을 잠그는 저수준의 핵심 최적화를 미뤄야한다. 게임의 디자인 공간을 탐색하기 위해 빠르게 움직이되, 너무 빨리 움직이지 말아야한다.(Move quickly to explore your game’s design space, but don’t go so fast that you leave a mess behind you.) 버리는 코드를 작성하는 경우 예쁘게 만드는데 시간을 낭비하지 않아야한다. 출처게임디자인패턴" }, { "title": "[백준][C++] 1541: 잃어버린 괄호 (greedy)", "url": "/posts/2022/02/19/05/15/1541/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-02-19 05:15:17 +0900", "snippet": "문제1541: 잃어버린 괄호풀이 주어진 식에서 적절히 괄호를 쳐 최소값을 얻어내는 문제 이 문제는 분할 정복으로 해결할 수 있다. 그 이유는 식에 ‘+’, ‘-‘ 만 있기 때문이다. ’-‘ 기준으로 뒤에 있는 식을 양수 즉 ‘+’로만 이루어진 식만 있게해야한다. 그 이유는 최소가 되게하려면 음수를 많이 생성해야하기 때문이기 때문에 ‘-‘ 개수만큼 음수를 만들고 합치면 문제는 해결된다. 분할과 정복 분할은 간단하다 ‘-‘ 를 기준으로 앞 과 뒤를 나누고, ‘-‘인지 ‘+’인지를 넘겨주면된다. 아래 식은 - 기준으로 나눈것이다. 앞의 식은 이전의 부호를 따르고, 뒤의 식은 ‘-‘를 넘겨 음수임을 알려줘야한다. 기저조건 ‘+’로만 이루어진 식을 처리만하면된다. sign * re(s.substr(0, idx), 1) + re(s.substr(idx + 1), -1)식 계산하기 ’+’로만 이루어진 식을 계산하기 위해서 문자열을 파싱해야한다. ’+’를 찾고, stoi함수를 이용하여 해결하였다.int sum(string &amp;amp;s){ int ret = 0; auto idx = string::npos; while (string::npos != (idx = s.find(&quot;+&quot;))) { ret += stoi(s.substr(0, idx)); s = s.substr(idx + 1); } return ret + stoi(s);}코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int sum(string &amp;amp;s){ int ret = 0; auto idx = string::npos; while (string::npos != (idx = s.find(&quot;+&quot;))) { ret += stoi(s.substr(0, idx)); s = s.substr(idx + 1); } return ret + stoi(s);}int re(string s, int sign){ auto idx = s.find(&quot;-&quot;); if (idx == string::npos) { return sign * sum(s); } return sign * re(s.substr(0, idx), 1) + re(s.substr(idx + 1), -1);}int main(){ string s; cin &amp;gt;&amp;gt; s; cout &amp;lt;&amp;lt; re(s, 1);}" }, { "title": "[UE4] 언리얼 엔진에 오신 것을 환영합니다 ", "url": "/posts/2022/02/18/05/36/unreal2/", "categories": "game, game-unreal4", "tags": "unreal4", "date": "2022-02-18 05:36:17 +0900", "snippet": " 언리얼 엔진에 오신 것을 환영합니다. 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서. 언리얼 엔진4와의 첫시간머티리얼 메시의 외관에 영향을 주는것. 머티리얼은 라이팅에 반응항다. 뭔가를 보려면 라이트가 있어야한다. Directional Light 태양을 시뮬레이션하는 아이템디폴트 캐릭터 어딘가에 스폰된다. 플레이어 스타트나 카메라 위치(뷰포트의)에 스폰된다. 액터배치-&amp;gt; 기본 -&amp;gt; 플레이어 스타트 플레이어 스타트의 파란색 화살표가 정면을 뜻함. 플레이어 스타트의 위치를 조정할 때 플레이어가 바닥과 겹치면 BAD SIZE가 표시됨. 스카이 애트머스피어 월드의 가장 윗부분이나 대기를 나타냄 디렉셔널 라이트에서 애트머스피어의 작동방식을 결정해야함. sun light 설정: 디렉셔널 라이트가 애트머스피어와 상호작용할 수 있게 해줌 태양이 디렉셔널 라이트에 따라 회전한다. light 디렉셔널 라이트 -&amp;gt; intensity 조절하여 밝기 설정 이미시브 라이팅 사용 =&amp;gt; self-lit : lighting 영향 받지 않음, 전체적인 광원이 없어도 보임. sky light =&amp;gt; 앰비언트 라이트: 어두운곳의 밝기, 그림자 속 라이트, 어떤 것 뒤의 라이트 그림자 속 라이팅 : 앰비언트, 바운스 라이팅처럼 어디든 있는 라이팅 이 밝기는 장소에 따라 밝기가 달라짐, 자동노출(auto exposure)이나 시각 순응(eye adaptation) 어두운곳에 가면 이 라이트는 밝아짐, 밝은 곳으로 가면 어두워짐 PostProcessVolume: Lens의 Exposure 에서 최소 최대 밝기. -&amp;gt; 범위== 이펙트의 차이 1로 최대최소 설정해주면 어두운부분이 약간 어두워지고, 밝은곳은 더 어두워지지않음 라이트 블룸, 오클루전 라이트 새프트 라이트 새프트: 디렉셔널 라이트에서 shaft occlusion, shaft bloom 설정하면 빛줄기가 생김. tint를 설정하여 푸른 안개 효과 낼 수 있음 모빌리티 세팅 씬에서 라이팅이 어떻게 쓰이는지를 결정한다. movable: 완전히 동적이라는 뜻, 모든것에 새도우, 실시간으로 라이팅이 적용됨, 퍼포먼스 가장 많이 소비 모든 프레임이 정보를 하나하나 계산한다. static: 프로젝트가 돌아가기 전부터 모든게 미리 결정, 프레임마다 계산할 필요가 없음. 퍼포머스 가장 적음. 라이트 맵을 사용한다거나, 굽는다고 함. 이 세팅을 키면 화면 위에 라이팅을 다시 빌드해야 뜸. stationary: 두 옵션을 섞은것 프리뷰가 그림자에 나타나면 -&amp;gt; 빌드 -&amp;gt; 라이팅 빌드블루프린트 블루프틴트는 요소의 모음, mesh일 수 도 있다.(Viewport) 뷰포트에서 구체는 콜리전, 플레이어가 밟으면 이벤트 발생 뭔가를 재사용하기 좋다. 에딧 -&amp;gt; 프로젝트 세팅 맵&amp;amp;모드와 입력이 중요 맵모드: 일부 게임 프레임워크나 언리얼 엔진의 유용한 기능을 설정한다. 디폴트 폰 또는 디폴트 플레이어, 화면 뒤의 사람을 나타내는 디폴트 대상이 뭔지 등에 대해, HUD가 있는지, 컨트롤러 클래스가 뭔지(캐릭터에 대한 입력을 모방) 입력: 입력세팅=&amp;gt; 커스텀 캐릭의 세팅과 기본 세팅과 일치하게 해야한다. 동일한 키와 입력에 여러 입력을 매핑할 수 있다. 캐릭터 컴포넌트 -&amp;gt; 여러 변수 설정 가능(점프 최대 높이 등)월드 아웃라이너 월드를 구성하는 모든 액터가 포함되어있는 패널 폴더생성가능 (폴더 삭제시 계층 구조의 루트로 다시 돌아감.) 부모-자손관계를 사용할 수 있음 라이트를 블루프린트로 드래그하여 자손으로 종속시키면, 함께이동 한번에 여러 항목 영향: 전부 선택 -&amp;gt; 우클릭, 그룹선택 or 컨트롤 G디테일 패널 현재 선택된 항목과 컴포넌트, 그리고 그 프로퍼티를 표시 프로퍼티 값을 변경하고, 컴포넌트를 추가하고, 선택된 항목을 블루프린트로 변환 다수의 디테일 패널을 사용하여 항목간의 프로퍼티를 서로 맞춤. Show hidden properties while playing: 플레이 도중 숨겨진 프로퍼티 표시 한 아이템의 프로퍼티를 다른 프로퍼티로 복사 에디터에는 프로퍼티 매트릭스가 있음. (눈동자 모양 옆에 있는 프로퍼티 매트릭스-&amp;gt; 선택 열기) 선택한 아이템과 공통 프로퍼티가 표시 -&amp;gt; 한번에 모두 같이 변경 가능 두 개의 다른 아이템 옵션 비교 window-&amp;gt;details 에서 디테일 패널을 4개 까지 열 수 있음. 디데일창의 락버튼을 사용하여 비교 오브젝트 프로퍼티와 옵션이 표시, 런타임이나 에디터에서 확인하거나 변경 가능.문제1 씬에 게임 안에서 볼 때만 실행되는 파티클 이펙트가 있습니다. 파티클 이펙트 실행을 확인하는 가장 빠른 방법은 무엇일까요? G키 게임뷰 언리얼 엔진 소개모드 패널 왼상단 윈도우 -&amp;gt; 모드 모드 설정 -&amp;gt; 랜드스케이프, 폴리지 시 아웃라이너, 뷰포트 설정 못함 적절한 모드 사용, 실수할 가능성 높음 콘텐츠 브라우저 저장장치, 파일구조 프로젝트에 포함된 파일들 윈도우 -&amp;gt; 콘텐츠 브라우저: 창을 4개까지 추가 가능 폴더에 우클릭, 색변경가능. view type-show developer content: 나만의 전용 콘텐츠로 임시 영역과 같다. 프로젝트에 문제가 발생하길 원하지 않을 경우 엔진 콘텐츠: 엔진에서 제공되는 콘텐츠. 간편하게 바로 쓸 수 있는 콘텐츠가 많음. 컬렉션 정적: 구성 가능한 항목에 대한 바로가기 옵션 동적: 검색 메인툴바 프로젝트 작업시 사용함 아이템생성, 월드 생성 소스콘트롤: git 세팅: 프로젝트, 에디터, 플러그인 기본적으로 반투명 아이템은 선택 불가능 (마티리얼이 반투명), 세팅에서 허용 설정(allow translucent selection), T키 엔진 퀄리티 세팅: 변경내용은 에디터에만 영향, 최종 제품에 영향 x(머티리얼 퀄리티 또한 마찬가지) 사운드 조절(게임 플레이시 제외한 사운드 크기) 레벨 블루포인트: 레벨에서 직접 액터와 같은 오브젝트를 참조, 연속된 블루프린트를 트리거링 또는 시네마틱 기능에 사용. play-&amp;gt;시뮬레이션: 씬에서 시뮬레이션 설정을 킨다. 뷰포트에서 시뮬레이션 보기 가능(실행중인 피직스나 파티클 ) 세팅에디터 개인설정 창 에디터가 작업을 수행하고 작동하는 방식에 대한 개인 설정, 세팅, 옵션을 변경할 때 편집-&amp;gt; 개인설정-&amp;gt; 에디터 개인설정프로젝트 세팅 게임 모드를 오버라이드하여 전체 프로젝트에 적용가능 편집-&amp;gt; 프로젝트 세팅 or 툴바 -&amp;gt; 세팅-&amp;gt;프로젝트 세팅 게임 게임전용프레임워크 세팅 엔진 프로젝트에 대해 엔진이 어떻게 설정되었는지 입력이나 렌더링 설정방식 에디터 프로젝트에서 에디터 각 부분을 처리하는 방식 플랫폼 모든 플랫폼마다 고유의 아이템이 있음. 플러그인 플러그인별로 프로젝트 고유의 세팅을 조정 프로젝트 프로젝트 이름, 퍼블리셔, 관련 정보들 맵모드 멀티플레이어가 분할화면을 사용하는지 등. Game Instance class 패키징 플랫폼 지원 설정엔진 콜리전 피직스를 사용할 때 아이템이 서로 상호작용할 때 사용됨. 특정 아이템만 충돌하게 할 경우, 기본 콜리전은 제대로 작동하지 않을 수 있다. 인풋 점프 이동 마우스 등 세팅 마우스로 터치 시뮬, 기본 가상 조이스틱(모바일) 렌더링 default setting : 기본적으로 Bloom 활성화, Ambient Occlusion 활성화, Auto Exposure, Motion Blur 세팅 포스트 프로세서 이펙트를 사용하거나, 카메라나 다른 세팅을 직접 조정하는것 대신 가능 에디터 레벨 시퀀스 세팅플랫폼 플랫폼별 세팅 가능 direct, opengl, vulkan 설정 월드 세팅 현재 작업중인 레벨 고유의 세팅을 조정하거나, 오버라이드할 수 있다. 윈도우-&amp;gt; 월드 세팅, 툴바 -&amp;gt; 세팅 -&amp;gt; 월드 세팅월드 Kill Z 조정 세로축, 액터가 이 기준 이하면 사라짐 게임모드 기본 게임 모드를 오버라이드 메인 메뉴가 있지만 일반게임모드에서 모든 기능이 다 필요하지는 않을 경우 새로운 게임 모드를 만들고, GameMode Override를 해당 레벨에만 설정하는 것. Lightmass 라이트매스 시스템은 양질의 결과를 제공할 수 있도록 설정되어있음. 라이트매스 시스템은 정적인 빌드된 라이팅. 라이팅을 빌드하고 굽는데 이 시스템이 사용된다. 이 세팅을 오버라이드하여 라이팅 퀄리티 개선, 구워진 라이팅을 사용하고 있지 않으면, 이 섹션은 걱정하지 않아도 된다. 대안은 Lightmaps =&amp;gt; Force No Precomputed Light =&amp;gt; 리빌드 이렇게하면 공간에 약간의 여유가 생긴다.(빌드된 라이트맵이 삭제되기 때문.)Physics 기본 중력값 설정(오버라이드) 가능 water world를 설정할 경우 이 레벨의 중력값을 변경하려면, 이 설정을 변경하면됨. VR시스템옵션 World to Meters 월드 스케일 같은 기본설정을 변경할 수 있다.Tick 레벨기준으로 설정 이 레벨에서는 틱속도를 조정할 수 있다. Mini/Max Global Time Dilation을 설정, Allow Tick Before Begin을 설정하면 시작전 틱을 허용할 수 있음. 이 설정은 월드 세팅에서 오버라이드할 수 있다. 월드세팅은 작업중인 레벨 고유의 세팅창으로 여기에서 레벨 전용 세팅을 오버라이드하고 조정할 수 있다. 문제2 프로젝트에 독립 게임 모드가 필요한 메뉴에 쓸 레벨이 있습니다. 에디터 어디서 이 게임 모드를 설정할까요? 월드 세팅 에디터 실행 -&amp;gt; 기본으로 어떤 맵파일을 로드하도록 : 맵 모드 세팅 프로젝트 및 파일 구조 이해.uproject 이 프로젝트가 엔진과 상호작용하는 방식에 대한 기본 설정을 포함 버전, 플러그인, c++용 모듈, 플랫폼 등 게임을 실행할 수 있음. 명령줄에 의해 실행되는 것으로 에디터에서 실행되는것과 동일 엔진 버전 변경가능 에셋은 이전 버전과 호환되지 않음(주의) 소스cpp =&amp;gt; vs 프로젝트 생성 가능 .uproject에 모듈이 생겨남. =&amp;gt; 이 프로젝트와 연관시킬 코드 모든 모듈 및 타깃, 프로젝트와 연관된 모든 소스코드를 찾아냄 무언가를 활성화 하거나 비활성화 할 경우에만 편집 플러그인 활성화 여부 확인 가능 프로젝트 폴더 구조기본 구조 CONFIG: 프로젝트별로 제어할 수 있는 설정 CONTENT: 프로젝트의 모든 콘텐츠가 들어있다. collections, developers (콘텐츠 브라우저의 컬렉션 표시등): 바로가기나 스크래치 파일 SAVED: Intermediate폴더와 비슷, 확실한 경우가 아니면 제거x, 일단 삭제하면 그 안에 있던 내용물 재생성 불가, 게임의 실행 로그등, 장애가 발생할 경우 엔진은 이 폴더를 살펴봄, 파일 및 폴더 복구를 시도. SOURCE: C++소스, 이 폴더가 없다면 프로젝트가 제대로 컴파일 x 일부 코드가 제대로 작동 x, 뭔가 변경, 프로젝트 리셋 =&amp;gt; 이 폴더를 삭제하는 방법(.uproject에서 모듈제거 ) =&amp;gt; 블루프린트만 있는 프로젝트로 리셋 (비권장) 삭제 가능한 파일 및 폴더 INTERMEDIATE: 프로젝트를 작성하고 엔진을 사용하는 중간단계에 사용하는 임시파일과 폴더를 보관 (삭제하면 프로젝트를 다시열 때 시간이 더 걸림, 매번 재생성, 교체 ) vs 솔루션 파일(모듈감지, 다시 생성됨) .vs 폴더 (자동완성을 위한 임시 데이터, 기타 VS기능들) Binaries는 임시폴더. 컴파일된 바이너리 코드, C++ 소스 모듈과 dll 파일 프로젝트를 컴파일할 때 생성. 프로젝트가 제대로 패키징되지 않는 문제 -&amp;gt; 이 폴더를 삭제하면 해결될 수 있음.(프로젝트 리셋) 캐시에 저장된 다운로드 프로젝트를 만들거나, 엔진에 아이템을 설치해야 아이템이 다운로드됨 런처 설정-&amp;gt; edit vault cache location : 기본 캐시 폴더DDC 폴더 파생 데이터 캐시: 타깃 플랫폼에 대해 UE가 사용하는 특정 포맷, 에셋의 버전을 저장하는 캐시. 프로젝트 시작시간을 단축시켜줌 Appdata&amp;gt;local&amp;gt;unrealengine 프로젝트 재실행시 셰이더를 다시 컴파일할 필요가 없음 각 버전에 대한 디렉터리, common 디렉터리 DDC는 자체적으로 재생성, 필요에 따라 최신상태를 유지 필수는 아님, 재생성됨 폴더로 구성할 수 있으므로 공유할 수 있음(프로젝트 작업에 참여하는 사람들 모두가 같은 ddc사용 ) =&amp;gt; 필요한 시간 단축더 나은 파이프라인 구축 총 4가지 주제 Working with Others Building Better 3D Meshes &amp;amp; Textures Creating Materials &amp;amp; Material Instances Performance &amp;amp; Optimization 소스컨트롤 대부분 Perforce 와 Subversion을 사용한다. 데이터 동기화, push, pull, revert, add, remove data 반드시 최종 애셋만을 임포트해야함 같은 메시의 다른 버전을 임포트하지말아야함. 더 나은 3D 메시와 텍스처1 명명 규칙, 알파 정보와 RGB 마스크 패킹, 처리하는 방법 등. UE4로 임포트할 수 있는 다양한 텍스처 자장 포맷에 대해 밉맵, 임포트, 텍스처 그룹의 용도 텍스처 압축Naming Conventions SM_Rock_00 : 스태틱 메시, 00 버전 좋은 명명 규칙=&amp;gt; 파싱 가능, 어떤 파이프라인에 연결하여 정보 추출가능 T_Rock_00_BC: Base Color Texture SKM_RockBunch_00: Skeletal Mesh텍스쳐 제작 텍스처는 항상 2의 제곱이어야함(x와 y축이) 16x256 등 이 텍스처가 마지막에 메모리로 패킹되는 방식과 밉맵이나 텍스처 스트리밍 같은 언리얼의 내장 최적화에서 활용되는 방식이기 때문 언리얼의 스트리밍 시스템에 사용되기 위해, 밉햅을 사용하기 위해 =&amp;gt; 퍼포먼스 좋음.(거리에 따라 적절한 크기의 텍스처 생성 가능) 알파 정보 처리방법 두 가지 방법 삽입된 알파(Embed Alpha) : 독립된 알파보다 비용이 두배 해당 텍스처에 저장된 정보인 알파 채널이 압축되지 않은 채 언리얼로 들어오기 때문. 임포트될싶대 전체 해상도를 얻게됨: 해당 텍스처의 비용이 두 배라는 것. 독립된 알파(Separate Alpha): 베이스 컬러 사이즈로부터 알파 채널 사이즈를 독립적으로 제어할 수 있다는 점. 프로젝트 실행을 좀 빠르게 하고 싶을 경우 모든 알파맵의 사이즈를 줄임 삽입된 알파 =&amp;gt; LOD 바이어스 5 =&amp;gt; 알파의 크기가 작아짐 =&amp;gt; 원하는대로 리소스 사이즈가 줄어든다. =&amp;gt; 하지만 외형은 박살(베이스 컬러 역시 픽셀화됨) 독립된 알파 =&amp;gt; 조금 픽셀화 =&amp;gt; 베이스 컬러는 거의 유지 =&amp;gt; 알파 채널 정보를 정말 저렴하게 만들면서, 베이스 컬러 정보는 정확히 동일하게 유지 두 방법을 선택하는 것은 프로젝트와 워크플로에 달려있음. 처음부터 독립된 알파를 사용하면 기존의 것 수정할 필요 없이, 퍼포먼스 문제를 확실하게 해결 RGB 마스크 패킹프로젝트 전체에 사용되는 텍스처의 양과 메모리를 줄이는 방법. 다양한 텍스처들 =&amp;gt; RGB와 가끔은 텍스처의 알파 채널로 저장 Texture Sample 채널의 핀에서 이런 다양한 정보를 얻을 수 있음. 주로 VFX나 정말 높은 수준의 표면 디테일이 필요할 때, 그리고 일부 캐릭터 모델에 사용함 주의: 현재 사용하고 있는 채널의 흑백 정보만을 얻는다는점 컬러정보를 얻으려면 이 결과에 특정 유형의 컬러 파라미터를 곱해 주어야하나. 참고: 텍스처 프로퍼티 자체에서 sRGB를 반드시 비활성화 해야한다. 이걸 머티리얼에서 사용할 때는 sampler type이 masks로 설정되어야한다. 이유: sRGB를 비활성화하면, 해당 텍스처의 감마 보정도 비활성화 되기 때문 마스크 텍스처는 픽셀의 표시 여부를 정의하고 있기 때문에 감마보정이 되어서는 안됨.(이 정보가 단순히 렌더러에게 뭔가 표시될지의 여부만을 알려주기 때문.) Saving TexturesUE4에서 지원하는 다양한 텍스처 포맷 BMP FLOAT PCX IPG EXR DDS - cubemap Texture(32 bits/channel 8.8.8 ARGB32bpp, unsigned) HDR - Cubemap Texture(longlat unwrap) =&amp;gt; 2의 제곱 규칙을 따를 필요가 없음. embed alpha 지원 PNG PSD TGA Mip Mapping 프로젝트가 작동되는 데 중대한 역할. 텍스처의 레벨 오브 디테일 밉맵생성 == 텍스처를 UE4로 임포트할 때 발생 특별한 경우가 아니라면 신경 쓸 필요 없다. 밉체인: 언리얼로 텍스처를 임포트할 때 자동생성 프로젝트를 볼 때 대부분 이 체인에서 2단계나 3단계 쯤의 밉맵을 보게됨 텍스처가 화면에서 이 텍스처를 전체 해상도로 보여줄 필요가 없음 거리가 먼 경우, 메모리는 여전히 텍스처를 크게 보여줄 때와 똑같은 비용이 들게됨. 밉맵 필터링 == Level of Detail 의 Mip Gen Setting에서, 밉맵이 생성될 때 날카롭게 보이거나, 흐리게 보이도록 할 수 있음. 밉맵이 일종의 일렁거림을 일으킬 수 있음. 쇠사슬로 연결된 울타리나 전선 메시처럼 작은 선을 가진 애셋에서 보이는 현상 멀리 있는 텍스처 =&amp;gt; 계단 현상 or 일렁임 형상 =&amp;gt; Mip Gen Setting을 Sharpen 이나 Blur로 바꿔야함. 프로젝트마다 해결할 수도 없을 수도 있다. (계속 세팅을 바꿔보면서 확인해야함) Importing Textures 윈도우 탐색기 =&amp;gt; 콘텐츠 브라우저에 드래그 드랍 import 버튼 =&amp;gt; 탐색기 =&amp;gt; 선택 =&amp;gt; 열기 언리얼엔진은 파일의 특정 값을 보고 노말맵인지 뭔지 알아서 처리 어떤 유형의 텍스처를 임포트하든 언리얼은 특정한 텍스처에 특정한 프로퍼티가 적용되어 있어야 한다는 걸 잘안다. 임포트되는 노멀맵 : 노멀맵으로 자동 구성 Texture Groups 텍스처가 프로젝트에서 사용되고 표시되는 방식을 관리하는데 도움. 어떤 유형의 텍스처를 사용하든 그 텍스처의 텍스처 그룹이 있음 항상 프로젝트의 텍스처들이 올바른 텍스처 그룹에 있는지 확실하게 확인해야 할 것이다. 실제로 그룹 안의 텍스처가 프로젝트에서 그려질 크기를 제어하기 때문. 텍스처를 축소하고 확대하는 정도 제어 GPU를 통해서 텍스처에 적용할 필터링 종류도 제어 Level of Detail에서 결정됨 최소 사이즈와 최대 사이즈를 제어할 수 있다. 프로젝트에서 텍스처 메모리가 바닥이 나면 텍스처 메모리를 좀 되돌릴 수 있을지 실험을 해 봐야한다고 가정 텍스처 그룹은 이처럼 리소스와 관련된 대규모의 실험을 비파괴적으로 할 수 있는 좋은 수단. 이 system settings 로 모든 TEXTUREGROUP _World 노멀맵에 접근할 수 있으며, LOD 바이어스를 변경하여 이걸 2나 3으로 설정해 밉맵 체인의 2나 3번째의 LOD를 취하게, 그 LOD가 주로 사용되도록 만들 수 있다. 대략 2048쯤 되는 텍스처를 취해서 1024나 512 정도로 줄임 =&amp;gt; 줄어든 텍스처로 프로젝트 실행가능 =&amp;gt; 자신이 원했던 퍼포먼스 상 효과를 얻음 =&amp;gt; 원하는거 얻지 못했으면 다시 되돌리기 텍스처를 빼고 사이즈를 줄인 후 리임포트하는것보단 싸다 [SystemSettings]TEXTUREGROUP _World = (MinLOdSize = 1, MaxLOdSize = 8192, LODBias = 0, MinMagFilter = aniso, MipFilter = point)텍스처 압축 텍스처 더블클릭 =&amp;gt; 압축 세팅 =&amp;gt; 설정 UI, 최대 해상도 필요할 경우 =&amp;gt; UI or Vector Displacement 전혀 압축되지 않은 텍스처 srgb: 활성화된 텍스처에 감마보정 하지만 노멀맵, 마스크 텍스처 같은 애셋은 텍스처 정보가 아니라 활용할 렌더러 정보를 포함하기에 이 텍스처에 포함된 정보는 어떤 방법, 형태, 형식으로든 절대 조정되지 않고, 지정된 방식을 정확히 그대로 고수해야함. 더 나은 3D 메시와 텍스처2: 스태틱 메시 System Units Lightmap UV’s Triangle Counts Collision Meshes Material ID’s What Are LOD’s Pivot Points Creating LOD’s What Are Lightmaps Limiting Overdraw시스템 단위(system units) 어떤 DDC앱을 사용하든 아이템 제작을 시작하기 전에 우선 시스템 단위를 확실하게 구성해야함. (이 강의에선 3d studio max를 사용하지만 모두 적용되는것) 우선 시스템단위가 센티미터로 설정됐는지 확인. UE4의 기본 측정단위가 센티미터임.(1 언리얼 유닛 == 1 센티미터) 몰입감때문에 이를 언리얼엔진과 DDC앱의 유닛 단위를 맞춰줘야함. Triangle Counts 트라이앵글 수: 퍼포먼스와 연관 DDC에서 삼각형 수를 확인하며 작업해야함. 너트볼트와 같은 수준까지 디테일을 신경쓰지 않아도 됨. 작은 디테일 =&amp;gt; 플레이어도 모름 지나친 폴리곤 낭비 Material ID’s 모든 머티리얼은 하나 이상의 ID를 가진다. 어떤 폴리곤 면에 어떤 머티리얼이 적용되는지를 결정 ID가 5개면 렌더링이 5번되어야만 최종적으로 한번 더 렌더링 된 후 표시됨 머티리얼 유형: MultiSub-Object Material == 오브젝트에 다수의 머티리얼을 할당할 때 ID가 많으면, 렌더링 비용도 증가피벗 포인트 올바른 피벗포인트를 설정해야함 오브젝트의 피벗 포인트 위치 잡아야 원하는 곳에 배치 가능 DDC에서 잘 설정하고 작업해야함 스케일을 조정할 때 거리또한 스케일됨, 틀어지면 모든 작업이 힘들어짐. What Are Lightmap 라이트맵: 텍스처의 복잡한 빛과 그림자의 정보를 저장하는 데 사용 텍스처가 이러한 유형의 데이터를 저장하는 데 저렴하고 좋음 복잡한 라이팅 계산을 텍스처에 저장하면, 런타임에 이 정보를 거의 비용없이 얻을 수 있다. 좋게보이도록, 퍼포먼스 높게 유지하도록, 균형을 맞추게해줌 라이트맵/ 섀도맵 라이트맵: 일반적인 텍스처와 다르게 생김. 라이트맵의 RGB채널에 다양한 값들이 저장되었기 때문 다양한 영역의 라이팅 정보가 모두 서로 다른 R,G,B 채널로 패킹된것 섀도맵: 섀도 데이터를 R, G, B채널에 저장한 것 Lightmap UV’s 라이트맵 제작과 주의할 점 라이트맵은 오브젝트의 모든 면이 0-1 공간에 고유하게 배치되어야함 각 면은 고유하게 배치되어야함. UV 아틀라스에서 각자 고유한 공간을 차지해야함. 0-1 space: UV 정보 주변에 위치한 정사각형. 모든 UV가 스페이스에 있음. 라이트맵을 렌더링할 때 라이트매스가 실제로 신경쓰는 데이터: 0-1 공간안에 있는것뿐, 그 외부 공간의 데이터는 잘라냄 0-1공간에서 UV내 각 오브젝트에 각자의 공간을 확보해야함. UV채널 = 2: 라이트맵 UV가 메시의 두 번째 채널에 저장되어야함을 의미 (3DMAX의 채널2는 UE4의 채널1, 언리얼은 0부터 채널 수를 셈) 라이트맵이 언리얼로 임포트 될 때 자동으로 언팩됨 스태틱 메시 설정 아래에 라이트맵 해상도, 라이트맵 좌표 인덱스가 있음 해상도: 메시 선택 =&amp;gt; 디테일 패널 =&amp;gt; Lighting =&amp;gt; Overridden Light Map Res 에서 오버라이드 가능 Collision Meshes 두 가지 방법으로 만들 수 있음. 자신이 사용하는 DCC에서 콜리전을 만든 다음 지오메트리와 함께 임포트 콜리전 메시의 구체적인 식별자가 있는 이름을 지어줘야함. UCX_(메시 이름)_(콜리전 번호) 언리얼엔진에서 콜리전을 만들 수 있음 상단 메뉴바 =&amp;gt; 콜리전 =&amp;gt; 콜리전 메시 컨벡스 분해(convex decompos): 콜리전을 만들기 어려운 유기적인 메시에 쓸 복잡한 콜리전을 만들 수 있는 기능 윈도우 =&amp;gt; 컨벡스 분해 선택 =&amp;gt; 적용 이 기능의 역할: 메시를 복셀화, 그 복셀을 기반으로 콜리전 파라미터를 생성하는 것 Limiting Overdraw 오버드로는 투명 혹은 오파시티를 다룰 때 나타남 이 현상은 GPU가 텍스처 곳곳에 다수의 투명을만들거나 여기저기가 뚫려 보이게 해서 유용한 정보를 표시하지 않게한다. 오버드로는 다수의 평면을 겹쳐서 실제 나무, 덤불, 잔디 등과 같은 모습을 보여야 하는 폴리지 메시에서 자주 나타남 버텍스를 약간 더 사용하거나 평면의 실제 형태를 조정하여 오버드로의 발생량을 줄일 수 있다. 버텍스를 몇 개 더 렌더링하는게 엄청난 수의 픽셀을 렌더링 한 다음 버리는 것보다는 싸다.(매프레임마다 하는 작업이므로) 오버드로 확인 : UE4의 툴 ‘셰이더 복잡도’라는 모드 뷰포트의 Lit =&amp;gt; Optimization Viewmodes =&amp;gt; shader complexity 하얀색을 최대한 많이 없애야함. What are LOD’s Level of Detail 메시와 같지만 트라이 앵글 수가 더 적고 가끔 머티리얼 인스트럭션 수도 더 적은 사본 윤곽선이 같지만 해상도는 낮게 일정한 유형의 LOD가 있어야함. LOD 메시는 많이 있어도 되지만. 너무 많아서 프로젝트가 해가되는 시점이 올 수 있음 보통 75%, 35%, 12% 까지 메시를 줄임 이런 수치는 정해진것은 아니지만, 차이가 나도록 설정해야함. 메모리를 아낀다는 목적달성하기 위해 Creating LODS (3DMax에서) 기존 메시 복붙, Modifier 목록에서 Pro-Optimizer를 추가, Caculate 클릭 폴리 수 줄이기: Optimization level 에서 vertex% 50%로 설정 모든 작업 후에 서로 겹침. =&amp;gt; 모두 선택한 후 =&amp;gt; 메뉴바에서 Group =&amp;gt; Group =&amp;gt; 이름 LOD =&amp;gt; Utilities Panel 탭에서 more.. =&amp;gt; LOD 선택 =&amp;gt; Create new set 클릭 =&amp;gt; File 에서 Export (언리얼에서) 임포트 =&amp;gt; 고급옵션 보기 =&amp;gt; 임포트 옵션 =&amp;gt; 메시 LOD 임포트의 박스 =&amp;gt; 라이트맵 UV 생성은 끔 =&amp;gt; DDC에서 만든 라이트맵 UV 사용 메시 LOD임포트를 켜지 않은 상태 =&amp;gt; LOD가 없는 기본 메시만 얻음 생성 =&amp;gt; LOD 세팅 =&amp;gt; LOD 그룹 =&amp;gt; LargeProp =&amp;gt; LOD 다수를 자동생성애샛 임포트 익스포트 스태틱 매시 익스포트 스켈레탈 메시 익스포트 + 옵션 애셋 리임포트 자동 리임포트: 폴더를 수신대기 설정 =&amp;gt; 애셋이 변경되면 자동 리임포트 FBX 를 통한 씬 전체의 임포트 수정할 애셋을 UE4에서 임포트스태틱 매시 익스포트 UE4는 스태틱과 스케레탈 메시 모두에 FBX 포맷 사용 (애니메이션 포함) FBX: 기본 머티리얼 데이터, 스태틱 메시 데이터 , 기본 머티리얼 데이터와 함께 스킨을 입힌 메시 데이터, LOD, 본 기반 애니메이션 데이터 스태틱 메시에 선택해야할 FBX 익스포터 지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation 애니메이션이 있거나 Skeletal mesh에는 animation에 클릭해야함 실수로 다른것도 익스포트하지 않도록 주의 스케레탈 메시 익스포트 지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation 애니메이션: animation Deformation (Morph 타겟을 익스포트한다면): Deformations, Skins3D Mesh 임포트 드래그 드랍, 임포트 버튼3D Mesh 임포트 옵션 대부분은 기본설정으로 충분. 콜리전 자동생성: 해당 메시의 콜리전 자동생성 라이트맵 UV 생성: 라이트맵 UV 생성, 최고가 아닌 경우가 많음. (강의하는 사람은 비활성화하는 편 ==&amp;gt; DDC에서 모든걸 직접 구성할 경우) 버텍스 절대치로 변환: 이 옵션이 꺼지면 콜리전 메시의 피벗 포인트가 전부 0이되어 스태틱 메시 중앙에 놓이게됨 머티리얼 임포트, 텍스처 임포트: 보통 비활성화 == 메시 작업 완료와 동시에 임포트와 구성이 될것이기 대문. 테스트 애셋 이 임포트될 수 있음. 스켈레톤 메시 에니메이션 임포트: 메시 옵션 스켈레톤 메시 활성화, 기존의 스켈레톤을 찾아서 그 애니메이션을 임포트할지 말지 선택 나중에 머티리얼과 텍스처를 직접세팅하고 싶기 때문에 머티리얼, 텍스처 임포트 옵션 끔애셋 리임포트 가장 간단하고 빠른 방법: 드래그 드랍 =&amp;gt; 자동으로 업데이트 우클릭 =&amp;gt; 리임포트 소스파일 경로 =&amp;gt; 리임포트할 때 자동으로 이 경로 팡일로부터 리임포트 텍스처 더블클릭 =&amp;gt; 리임포트 =&amp;gt; 파일 탐색기(경로에 해당파일이 없을 경우) =&amp;gt; 설정자동 리임포트 구성 에디터 설정 =&amp;gt; General =&amp;gt; Loading &amp;amp; Saving =&amp;gt; Auto reImport =&amp;gt; 폴더 모니터 업데이트가 저장될 폴더 수신대기 =&amp;gt; 자동으로 업데이트 가능. 이 방법은 소스 컨트롤 없이 작업할 때 사용하기 좋음. 협업할 경우 프로젝트에 최신 변경사항을 확실하게 반영시키고 싶을 때 사용하기 좋음.Full Scene Import FBX 파일의 전체 씬 임포트 건축 시각화와 같은 프로젝트 =&amp;gt; 모든 애셋을 가져와서 일일이 정확한 위치에 배치하는 것은 불필요 작업 스태틱메시 + 스켈레탈 메시 + 애니메이션 + 머티리얼 + 텍스처 + 리지드 바디 + 모프타깃 + 카메라 + 라이팅 모두 지원 머티리얼과 카메라는 일정한 제한이 있음. 머티리얼: 디퓨즈와 노멀맵만 가져옴 카메라: 애니메이션은 가질 수 없음, UE4에서 구성해야함. 3dmax에서 전체 선택 =&amp;gt; 익스포트 임포트하면, 전체 씬을 재구성해 블루프린트에 배치해 주어서 씬의 모든 메시를 쉽고 빠르게 업데이트 할 수 있게 해 줌.UE4로부터의 애셋 익스포트 애셋이주: UE4 외부에서 콘텐츠를 가져오는 또 다른 방법, 모든 내부 연결을 유지해줌. 구 버전의 UE4를 사용했을 때 아주 좋은 방법 새 프로젝트에서 열면 텍스처, 머티리얼, 메시 모두의 내부 연결이 유지. Content 폴더에 배치해야함.(안그러면 모든 연결이 망가질 가능성이 큼) 애셋 익스포트: 소스 콘텐츠에 접근할 수 없을 경우, 애셋에 아주 미세한 조정만 하고 싶을 경우머티리얼과 머티리얼 인스턴스What is PBR Physically Based Rendering: 빛의 실제 작용을 추정하는 것. 더 정확, 더 자연스러운 라이팅 모든 라이팅 시나리오에서 똑같이 잘 작동함. 시나리오별로 다양한 버전의 라이팅을 만들 필요 없음 머티리얼도 평소처럼 복잡해질 필요가 없음. 원래 필요했던 머티리얼 인스트럭션 수를 많이 간소화할 수 있다. 머티리얼 값 훨씬 덜 복잡, 덜 상호의존적/ 더 직관적으로 조정가능 단순히 극 사실적인 렌더링을 돕거나 사실적인 이미지에만 사용할 수 있는 것이 아님. 만화 기반의 이미지에도 적용 가능 아트 프록덕션 파이프라인의 통일에 도움이됨. PBR은 애셋 하나만 있어도 어떤 유형의 라이팅을 받든 정확히 똑같은 방식으로 라이팅에 반응함 라이팅 유형 별로 다수의 머티리얼이나 텍스처를 만들필요가 없게됨 머티리얼 도메인 각 머티리얼은 도메인과 블렌드 모드 또는 셰이딩 모델만 바꿔서 다양한 필요를 충족시킬 수 있다. 이에 따라 일부 기능을 활성화하거나 비활성화해야함. 주요 셰이더 노드의 각각 다른 출력에 영향이감. 머티리얼 도메인: 머티리얼 어트리뷰트가 평가되는 방식 블렌드 모드: 머티리얼 색과 배경과 블렌딩되는 방식을 결정 셰이딩 모델: 입력이 합쳐져 머티리얼의 최종 색을 만드는 방식을 결정 ex. 유리: 블랜드= Transparent, 셰이딩= Unlit or Default Lit =&amp;gt; 유리의 빛에 대한 반응 방식을 바꿀 수 있음. 여러 조합으로 필요를 만족시켜야함. 이들은 런타임에 변경할 수 없다.머티리얼 머티리얼은 UE4가 오브젝트 상 텍스처의 표시 방식을 돕거나 조작하는 수단. 머티리얼은 HLSL코드의 작은 블록들로 구성됨. 작은 블록들은 온갖 다양한 역할을 수행함. 그 중에는 텍스처의 색상대로 색조를 더하거나 두 텍스처의 블렌딩을 돕는다. 사실상 HLSL 함수를다루는것. 머티리얼은 먼저 컴파일되어야함. 컴파일: 미리보기 뷰포트 위의 적용 클릭 컴파일 == 스태틱 == 프로젝트 실행 중에는 변경불가 머티리얼로 프로젝트 전체의 온갖 다양한 머티리얼에 적용할 수 있는 기능이 있음.머티리얼 인스턴스 머티리얼은 런타임에 변경 불가 색상, 텍스처 등 머티리얼 인스턴스는 머티리얼의 특별한 버전 머티리얼을 리컴파일 할 필요 없이 머티리얼에 포함된 값과 텍스처를 런타임에도 바꿀 수 있게 해준다. 덕분에 머티리얼 인스턴스는 반복처리를 정말 빠르게 해줌. 변화가 거의 실시간. 타임라인과 블루프린트로부터 머티리얼 인스턴스와 상호작용해 다양하고 멋진 애니메이션 효과 얻음. 퍼포먼스 이점 유연성: 다양하고 수많은 파라미터 사용 =&amp;gt; 마스터 머티리얼을 구성 =&amp;gt; 복잡한 셰이더 코드를 다수 개발할 필요 없음. 미세 조정 가능 마스터 머티리얼 많은 구성을 할 수 있는 머티리얼 수 많은 파라미터 노드 사용 Base Color라는 백터 파라미터 =&amp;gt; 색선택 텍스처 파라미터=&amp;gt; 무엇이든 보충할 수 있게, 외형을 완전히 변경 가능 스칼라 파라미터 =&amp;gt; 스칼라 변수 제어 = 특정 이펙트를 늘리거나 줄일 수 있음.마스터 머티리얼 주의점 가능한것 다수의 마스터 머티리얼 사용 해서는 안됨 모든 오브젝트에 작용하는 단 하나의 마스터 머티리얼을 만드는것은 하면안됨 =&amp;gt; 성능에 문제 생김 캐릭용 , 아이템용, 불투명한것, 투명한것.. 등등 따로 따로 지레짐작하지말아야함(불필요한 파라미터 삽입금지) 마스터 머티리얼 개념 머티리얼 =&amp;gt; 좋은 퍼포먼스 + 자신이 목표로한 모든 플랫폼에서의 작동을 보장해야함 머티리얼 함수: 머티리얼 그래프 일부를 공유하고 재활용할 수 있게 해줌 수많은 내장 함수들: 오브젝트의 월드 위치 결정, 화면상 마우스의 좌표 위치 파악까지 모든 것을 해냄 머티리얼 라이브러리로 코드 공유 가능 유지보수 간소화 RGB 마스크 패킹 텍스처의 사용 방식을 지정할 수 있다. R, G, B, A 채널에 다른 텍스처를 저장하게 두는 것 =&amp;gt; 메모리에서 텍스처 양을 줄일 수 있는 방법 스태틱 스위치(static switches) 머티리얼의 전체 경로를 활성화 또는 비활성화 ex. 패럴랙스 오클루전 노멀 매핑을 켜고 끄는 스위치를 만들면 노멀 맵에 굉장히 비용이 높고 사실적으로 보이는 디테일을 구현할 수 있다. 비용이 높아 씬의 머티리얼 다수에 사용할 수 없음 =&amp;gt; 스위치로 필요한 메시에만 활성화 피처 레벨 스위치 어떤 목표 기기에서든 머티리얼이 실행될 수 있게 해줌. 다양한 플랫폼에 사용할 서로 다른 복잡도 수준에 따라 서로 다른 버전의 머티리얼을 연결 ex. 셰이더 모델 5(SM5)을 사용해 거의 무한한 디테일과 아름다움을 얻고 싶으면 =&amp;gt; 높은 디테일의 셰이더가 됨. ex. ES2에서 실행되는 것 =&amp;gt; 안드로이드 모바일 프리뷰어, 그냥 실행만될 뿐, 부가기능많이 없음 마스터 머티리얼 제작 배경 오브젝트에 사용할 마스터 오브젝트 구성 방법 배경 오브젝트용 마스터 머티리얼을 유리가 있는 오브젝트용 마스터 머티리얼로 변환 머티리얼 함수 만들고 사용마스터 머티리얼 생성 파일 -&amp;gt; 새 레벨 =&amp;gt; 새 default 레벨 =&amp;gt; 마스터 머티리얼 폴더 =&amp;gt; 콘텐츠 브라우저 우클릭 =&amp;gt; 새 마티리얼 =&amp;gt;더블클릭 색추가 머티리얼 인스턴스 =&amp;gt; 벡처 파라미터 노드 추가(BaseColor로 그룹) 머티리얼 에디터 우클릭 =&amp;gt; Vector 검색 =&amp;gt; 베이스컬러와 연결 (키보드에서 v누르고 에디터 클릭) 텍스처 추가 T Key를 사용해 머티리얼 내에 배치 (콘텐츠 브라우저에서 우클릭후 텍스처 선택 =&amp;gt; 머티리얼 에디터에서 t 누르고 에디터 클릭 or 드래그 드랍) 텍스처를 텍스처 오브젝트로 변환해 설정할 것임. 노드를 바로 BaseColor에 연결하면, 머티리얼을 컴파일하고 머티리얼 인스턴스에서 사용하려고하면 텍스처 샘플을 조정할 수 없게됨 Texture Sample 노드에 우클릭 후, 파라미터로 변환해야함. (Base_Color_Texture로 이름 설정, 그룹을 BaseColor) 스태틱 스위치 추가(텍스처나 더 저렴한 비용의 벡터 컬러 파라미터의 사용여부를 결정) 머티리얼 에디터 =&amp;gt; 우클릭 =&amp;gt; ‘Switch Parameter’ =&amp;gt; ‘Default Value’를 true로 (bUseBaseColorTexture로 이름 설정, 그룹을 BaseColor) 상수 값 추가 키보드 1 키 + 좌클릭 =&amp;gt; 노드 우클릭 파라미터 변환 (Metallic으로 설정, 그룹도 Metallic) 러프니스 구성 약간의 제어를 위해 Lerp Parameter 를 사용하여 러프니스 값을 높이거나 낮출것임. 텍스처를 하나 더 추가 =&amp;gt; 텍스처의 RGB 채널에 패킹된 러프니스 맵을 사용할 수 있도록 러프니스를 구성할것임 이 텍스처에서 샘플 타입을 Masks로 설정해야함 =&amp;gt; 마스크 파라미터 구해야함(RGB -&amp;gt; static mask param) =&amp;gt; 머티리얼 인스턴스에서 텍스처의 다양한 R, G, V 채널을 선택 가능 (RoughnessMasks라고 이름 지음. Roughness 그룹에 넣음) Texture Sample 우클릭 =&amp;gt; 파라미터로 변환 =&amp;gt; Roughness_Texture 라고 이름지음 =&amp;gt; 그룹을 Roughness 키보드 L 을 누르면서 클릭 =&amp;gt; Lerp 노드를 생성 =&amp;gt; Lerp의 Alpha와 마스크 연결 =&amp;gt; A, B에는 스칼라(상수) 값 추가 러프를 Roughness(러프니스)와 연결 컨트롤 쉬프트 왼클릭 =&amp;gt; 노드 다중 선택 노멀맵 추가 텍스처 샘플러 추가 =&amp;gt; 우클릭 =&amp;gt; 노멀맵과 연결 =&amp;gt; 샘플 타입 노멀로 설정 =&amp;gt; 파라미터로 변환 (Normal_Map으로 이름 변경) 적용과 저장 버튼 =&amp;gt; 마스터 배경(environment) 머티리얼 제작 끝유리 머티리얼 제작 위에서 만든 머티리얼 복붙, 이름 변경, =&amp;gt; 오파시티나 오파시티 마스크 사용 (디테일 패널 =&amp;gt; Materials 섹션 =&amp;gt; Blend Mode) BlendMode: Masked(렌더러에게 이 픽셀을 통과해서 볼 수 있는지 없는지 알려줌)or Translucent(통과해 볼 수 있는 정도를 어느정도 조절) Translucency가 0.1 =&amp;gt; 거의 다 통과 =&amp;gt; 표면이 살짝 더럽거나 하는 경우를 만들 수 있음. 오파시티 or Translucency : 오파시티 마스크보다 비용이 더 많이 든다.(속도를 원한다면 마스크 사용, 퀄리티 =&amp;gt; 오파시티) Opacity 상수 만들어 연결(opacity에) Shading Model을 Glass로 변경하여 씬의 라이팅과 더 나은 상호작용하도록 해야함 Transluncy 섹션 =&amp;gt; Lighting Mode =&amp;gt; Surface Forward Shading : 최고의 라이팅과 반투명 상호작용을 보여줌 + 비용이 가장 비싸기도함. 컴파일 오래걺림 머티리얼 함수 제작 서로 다른 머티리얼 간에 셰이더 코드를 공유할 수 있게 해주는 머티리얼 함수 제작 머티리얼 함수: 머티리얼 간의 셰이더 코드 공유하는 수단 ex. ‘MF_Tile’이름의 머티리얼 펑션 생성 간단한 텍스처 타일링: 타일링을 동일하게 유지시켜야하기 때문에 만든다. 각각 다른 셰이더에 사용하는 타일링 방식이 다를 필요가 없기 때문(일원화 작업) 텍스처 좌표 추가(Texture Coordinate) FunctionInput 추가 =&amp;gt; Texture_Scale로 이름 변경 =&amp;gt; Input Type을 인풋 스칼라로 (텍스처 좌표에 값을 곱할 것임) =&amp;gt; preview Value의 x를 1로 설정 =&amp;gt; M키 랑 왼클 =&amp;gt; Multiply 노드 생성 =&amp;gt; 좌표를 A, Scale 스칼라를 B, 그리고 Multiply 노드를 타일 아웃풋에 연결 =&amp;gt; 적용 아웃풋에 우클릭 =&amp;gt; 미리보기 중지 =&amp;gt; 다시 미리보기 시작 머티리얼 함수를 머티리얼 에디터에 드래그 드랍하여 배치 가능 머티리얼간에 일관성이 있어야함 =&amp;gt; 변수명 등 머티리얼 인스턴스 사용부모 자손 관계 부모 인스턴스 머티리얼 관계 부모들이 그 색깔에 대한 액세스할 수 없기에 자손도 액세스할 수 없다. 부모가 할 수 있으면, 자손 역시 부모가 할 수 있는 모든 것에 액세스할 수 있다. 부모가 할 수 없으면, 자손 역시 할 수 없다. ex. MAT_ENV_Master 와 MAT_Glass_Master가 있다. MAT_ENV_Master =&amp;gt; 세가지 외형의 머티리얼 인스턴스를 만들 수 있다.(타일링 변경, 색변경, 텍스처 변경) 인스턴스에서 완전히 다른 외형의 머티리얼을 구성할 수 있다.(하지만 통과해서 볼 수 없음.) MATGlass_Master는 통과해서 볼 수있는 머티리얼.(이 마스터의 자손인 인스턴스들은 ENV처럼 변경할 수 없다 =&amp;gt; 부모가 접근을허용하지 않음) 머티리얼 인스턴스 생성 머티리얼 선택 =&amp;gt; 인스턴스 생성 or 콘텐츠 브라우저에서 우클릭 후 머티리얼 &amp;amp; 텍스처에서 만들 수 있음. 머티리얼 인스턴스 클릭 =&amp;gt; 인스턴스 에디터 BaseColor에서 텍스처 변경 가능 =&amp;gt; 빠르게 변경됨(컴파일 시간 없이) Metallic 등 을 오버라이드 가능 =&amp;gt; Slider min ~ max 설정가능 이러한 설정들은 인스턴스 생성시 만든 그룹으로 묶임 부모 머티리얼 또한 변경 가능. 머티리얼 더블클릭 =&amp;gt; 디테일 Material Property Override: 부모 머티리얼의 함수 기능을 오버라이드 TwoSided: 안쪽도 렌더링하는지 블렌딩 모드 변경, 디더링된 LOD 전환의 변경 등 이는 부모 머티리얼 시스템의 목적을 무산시킴(보통 머티리얼을 새로 만듬) 검증용도로 사용하면 좋다. Vertex Animation 미묘한 움직임을 저렴한 비용으로 전달 물, 풀, 천 또는 역동적으로 움직여야하는 물건들 GPU에서 진행되기에 매 프레임의 렌더링 비용이 저렴함. 주어진 메시에서의 기존 버텍스 위치를 오프셋하기만 하면 되기 때문 저렴함 + 쉬운 활용 =&amp;gt; 약간의 비용(상호작용성) 모든 콜리전과 비슷한 것을 전부 처리하는 CPU는 GPU의 메시와 버텍스에 적용된 오프셋에 대해 알지 못함. 그저 부가적인 장식이나 씬과 경험에 재미나 실감을 더해주는 용도 게임플레이에 영향을 주지못함. (상호작용하는데 사용못함) 퍼포먼스와 최적화: Texture StreamingTexture Streaming 많은 양의 텍스처를 다룰 때 =&amp;gt; 텍스처가 흐려질 수 있음. 디테일이 제대로 표시되지 않을 수 있음.(스트리밍이 제대로 이루어지지 않음.) 스트리밍: 기본적으로 텍스처가 얼마나 크거나 작게 보일지 처리한다 Lod or 밉맵: 텍스처와 정확히 똑같은 버전이지만 크기만 다른걸 보여줌(리소스 비용이 적음) 스트리밍: 레벨의 오브젝트와 카메라의 거리에 따라 서로 다른 LOD를 스트리밍하는것을 도와줌. 건축 시각화나 엄청나게 높은 텍스처 디테일이 필요한 경우 종종 경고를 받음(풀의크기가 부족하다는) 텍스처 스트리밍에 PoolSize라는 것이 있음. 텍스처 밉맵으로 채울 수 있는 특정 메모리 셋을 말함. 텍스처가 카메라에서 멀 수록. 점점 작아지다 메모리 풀에서 차지하는 크기 또한 작아짐, 결국 메모리에 없어짐. 오브젝트에 가까이 가면 갈 수록, 텍스처는 이 스트리밍 풀을 점점 더 많이 차지하게됨. 풀크기 키우기 : ‘`’ or ‘~’ 키를 눌러서 UE4 콘솔창 =&amp;gt; r.Streaming.PoolSize = 5000 이런식으로 설정하면 됨.(메가바이트 단위) 아니면 DefaultEngine.ini에서 설정 Forcing Textures to never stream 텍스처 스트리밍 안함 옵션: 언제나 가장 높은 해상도 버전의 텍스처가 표시되도록 만드는 것. 프로젝트의 모든 텍스처를 가장 높은 해상도로 설정하면 안됨. 보통 UI옵션, 텍스트 등 유저에 가깝게 뭔가 표시하는 텍스처에 스트리밍 안함. Texture =&amp;gt; Never Stream 퀄리티는 높지만 비용이 비쌈. LOD &amp;amp; 스태틱 메시 병합 LOD: 거리가 멀리 떨어졌을 때 사용하려고 더 적은 버텍스로 렌더링한 다양한 버전의 메시UE4 Automatic LOD Creation Tools &amp;amp; Manual LOD Setup DCC에서 생성할 수 없거나 시간이 없을 경우 자동: 스태틱 메시 에디터의 LOD 세팅 LOD 그룹 =&amp;gt; 그룹 선택 =&amp;gt; 자동 LOD 생성 툴이 BaseEngine.ini를 확인해 얼마나 많은 LOD 레벨이 적용되어야 하는지 알아낸다. (또한 메시 디테일 패널에 있는 다양한 세팅들도 확인, LOD0 세팅) 메시의 LOD 세팅 =&amp;gt; LOD 그룹 LevelArchitecture =&amp;gt; LOD를 거쳐서 Reduction setting을 각각 설정 LOD 그룹에서 설정 수동 LOD 세팅에서 LOD의 개수를 설정할 수 있고 각각의 LOD에서 Reduction setting에 있는 percent triangles 로 폴리곤 개수를 설정 가능. 보통 삼각형 개수를 75%, 25%, 12%로 맞춤 (사람의 눈은 윤곽선에서 얻는 정보가 더 큼) Adjusting/ Tweaking LODs LOD 변경사항에서 거리를 조정하거나 미세 조정해야한다면 =&amp;gt; 현재 화면 크기 사용 LOD 세팅에서 Auto Compute LOD Distances 세팅 해제 스태틱 메시 에디터 =&amp;gt; 트랜지션화면 크기를 설정 =&amp;gt; Current Screen Size 를 보고 설정 LOD 강제 렌더링 가능 =&amp;gt; Forced Lod Model 액터 =&amp;gt; 디테일 패널 =&amp;gt; LOD =&amp;gt; Forced Lod Model 배경 오브젝트가 많은 경우 메시가 항상 LOD4가 되게 설정 가능. Min LOD: 마지막 LOD가 나올 때까지 계속 그 LOD 시스템을 쓰는것 Merge Actor Tool 드로콜과 머티리얼 수를 줄여주는 배경 오브젝트 그룹 작업 가능 스태틱 매시나 머티리얼 수가 많은 것. =&amp;gt; 하나의 머티리얼, 스태틱 매시(삼각형의 개수는 같음) 전체 렌더링 크기를 줄임. 하나의 머티리얼, 하나의 메시, 하나의 텍스처 Window =&amp;gt; DeveloperTools =&amp;gt; Merge Actors Pivot Point at Zero: 단점이 있긴하지만 새 메시의 배치를 쉽게한다. Merge Physics Data: 모든 피직스 데이터를 한데 병합. LODSelection Type Use all LOD Levels: 새 머티리얼의 생성 방식을 선택이나 조정할 수 없게 하기 때문. (현재 상황 전부 취해 거대한 메시를 만든 후 그 LOD 를 모두 사용한다.) Use specific LOD Levels: LOD 0으로 설정(2나 3 등의 레벨이 없는 것이 있을 수 있음), 새로 병합된 메시가 그 LOD 레벨을 신뢰할 수 없음. (LOD == 0일시 LOD Maker와 같은 내장 최적화 툴도 사용하여 메시를 더욱 최적화 가능 ) Material Setting Merge Materials all LOD Levels =&amp;gt; 다양한 머티리얼 세팅 불가능 Use Specific LOD =&amp;gt; Material Settings를 수정할 수 있다.(Normal map이나 Metallic Map을 수정할 수 있음) Texture Sizing Type: 선택한 옵션이 자신의 콘텐츠에 최적하지 않을 수 있음. (모듈화 중점 =&amp;gt; Input Texture의 Texture Size에 따라 자동 편향된 텍스처 크기를 사용할 수 있음. Landscape Culling: 랜드스케이프와 교차하는 모든 메시에 교차 부위를 마치 잘린것처럼 만들어줌. 랜드스케이프 액터에 배치된 매시를 크게 최적화함. 계층형 LOD 액터병합: 성능은 좋지만 파괴적 계층형 시스템: 레벨에서 다수의 액터를 생성하거나 병합할 수 있게 해주며, 프로그래밍적으로 수행한다. HLOD 툴을 삭제하거나 재실행하여, 레벨에 완전히 새로운 메시를 만들 수 있음. 비파괴적 HLOD: 메시들을 모두 취해 하나의 텍스처와 하나의 머티리얼을 가진 단일 메시로 변환함 window =&amp;gt; world settings =&amp;gt; LODSystem =&amp;gt; HLOD 활성화 window =&amp;gt; HLOD Outliner =&amp;gt; Generate Clusters =&amp;gt; Cluster generation setting 기본적으로 HLOD 시스템 전반을 거쳐 볼륨을 상당히 낮춰줌. 그 볼륨에 포함된 모든 액터는 새로 생성된 메시, 새 LOD 메시를 얻어서 멀리서 사용할 수 있게해줌. 일정 거리만큼 떨어지면 HLOD 가 메시를 그룹으로 묶어 2~3개의 메시로 바꾸면서도 완전히 동일한 디테일한 레벨을 보여줌(메시도 2~3개, 머티리얼도 2~3개, 텍스처도 2~3개) 카메라에서 멀리 있을 경우, 정확히 똑같은 오브젝트를 훨씬 절감된 비용으로 렌더링 가능 모든것을 구성하거나 알맞은 클러스터에 두었다면, Generate Proxy Meshes 누름. 레벨을 렌더링하는데 드는 메모리와 GPU 비용을 줄임. 주의: 레벨이 크면 클수록, 혹은 오브젝트 밀도가 높으면 높을수록, 프록시 메시 생성에 드는 시간은 더 길어진다.라이팅, 섀도잉, 포스트 프로세스 모두 서로 비슷, 모두 서로 상호작용 여기에서 대부분의 퍼포먼스 문제가 발생함라이팅 다양한 라이팅 Mobility 타입 라이팅의 퍼포먼스 비용 면에서 서로 다른 기능이 있다. Static: 가장 저렴, 씬에서 아무것도 하지 못하는 라이팅을 의미, 완전히 구워져서 상호작용할 수 없음. Stationary: 씬과 상호작용을 할 수 있어, 스테이셔너리 라이트로 인해 생기는 섀도는 다이나믹 오브젝트가 해당 섀도와 어우러지게 해줌. (비용이 살짝 비쌈) 런타임에서 스테이셔너리 라이트의 라이팅 색상과 강도를 실제로 바꿀 수 있기 때문. 라이팅을 움직이지는 못함. Movable: 완전히 동적이기 때문에 비용이 비쌈. 모든 라이팅, 섀도인이 다 동적 사람눈으로 차이를 거의 구분할 수 없음. 라이팅 빌딩 BuildOptions =&amp;gt; Lighting Quality =&amp;gt; Production/High/Medium/Preview preview: 에디터가 매우 낮은 세팅을 사용해 프리뷰를 보여주거나 라이팅과 섀도잉이 어떻게 보일지 기본적인 개념만 제시 Medium: preview보다 약간 더 느리고, 약간 더 나은 결과를 보여줌. High: 비교적 높은 라이팅 제공하지만, 얼룩, 띠현상 때문에 라이트맵 해상도를 올려서 조정해야할 수도 있음. Production: 기본적으로 완성할 수 있는 최고의 퀄리티의 라이팅을 보여줌.(오래걸림) production 과 preview 사이의 퀄리티 차이는 꽤 큼. 개발진행상태에 따라 옵션을 변경(초기 == preview, 모든 작업끝 == Production) 섀도잉 섀도잉하는 방법은 다양함. 언리얼에서는 두 가지의 주요 섀도잉 타입이 있음. Static: 스태틱 라이트 유형에서 나오는것. 비용이 작음, 씬 상호작용 할 수 없음 Dynamic: 스테이셔너리와 무버블 라이트에서 나옴. 비용이 비쌈, 씬 상호작용 할 수 있음. static 라이트 다이나믹 오브젝트 즉, 모든 움직이는 오브젝트는 그림자를 드리우지 못함. 스테이셔너리 라이트 사용 =&amp;gt; 그림자가 서로 합쳐짐(구워진 섀도우에서도) 다이나믹 섀도를 드리우되, 스태틱 섀도잉 시스템의 효과도 많이 가져옴 스태틱과 다이내믹 사이에 위치. Dynamic 좀 더 선명하고 가장자리의 부드러움이 전혀 없음. 구워진 섀도우가 없음. 특이한 섀도우 CSM(Cascaded Shadows) 스태틱 섀도와 다이내믹 섀도의 최고 장점들을 합칠 수 있기 때문. 가까이 있을 때 =&amp;gt; 완전한 다이내믹 섀도 멀리 =&amp;gt; 스태틱 섀도로 전환 Direction Light =&amp;gt; cas =&amp;gt; Num Dytnamic Shadow Cascade, Dynamic Shadow Distance =&amp;gt; 전환되는 거리와 다이내믹 섀도 케스케이드의 수 변경 가능 이 섀도는 Directional Light에서만 사용가능. Distance Field Shadows 메시 디스턴스 필드를 사용하여 실제로 라이팅과 섀도의 상호작용을 생성해서 멋진 섀도 감쇠를 만들어냄 비용이 굉장히 높음 포인트 라이트에서 활성화 할 수 있지만, 디스턴스 필드를 활성화 해야함. 프로젝트 세팅 =&amp;gt; Distance =&amp;gt; 엔진 라이팅 =&amp;gt; Generate Mesh Distance Fields =&amp;gt; 활성화 Contact Shadows 컨택트 섀도가 멋진 이유: 실제 스크린 스페이스에 구성되는 섀도. 기본적으로 스크린 스페이스의 섀도 굉장히 작은 디테일 (디렉셔널 라이트의 섀도잉은 섀도 버퍼가 이런 디테일 유형을 나타내기에 충분히 크지 않음) 포인트 라이트 =&amp;gt; 디테일 패널 =&amp;gt; Contact =&amp;gt; Contact Shadow Length Contact Shadow 값을 증가시키면 그림자는 깊어짐(적절히 설정해야함. 1을 넘어가면 별로) 패럴랙스 오클루전 매핑(Parallax Occlusion mapping) =&amp;gt; 특정 컨택트 섀도 메서드의 작동 방식을 바르게 볼 수 있는 방법 정말 높은 비용의 기능 Post Process 볼륨으로 처리되는 포스트 프로세싱 =&amp;gt; 렌더링을 제어하기 때문. 퍼포먼스 다수를 순식간에 잡아먹을 수 있는 구간 중 하나. 포스트 프로세스 섀도를 구하는 방법 Volumes =&amp;gt; Post 검색 =&amp;gt; 포스트 프로세스 볼륨 =&amp;gt; 디테일 패널 디테일 패널 =&amp;gt; Unbound 프로퍼티 체크(언바운드의 역할: 이 포스트 프로세스가 레벨 어디에 배치되든 모든 포스트 프로세스 세팅에 이 포스트 프로세스를 사용하라) 언바운드가 활성화되지 않으면: 볼륨의 스케일과 회전을 조정 =&amp;gt; 플레이어가 이 볼륨에 들어오면 포스트 프로세스가 변함. 언바운드는 이를 방지함. =&amp;gt; 이 세팅을 월드 모든 곳에 적용. 모바일 톤 매퍼: 모바일 프로젝트 제작에만 유용 안티 에일리어싱: 프로젝트 설정 =&amp;gt; 디폴트 세팅에서 설정 가능 포스트 프로세싱 =&amp;gt; 블루프린트를 통해 조작된 값도 가질 수 있음. (온도 등 변경) 포스트 프로세스의 세팅을 많이 켜고 조정할수록 렌더링에 드는 비용이 커짐.볼륨 많은 볼륨 중 다음과 같은 볼륨만 다룰 것임 Lightmass Volumes: 라이팅 계산이 이루어지는 Min 과 Max 영역을 정의, 인터렉티브나 무버블 오브젝트가 월드와의 확실한 상호작용을 통해 여기저기 움직이고 상호작용을 하면서도 월드로부터 라이팅을 받을 수 있게 돕기도 함. Cull Distance Volumes: 레벨에서 확실하게 컬링을 만들어주는 안전 그물역할 Using Volumes UE4의 여러곳에 배치해 다양한 일을 수행할 수 있는 액터 갈수 있는 곳과 갈 수 없는 곳을 결정. 사운드 리버브방식 등 결정 상호작용할 수 있는 많은 방식 =&amp;gt; 볼륨으로 제어됨.라이트매스 볼륨 두가지 목적 1. 라이트매스 시뮬레이션의 경계를 정해 라이트매스가 계산할 가장 큰 영역과 가장 작은 영역을 결정 라이트매스 볼륨을 레벨에 두지 않으면, 결국 라이트를 전혀 받지 않는 영역이나 레벨에서 플레이가 가능하지 않은 영역에 상당량의 연산 시간을 낭비하게 될 수도 있다. 라이트매스 볼륨 =&amp;gt; 플레이어가 보거나 상호작용하는 영역만 라이팅 계산 =&amp;gt; 계산 양 줄어든다. =&amp;gt; 실제 레벨 라이트 계산 빨라짐 ex Lightmass importance volume 이 볼륨들을 여러개 레벨의 모든 영역에 배치할 수 있지만, 결국 라이트매스란 MIN 과 MAx 위치를 보고 하나의 큰 볼륨을 만든다. 그러니 레벨에 볼륨을 확실히 두고 레벨의 플레이 가능 영역을 모두 포함하는지 확인해야 한다. 2. 캐릭터와 같은 동적 오브젝트에게 정적으로 라이팅되는 환경에 대해 알려주는 것. 완전한 다이내믹 라이팅을 만들 수 없다(라이트와 섀도 맵 안에 라이팅을 구움) 즉, 상호작용 못함 =&amp;gt; 문제 해결: “Lightmass Importance Samples” 혹은 소형 라이팅 프로브들을 곳곳에 배치 viewport=&amp;gt; show =&amp;gt; visualize =&amp;gt; light sample 에서 확인 가능. 이 샘플들은 각각 캐릭터들에게 배치된 라이팅에 대해 알려준다.(메시 선택, alt + shift를 누른채 옮겨서 확인 가능) 다이내믹 메시가 정보를 받도록, 또는 작은 라이팅 볼륨 샘플과 배치된 샘플들로부터 어떤 색상을 띠어야 하는지 알려주는것인데 다 이 볼륨덕분 Lightmass Character Indirect Detail Volume 특정 볼륨에 배치된 샘플 숫자를 증가시킴 작은 샘플들 각각이 지오메트리가 있는 곳 위로 배치됨 (샘플이 없으면, 캐릭터 안보임) 캐릭터 볼륨안에 샘플 다수가 있는지 확인 엘레베이터 내부처럼 플레이어가 긴 영역을 따라 이동해야하지만 샘플이 많이 있지는 않은 특정한 장소에서 사용하고 싶을 것 특정 프로젝트에 있는 샘플의 전체적인 양을 증가시키기 위함 world Setting =&amp;gt; lightmass =&amp;gt; Static Lighting Level Scale =&amp;gt; 샘플들의 밀도 조절 (높은 밀도 =&amp;gt; 디테일 증가 =&amp;gt; 0.1로 설정 =&amp;gt; 메모리 많이 필요) Cull Distance Volume 특정 크기나 카메라 거리를 초과한 오브젝트의 렌더링을 멈추는 최적화 툴 이를 사용할 때 오브젝트의 모든 것을 컬링할 수단보다는 그냥 기본값처럼 사용(안전 그물역할) cull distance volume 디테일 =&amp;gt; Cull distances =&amp;gt; 배열 =&amp;gt; 여러 종류의 입력이 있음(ex, 3개) 오브젝트가 렌더링될자 아니면 멈출지의 기준이 될 크기와 거리를 결정. 이 배열에 카메라의 거리와 크기의 임계점을 담음. 메시에서 Allow Cull Distance 를 활성화 해야함 수동적인 방법: 메시 =&amp;gt; 렌더링 =&amp;gt; 고급 프로퍼티 =&amp;gt; Min Draw Distance. Desired MaxDrawDistance, Current Draw Distance : 하드 코딩 설정/ 오브젝트가 카메라로부터 컬링되는 기준 거리 강제 설정 가능 볼륨을 사용하여 컬링을 하면, 프로젝트에서 컬링을 구성할 때 원래 필요했을 작업량을 상당히 줄여줌. 일일이 수동으로 최적화하지 않아도 됨. 리플렉션Reflaections 3가지 방법으로 얻을 수 있음 이 방법들은 특정 액터에 의해 제어됨 sphere: 비용이 저렴 box: 비용이 저렴 planar: 비용이 비쌈 sphere 구체 영역안에 리플렉션을 만든다. 저렴 레벨 전체 커버할 캡처 액터와 , 작은 캡처 몇개를 만들어 여기저기 배치 과용하면 좋지않음 리플렉션 뷰모드 사용하여 세세하게 잘 설정할 수 있다. BOX 일반적으로 복도 내부, 네모난 레벨에서 사용 구석에서 약간 오류가 발생 Planar 프로젝트 세팅 =&amp;gt; 렌더링 =&amp;gt; support global clip plane for planar reflections활성화 레벨과 모든 메세와 텍스처의 사본을 취해서 위 아래로 뒤집은걸 리플렉션으로 사용 정확한 리플렉션이 나오지만 비용은 메시와 머티리얼의 비용에 직접적인 연관. 몇몇 에러 발생가능 =&amp;gt; 작고 파란 하이라이트들이 생김 =&amp;gt; 리플렉션이 씬을 One-Sided로 렌더링하기 때문.=&amp;gt; Render Scene Two Sided를 True로 설정해야함 포스트 프로세싱 볼륨의 스크린 스페이스 리플렉션(SSR) 포스트 프로세싱 볼륨 =&amp;gt; 디테일 패널 =&amp;gt; Rendering Features =&amp;gt; Screen Space Reflection 활성화 Sphere, BOX는 레벨의 모든 다이내믹이 리플렉션 캡처로 고려되지 않는다. 역동적인 리플렉션 =&amp;gt; SSR or Planar 스크린 밖에 오브젝트가 있으면 리플렉션 망가짐 화면의 정보를 사용하기 때문(보이지 않으면 반사 x ) Getting Higher Quality Reflections 언리얼 == 실시간 엔진 전반적인 리플렉션 캡처 해상도를 최소한으로 낮춤 해상도를 실제로 변경 가능. 에디터 =&amp;gt; 편집 =&amp;gt; 프로젝트 세팅 =&amp;gt; 렌더링 세팅 =&amp;gt; Capture Resolution 스카이라이트 =&amp;gt; 디테일 패널 =&amp;gt; Cubemap Resolution 해상도 높 =&amp;gt; 메모리 사용량이 많이 늘어남 메시에게 High Precision Static Mesh Normal 과 Tangent Encoding 사용 높은 테셀레이트 스피어 사용 편집 =&amp;gt; 프로젝트 세팅 =&amp;gt; 렌더링=&amp;gt; GBuffer Format =&amp;gt; High Precision Normals 메시 =&amp;gt; 디테일 패널 =&amp;gt; 빌드 세팅 =&amp;gt; Use High Precision Tangent Basis =&amp;gt; TRUE 메시 전체에 더 나은 보간을 줌. 메시가 높게 테셀레이트 =&amp;gt; 버텍스 많이 사용 =&amp;gt; 부드러운 트랜지션 " }, { "title": "[UE4] 개발자를 위한 언리얼 엔진 시작하기_1", "url": "/posts/2022/02/16/20/34/unreal1/", "categories": "game, game-unreal4", "tags": "unreal4", "date": "2022-02-16 20:34:51 +0900", "snippet": "개발자를 위한 언리얼 엔진 시작하기 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서.인트로 8개의 주제 엔진구조 렌더링 월드 빌딩 마테리얼 블루프린트 프로그래밍 캐릭터 애니메이션 월드 빌딩철학 언리얼: 시각적 지향성을 추구하는 완성형 툴셋 레벨에 중점을 맞춘 워크플로, 레벨에디터로 시작한 언리얼 엔진 에디터: 기본적으로 서브에디터와 툴이 포함 툴과 서브에디터가 전부 에디터와 엔진의 일부, 핵심적인 철학: 모든게 함께 빌드, 모두 같은 스타일, 같은 로직, 모든게 끊김없이 함께 작동해야함 SchematicPlaceable Actors excluding 3D Actors 월드에 배치가능하면서 3D 액터가 아닌것 emitter Actors Reflection Captures static Lighting + stationary Light + Dynamic Lighting =&amp;gt; Light Actors 다섯가지 라이트(스태틱: 구운것) geometry Editing =&amp;gt; volumes 트리거, 블로킹, 킬z 등등 게임플레이 영향, 포스트 프로세스 변경 볼륨이 중요함 게임플레이 + 워크플로우 =&amp;gt; BP Actor 블루프린트: 임베디드 스크립트 게임플레이에만 국한되지 않는다. 월드 빌드와 콘텐츠 관리에 도움을 주는 기능도 있음. 게임플레이: 트리거, 스폰포인트, 플레이 스타트Placeable 3D Mesh Actors 모델이나 캐릭터 static mesh: 변형되지않고 이동되지 않는다. 변형 기반 본이 없다는것.(vertex shader를 사용하면 변형되긴한다.) Lodding, HLOD , Instanced Static Meshes, Splines =&amp;gt; staticmesh Lodding: Dithered Lod Transition (디더링된 트랜지션 옵션)- 스무드를 조절, HLOD: 계층형 LOD 노멀LOD: 멀리있을 때 폴리곤 수가 줄어드는 데서 끝난다.(여전히 다양한 드로콜) HLOD: 멀리서 메시를 한데 합치는것 window/HLOD outline 툴에서 생성(자동으로 생성해냄) 한번의 드로콜을 사용하게 끔, 폴리곤 수가 줄어든다. 텍스처를 하나로 합침 Instanced Static Meshes: 인스턴스 렌더링. 엔진에서 메시를 자동으로 처리 기본적으로 언리얼 엔진의 메시는 인스턴트 스태틱 메시가 없기 때문에 언제나 메모리에서 처리된다. 이 메시는 메모리에 한 번만 로드되지만, 드로콜이 여러개 있다면 렌더링도 여러번 이뤄진다. 인스턴트 스태틱 렌더링으로 렌더링 처리가 된다. instancedStaticmesh 컴포넌트: 하나를 여러번 렌더링 Spline 로프트 스플라인 revolve 스플라인 메시를 스플라인으로 로프트나 리볼브 시켜 파이프나 울타리 등을 만들 수 있다. 메시가 스플라인을 따르게 만드는것 skeletal meshes Lodding 애니메이션과 캐릭터를 다룰 때 보통 캐릭터에 사용할 본이 있는 매시를 다룰 때 차량 등의 다른 요소에도 사용 가능 Geometry Geometry Editing old and outdata 프로토타입 작업, 화이트 박싱 작업에만 사용 노멀 메시가 아님 BSP라고 부르는 바이너리 스페이스 파티셔닝(CSG) 단점만 있음 거의. Procedural Mesh 플러그인으로 활성화 해야한다. vertex들을 설정하여 메시를 설정 Foliage(야외) Foliage Tool 배치한 폴리지가 하나의 오브젝트로 작동한다.(배치 렌더링) Grass 랜드스케이프 전체를 덮는 작업에 아주 유용 잔리 레이어: 터레인 전체에 자동 적용, 아래에 깔린 랜드스케이프의 라이트 정보를 재사용함.(이 메시는 라이팅맵을 굽거나 라이팅을 계산하지도 않음) -&amp;gt; 일관성 개선, 대규모 환경에 대한 스케일링도 나아짐. Procedural Foliage: 지정한 매시를 좀더 똑똑하게 배치(나무를 심으면 나무가 퍼져 자라는 것처럼, 성장 시뮬 가능),(나무 그늘에서 뭔가가 자라게 설정 가능) Geometry Collections Chaos Destructibles: 카오스는 새로운 피직스 시스템 기본적으로 메시를 균열시켜서 저장하는 것 Landscapes(야외) Landscape Layers Landscape Components Landscape Gizmos: 일정영역을 선택해 복사가능 Landscape Visibility Landscape Painting 하이트맵: 원하는대로 제거, 수정, 확장 가능, 방대한 규모로 스케일링 가능(단일 하이트맵을 거대하게 유지하는 것보다는 나음) Landscape Splines: 강이나 도로같은 요소를 작업할 때 유용 Landmass Plugin: (활성화 필요) 협곡같은거, 리얼타임 배치는 불가능, 에디터에서 배치, 평탄화된 지면 위 에 건물이 자동으로, 새 메시를 간단히 배 Landscape Brushes Skies 거대한 메시, 거대한 구체, 구체가 머티리얼로 존재 PBSA-&amp;gt; materals -&amp;gt; static Meshes Physically Based Sky Atmosphere - visual effect에서 선택 가능 - Light의 directional Light의 컴포넌트 조합 좋음 (필수요소) - directional Light에서 atmosphere 활성화(개인설정) - 내부의 태양으로 그레이디언트 생성 - 일광의 각도 파악, 모든 색상을 자동으로 조정 CTRL + L 키가 태양을 제어하는 단축키 - 오존등 조절하여 색 시뮬 가능(다른 행성 등 표현) - 스카이 시스템 전체가 머티리얼로도 캡쳐가 됨 3D Tools 3D 메시 배치에 충실한 기능 (아직 한창 개발 중) sculpting Tools -&amp;gt; Modeling Tools 이전에는 메시를 임포트만 할 수 있었음. UVTools -&amp;gt; Modeling Tools 엔진내의 UV를 다시 수정 가능 라이트맵 UV수정 등 엔진이 라이트맵을 생성하는 시점은 메시를 임포트할 때나 그 이후로 선택할 수 있다. Mesh Simplification 모든 모델의 일부 기본적으로 메시를 간소화 가 LOD 생성 가능 작은 유틸리티 플루프린트도 약간의 스크립팅으로 빌드 가능 모든 콘텐츠의 LOD를 한 번에 생성허거나 임포트를 할 때 생성(엔진 자동화 기능) Controlling The Level World Properties 모든 레벨에 있는 프로퍼티 목록 Timeline-&amp;gt; Level Blueprint 일종의 레벨 블루프린트, 각 레벨에는 내장된 블루프린트가 있다. 타임라인 추가: 간단한 애니메이션(스켈레탈 애니메이션을 쓰지 않을 요소에 사용), (문, 엘리베이터, 버튼, 레버 등 간단한것) 시퀀서: 영상 에디터로 사용가능 단점: 재생할 때까지 프리뷰 못함 Variants Manager 편차를 관리하는 매니저 Level Variance Set 애셋-&amp;gt; 바닥 등을 선택-&amp;gt; 할당가능 CE 콘솔입력: 블루프린트를 사용하면 사용가능, 함수나 이벤트 강제 실행 가능, 테스트에 좋음 시퀀서: 가장 큰 트랙 에디터(영상용) 간단한 작업에는 과하다. 월드에 시퀀서 플레이어로 배치되어있음. 레벨 시퀀스 열기라는 버튼-&amp;gt; 시퀀서 에디터가 실행됨 시퀀스는 값만으로 모든것을 수정가능 머티리얼 프로퍼티 같은 다양한 요소에 키를 부여할 수 있다. 이 키로 시퀀서 제어 가능 (Re)building 필수는 아님, 작업에 따라 달라짐. 사전 연산이 전혀 없이 월드와 레벨 빌드하고 싶을 경우Lightmass Importance Volume Lightmaps 라이트맵 생성, 알아서생성됨 메시의 세컨드 채널에 UV좌표가 구성되어있는한 또는 없어도 뭘 해줄 필요가 없음. 올바른 해상도로 알아서 처리 다른 프로그램으로 직접 생성 가능 Volumetric Lightmaps 라이트매스 볼륨안에서는 높은 퀄리티의 라이팅을 얻을 수 있다. 멀리 떨어진 지오메트리가 아니라 실제 플레이하는 곳에 배치Lighthing Lightmass Importance Volume Precomputed VisibilityHLOD 계산 및 빌드되어야한다.Reflections Captures 배치된 리플렉션은 모두 업데이트되고 캡처되어야한다. 리빌드 과정, 라이트 리빌드 과정에서 이뤄져야한다. 게임을 구웠거나 패키징하여 완성된 게임을 만들었다면, 리플렉션 캡처가 구워진것. 직접 구운 텍스처를 큐브맵이 생성해냄 에디터에서나 굽기전의 시점: 리빌드하거나 레벨을 여는 식으로 매번 리플렉션 캡처를 재생성해야한다. 그렇기 때문에 아직 패키징되지 않았거나 굽지 않은 레벨을 열 때 시간이 오래걸리는 것. 이런 요소들을 콘텐츠 브라우저에서 에셋으로 두고 리플렉션 캡처로 할당하면 그런 프로세스를 거치지 않아도 됨. 이러면, 수동으로 작업하거나 아예하지 말아야함 리플렉션을 원하는 대로 정확히 표현하고 싶을 때만 Navmesh 빌드메뉴 =&amp;gt; 다양한것들을 빌드 가능 지오메트리 빌드: 스피드 브러시로 지오메트리를 리빌드.(지금은 거의 안씀) ‘p’키를 누르면 빌드 패스에 의해 생성된 내비메시가 나타남. 빌드패스: 언리얼 엔진1용어로, 더이상 패스도 아님. 라이트맵에 의해 구동됨 Navmesh Agent Multi User Editing 서버를 구성한 다음 다수의 사람들이 마치 멀티 플레이어 게임처럼 레벨을 실시간으로 편집하면서 그 결과를 확인할 수 있음. 두 사람이 정확히 똑같은 레벨을 동시에 수정 가능라이트 시나리오 선택적 레벨 스트리밍이나 서브레벨등을 호출하고 싶은데서 호출한다. 레벨탭 에서 설정가능 밤이나 저녁 라이팅을 서브레벨에 두고 상호교환하거나 다양한 라이트 시나리오를 원하는대로 갖게 만들 수 있음. 중요한점은 보간할 수 없다는 점. 그냥 바꾸는 것. 딜레이가 살짝 걸림. 모든 요소를 불러옴. Multiple Levels/ Streaming 다양한 서브레벨. 항상 쓰이는 것이 아님 대규모 작업에서 필수적 대안은 3가지 무시하고 쓰지 않는것(소규모 제작에서만 먹히는 방법) persistent level streamed level 등 이런 저런 루트를 사용 실제로 레벨을 스트리밍하는 방법을 사용해도 되지만 여러레벨(스트리밍), 실제로 일반적인 표준 레벨이 아니라 다른 레벨에 병합된 레벨(다른 사람이 작업한 레벨과 병합해도 상충 발생 x =&amp;gt; 협업에 유리) 레벨 스트리밍 볼륨에 들어가면 관련된 레벨이 로드됨. 이게 바로 레벨 스트리밍 - 에디터상에서는 지연 발생 가능, 하지만 패키징된 게임에서는 완전히 동기화된 상태로 실행됨. (설정에 따라 다름) 위치별 분할이 가능. 작은 묶음을 만들면 잘작동. 스태틱 메시를 show 에서 끄면 볼륨찾기 쉬움. 스트리밍 방법: 블루프린트, 코드: Load Stream Level 함수 볼륨 항상 로드 world composition: 월드를 다양한 레벨로 나눔. 기본적으로 별개의 셀로 나눈다. 각각이 모두 레벨이됨. 부모레벨인 persistent level의 일부가 됨. 오픈월드 용. 거리 지정 가능. 다음 레벨 근처로 가면 자동으로 로드 z 축에는 적용되지 않는다. 레벨이 얼마나 먼 거리부터 보일지 정의 가능 거리 그룹으로 정의 가능 먼 거리에서도 보여야 하는 레벨이면 전부 그 그룹에 넣으면 됨. The playable experience Runtime Navmesh 컴포넌트 미리 계산된 Navmesh를 원하지 않는 경우 (월드가 클 경우 거대한 단일 내비 메시를 두는 것도 이상적인 방식이 아님) 런타임동안 내비매시를 생성할 수 있다. 적들이 돌아다니는 주변에 작은 로컬 내비메시 생성기를 배치하는 것. Performance 통계 viewport에 stat stat scenerendering : 추천할만한 명령은 아니지만, 씬의 렌더링을 요약, 정확하지않음, 메시드로콜을 파악 가능 드로콜과 씬의 라이트 개수를 파악할 수 있다. stat game: 블루프린트 시간 stat none: stat 지우기 stat physics stat Units: fps를 ms 단위로 보여줌, 스레드별로 나누어줌, game, draw, gpu등의 프레임 시간을 보여줌. stat FPS: 프레임속도를 보여줌. 프로젝트를 재시작해도 특정 통계를 계속 보여주도록 설정 가능 GPU 프로파일러: 내장형 비주얼 프로파일.(대강 비슷한 정보를 보여줌. 가독성을 높여줌, 컨트롤 + 쉬프트 + ,) ms단위 시각적 보여줌. 실시간이 아님, 버튼 누른 순간만 포착 통계 패널: window-&amp;gt;statistics 라이팅에 대한 통계를 표로 나열해서 보여줌. Texture Stats 폴리지는 하나로 셈(인스턴스 안셈) 뷰모드 Cull/Max Draw Distance 멀리있는 메시를 지움 디스턴스 컬링이지만 볼륨의 제어를 받음. Scaleability Render Quality Force LODs Distance Multipliers Etc 엔진 퀄리티: 서로다른 R dot Scalability C vars로 게임이 실행하는 동안 렌더러의 퀄리티를 실시간으로 바꿀 수 있다. world detail: 언리얼1,2의 기능이 남아있는것 파티클, 메시 등, 시각적 렌더링이 되는 모든 것의 속성에 적용된다. 속성에서 detailmode에서 설정 High: High로 설정된 메시들 제거(규모가 작은 작업에서 사용, 거미줄 경우 투명해서 퍼포먼스가 무거움) 월드 구성과 퍼포먼스: 월드 컴포지션과 관련 레벨 전체에 대한 적업도 할 수 있음. 관리도 가능 더 낮은 퀄리티의 새레벨을 만들기도 함. 멀리 떨어진 셀은 시스템이 생성한 레벨의 간소화 버전 랜드스케이프 자체 엔진은 랜드스케이프의 모양을 노멀맵으로 구운다음 그 위에 노멀 맵을 렌더링 랜드스케이프가 엄청나게 간소화되도 마찬가지. 자동 LOD 간소화 기능도 제공하긴함. 조언 대규모 씬에서 쉽게 작업할 수 있도록 도움이 되는 월드 빌딩 기술, 팁 &amp;amp; 트릭 Level organization Level cleanliness Landscapes Foliage Painting ToolsLevel organizationimportant actor standards, Outliner, Groups 선택하면서 컨트롤 G 누르면 그룹으로 묶을 수 있음. 컨트롤 + 쉬프트 + G 키를 누르면 그룹을 잠시 비활성화 할 수 있음. 쉬프트 + G는 그룹해제 액터의 렌더링 방식은 그룹화해도 바뀌지 않음.(아웃라이너 또한) 아웃라이너에 폴더, 그룹, 레이어 등 작업 가능Layers window -&amp;gt;layers 이름이 레이어지만 레이어는 아님 그냥 선택 설정임.Selection tools 언리얼 엔진에서 뭔가를 선택할 수 있는 모든 방식 레벨을 빠르게 제어할 수 있음. 콘텐츠 브라우저에서도 이런 툴을 사용할 수 있음.(컨트롤 + B, 우클릭, 해당 에셋을 사용하는 모든 액터 선택) 통계툴 또한 선택하여 제어 가능.Level cleanliness Shadows/Collision은 끌 수 있음. -&amp;gt; 시야 명확, 퍼포먼스 증가. (sky 같은 경우 그림자, 콜리전 x)Snapping Tool Standard 그리드 스냅, 회전 스냅, 스케일 스냅 월드 빌딩에 도움됨 그리드와 어긋나있지 않게 수정 가능(각종 요소들 움직이기 쉬움) 컨트롤로 여러 요소를 동시 선택 가능 대괄호 Bracket ‘[’, ‘]’를 사용하면 그리드 크기 조절 가능Landscapes Lodding and Collisio, Per Component Settings 랜드스케이프에서는 자동으로 LOD가 적용됨. 랜드스케이프 세팅에서 설정 가능 보통 LOD 거리를 좀더 높임.(기본 설정이 미묘하기 때문) 좀 더 명확하게해서 성능을 아주조금 높임. 컴포넌트 별 설정도 가능. 콜리전 밉 레벨: 1로 설정하면 콜리전의 정밀도가 낮아짐. 거친 터레인. -&amp;gt; 평평한 랜드스케이프에서 효과적(메모리 상당량 줄어들게함), 컴포넌트마다 해줄 수 있음. 덜중요하거나, 거리에 따라서 머티리얼 간소화 가능 Material complexity and Shared Samplers 랜드스케이프는 공유 샘플러를 통해 최대 128개의 텍스처를 지원한다. (기본설정으로는 안됨, 머티리얼이 있다면 텍스처에서 sampler source를 From Texture Asset에서 공유 샘플러로 변경하면 128개의 텍스처 배치 가능 ) 랜드스케이프 머티리얼의 복잡성: 필요한만큼 조절 가능(보수적으로 작업하는게 좋음- 화면을 차지하는 픽셀의 대부분이 됨) Distance Fading scale/textures 트릭 렌더스케이프에서 타일같은 느낌을 없애는것 멀리서 볼 때 보이던 텍스처 타일링이 어느 정도 거리에서 매크로 텍스처에서는 페이드되어 사라짐 픽셀뎁스같은것 스케일한 다음 그 위에 선형보간하는것 Hard blends 언리얼 엔진은 레이어 간의 하드 블렌딩을 지원한다. 보통 언리얼 엔진의 랜드 스케이프에 페인팅을 하면, 굉장히 부드러운 트랜지션이 나타남, 알파 텍스처를 정의하여 좀 더 확실하고 묵직한 트랜지션을 얻을 수 있음.(weight blend, height blend…) Foliage Foliage Assets 폴리지 패널에 메시를 드래그 하여 넣으면됨. 저장하지 않으면 페인팅 가능한 폴리지로 스태틱 메시를 직접 할당한다. 폴리지 에셋으로 저장 가능. 다른 레벨에서도 똑같은 설정으로 페인팅 가능 Foliage Paint Tool 패널의 설정, 에셋에 그 설정이 저장 모든 레벨에서 바뀌기 때문에 엔진 퀄리티도 높아짐. 잔디 (grass)에서 사용 Range and Shadow 그림자가 있으면 무거워짐 잔디나 조그만 돌에는 그림자를 주지않는것이 좋음 의미도 없음 렌더링 거리는 짧게 유지하는게 좋음 (잔디의 제거 시점, 잔디 렌더링 중지 시점 확실하게 설정) 기본설정으로는 렌더링이 계속해서 이어짐. 거리 조정에 특히 도움이 되는 요소 두가지 Lower position material trick 확 없어지는것은 보기에 좋지않음. 이 트릭을 이용하면 잔디가 땅 속으로 녹아드는 것처럼 보임 페이드하면 반투명한 잔디가 생기기 때문에 좋지 않음.(디더링이나 트랜지션이 없다면 좋은 생각이 아님) Object Position과 Camera Position 여기에 distance를 곱하여 앞쪽에 약간의 데드존을 subtract한 후 안전하게 clamp하면 됨. distance squared를 사용하는게 더 저렴함. Slope material trick 경사면에 잔디를 심으면 잔디가 튀어나오는게 보임 잔디를 표면의 각도에 정렬하면 잔디가 비스듬하게 자라게된다.(수직으로 자라지 않음) 표면에 따라 정렬하면 잔디도 수직으로 자란다. 메시를 회전 =&amp;gt; 어떻게든 수직을 향하려고한다. 다릉 머티리얼을 할당하면 메시를 압축해서 평탄화가 됨. Vert Colors가 적용되었으며 스케일이 굉장히 낮아져서 압축됨. vert colors는 어떤 버텍스를 나타내고 스케일을 높일지 결정 스케일을 높이는 것도 머티리얼을 기반으로 이루어짐.(노멀 기반) 월드 포지션 오프셋을 변경해서 수직으로 높여줌. painting tool 메시가 있는데 타일을 흙으로 페인팅하고 싶은 경우,버텍스 컬러를 페인팅 가능. 텍스처도 페인팅 가능, 텍스처를 인식, 페인팅이 가능하게 세분화된 메시, 나머지 작업은 머티리얼이질문 레이트레이싱 기술 대신 라이트매스 임포턴스 볼륨을 사용? 모든 라이팅이 다이내믹 해진다면 라이트매스 임포턴스 볼륨은 필요가 없어짐 사전 계산된 라이팅에만 사용하는 수단이기 때문 구운 라이팅이 있다면, 라이트매스 임포턴스 볼륨도 있어야함. 레이트레이싱은 아직 아무데나 가져다 사용하지 않음. 현업할 때 레벨은 분야별로 나누는게 좋음.문제 액터를 그룹화하고, 다양한 액터를 프로퍼티를 제어하려고한다면 무엇을 사용? 블루프린트 액터 월드 프로퍼티에서 가장 흔히 세팅하는 2가지 프로퍼티세트 게임모드 라이트매스 프로퍼티 " }, { "title": "[learn-opengl] Coordinate Systems", "url": "/posts/2022/02/15/01/44/learn_opengl7/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-15 01:44:55 +0900", "snippet": "Coordinate Systems OpenGL은 각 정점 쉐이더가 실행된 후에 NDC로 표현된 정점을 기대한다. 즉, 모든 좌표는 -1.0에서 1.0 사이어야한다. 이 범위를 벗어나는 좌표는 보이지 않는다. NDC 좌표를 rasterizer에 제공 =&amp;gt; 화면에서 2D 좌표/픽셀로 변환한다. 좌표를 NDC로 변환한 후 화면좌표로 변환하는 작업: 여러 좌표 시스템으로 변환하는 단계별 방식 이유: 각 단계별로 수행하는 연산/계산이 특정 좌표계에서 더 쉽고 명백 아래와 같은 5가지 좌표계가 있다. Local space (or Object space) World space View space (or Eye space) Clip space Screen space 위 좌표계를 거치면서 vertex가 변형되어 fragment가 된다.The global picture 여러 변환 행렬 사용: 한 공간의 좌표 =&amp;gt; 다음 좌표 공간으로 정점 좌표 =&amp;gt; 로컬 좌표 =&amp;gt; 월드 좌표 =&amp;gt; 뷰 좌표 =&amp;gt; 클립 좌표 =&amp;gt; 화면 좌표 다음 이미지는 프로세스를 표시, 각 변환이 수행하는 작업을 보여준다. 로컬 좌표: 객체의 로컬 원점을 기준으로 한 좌표(객체가 시작하는 좌표) 월드 좌표: 월드의 원점에 상대적으로 배치된 다른 많은 객체가 있음. 뷰 좌표: 월드 좌표를 카메라 또는 뷰어의 시점에서 볼 때와 같은 방식 클립 좌표: 좌표가 뷰 공간에 있으면 좌표를 클립하기 위해 좌표를 투영하려고한다 -1.0~1.0 범위로 처리, 어떤 정점이 화면에 나타날지 결정 (원근분할 =&amp;gt; 정규화장치좌표) 화면 좌표 : 클립좌표 =&amp;gt; glViewport(뷰포트변환) =&amp;gt; 화면 좌표 =&amp;gt; rasterizer =&amp;gt; fragment 정점을 다른 공간으로 변형시키는 이유: 일부 작업이 특정 좌표계에서 더 이해하기 쉽거나 사용하기 쉬움. ex. 로컬 공간에서 객체를 수정하는게 월드보다 더 쉬움 ex. 다른 객체의 위치와 관련해 객체에 대한 특정 계산을 하는 것은 월드 공간이 더 적합 SpacesLocal space 객체가 시작되는 곳. ex. 모델링 소프트웨어(Blender)에서 큐브를 만들었다고 가정, 큐브가 최종적으로 다른 위치에 있더라도 큐브의 원점은 (0, 0, 0) 대부분 모델의 초기 위치는 (0, 0, 0) 따라서 모델의 모든 정점은 로컬 공간에 있다. World space 모든 객체를 응용 프로그램에서 직접 가져오면, 월드 원점인 (0,0,0)을 기준으로 내부에 어딘가에 위치해있을 것이다. 월드 공간의 좌표: 게임 세계와 관련된 모든 정점 좌표 이 좌표 공간은 객체가 변형된 방식으로 모든 자오에 흩어진 형태로 배치 객체 좌표는 로컬에서 월드로 변환된다. (Model Matrix) Model Matrix: 객체를 변환, 크기 조절, 회전 =&amp;gt; 객체가 속한 위치/방향으로 세계에 배치하는 변환 행렬 View space 뷰 공간: OpenGL의 카메라(카메라 공간 또는 시각 공간) 월드 좌표를 사용자 시점 앞에 있는 좌표로 변환한 결과 카메라의 관점에서 본 공간 일반적으로 translate, rotation을 결합, 특정 아이템이 카메라의 전면으로 변환되도록함. 결합된 변환은 world 좌표를 뷰 공간으로 변환하는 View Matrix내에 저장됨. Clip space 각 정점 쉐이더가 끝나면, OpenGL은 좌표가 특정 범위 내에 있고, 이 범위를 벗어나는 모든 좌표는 절단된다. 절단된 좌표는 폐기되고, 나머지 좌표는 화면에 표시되는 fragment가 되어 화면에 보임. 눈에 보이는 모든 좌표들이 -1.0와 1.0범위 안으로 지정하는 것은 직관적이지 않음 그러므로 로컬 =&amp;gt; 월드 =&amp;gt; NDC로 변환하는것 projection matrix: 정점 좌표를 뷰에서 clip-space로 변환하기 위해 좌표의 범위를 지정하는 행렬 ex. 각 축에 대해 -1000에서 1000까지를 범위로 지정 =&amp;gt; 이 행렬은 이 범위 내의 좌표들을 NDC(-1.0, 1.0)으로 변환 지정된 범위 밖에 있는 좌표들은 폐기된다. primitive의 일부가 외부에 있을 경우, OpenGL은 클리핑 범위 내에 맞게 하나 이상의 삼각형으로 삼각형을 재구성한다. 투영 행렬이 생성하는 viewing box (frustum), 이 내부의 정점들은 화면에 보이게됨. 투영(Projection): 2D 뷰 공간 좌표로 쉽게 매핑할 수 있는 NDC로 변환하는 전체 프로세스 원근 분할(perspective division): 절단 좌표로 변환된 후에 수행하는 마지막 작업 위치 벡터의 x, y, z 를 벡터의 w로 나눔. 4D 절단 좌표 =변환=&amp;gt; 3D NDC vertex shader의 실행 마지막에 자동으로 수행 결과 좌표들 =&amp;gt; 화면 좌표에 매핑(뷰포트 변환에 의해) =&amp;gt; rasterizer =&amp;gt; fragment로 변환 projection 행렬: view =&amp;gt; clip 두개의 다른 형식: 정사영(orthographic) projection 행렬, 원근(perspective)projection 행렬 ProjectionsprojectionmatrixOrthographic projection 직교 투영 행렬: 정육면체 절두체, 외부의 정점이 폐기되는 절단 공간을 정의 가시 좌표를 정의: 절두체의 width, height, near, far를 정의 ortho 절두체 내부의 모든 좌표들을 NDC로 매핑한다. 각 벡터의 w요소를 건드리지 않기 때문 w가 1.0이라면, 원근분할은 좌표를 수정하지 않기 때문, glm::ortho 함수 사용 glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f); 파라미터 1, 2: 절두체의 왼, 오 파라미터 3, 4: 절두체의 밑, 위 파라미터 5, 6: near, far 평면 사이의 거리 지정된 projection 행렬은 x, y, z범위 값을 가진 모든 좌표들을 NDC로 변환한다. ortho projection 행렬은 좌표들을 화면의 2D 평면에 똑바로 매핑. 실제로 똑바로 투영하는 것은 비현실적인 결과를 생성 원근감 고려 x 때문 Perspective projection 원근감(perspective): 멀리있는 객체는 작어짐. 원근법 때문에 선이 멀어짐 == 선이 서로 만남 perspective matrix 사용하여 이를 수행 주어진 절도체를 절단된 공간에 매핑 vertex 좌표의 w값을 조작. 시점으로부터 vertex 좌표가 멀어지면, w값 증가. 좌표들이 절단 좌표로 변환되고 나면, -w에서 w까지의 범위를 가짐. 최종적으로 -1 과 1 사이의 범위에 있어야하므로 원근 분할 즉, w로 나눠야한다. \\[out = \\begin{pmatrix} x /w \\\\ y / w \\\\ z / w \\end{pmatrix}\\] 그 계산 다음, 좌표들은 NDC에 있게 된다. GLM에서 다음 함수를 사용하여 생성할 수 있다, 이 함수는 가시 공간을 정의하는 커다란 절두체를 만든다. 절두체 외부의 정점은 폐기된다. 절두체는 균일하지 않은 상자 모양이다. glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); 파라미터 1: fov(field of view): 뷰 공간의 크기를 설정함 현실적인 시점: 일반적인 45도 둠-스타일: 더 높은 값 파라미터 2: 뷰 포트의 너비를 높이로 나눈 값으로 설정, 화면의 비율 설정(종횡비) 파라미터 3: near, far 거리 설정 일반적으로 0.1f, 100.0f로 설정 near 값을 너무 높게(10.0f 같이) 설정 될 때마다 OpenGL은 카메라에 가까운 모든 좌표 (0.0f, 10.0f)를 잘라내어 비디오 게임에서 익숙한 시각적 결과를 제공한다. 정리 ortho: vertex의 각 요소들은 그대로 clip space에 매핑된다. 복잡한 perspective division을 하긴 하지만, w 요소가 조작되지 않는다.(1로 유지) 멀리 떨어진 오브젝트들이 작게 보이지 않음. 2D렌더링 or 구조적이거나 공학 응용프로그램에서 사용됨 또는 각축에 대해 정밀하게 그릴 때 사용 Putting it all together 앞서 언급한 각 단계에 대한 변환 행렬 Model, View, Projection 행렬을 만들고 계산하면 다음과 같이 절단 좌표로 변환된다.$Vclip=Mprojection⋅Mview⋅Mmodel⋅Vlocal$ 결과로 나오는 정점은 gl_Position에 할당되어야하며, OpenGL은 원근감 분할 및 자르기를 자동으로 수행한다. 정점 쉐이더의 출력은 좌표계가 절단 좌표계, OpenGL은 클립 공간 좌표를 투시-분할해 NDC로 변환한다. 뷰포트 변환: OpenGL은 glViewPort의 매개변수를 사용해 NDC를 화면 좌표의 한 지점에 해당하는 화면 좌표에 매핑한다.Going 3D 위의 내용은 전부 3D좌표를 2D 좌표로 변환하는 방법임. 이제 3D 드로잉을 할 수 있다. 먼저 모델 행렬을 만들어야한다. 모델 행렬은 모든 오브젝트의 정점을 글로벌 월드 공간으로 변환하기위해 적용하고자 하는 translation, scaling, rotations로 구성된다. glm::mat4 model = glm::mat4(1.0f);model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f)); 정점 좌표에 위 모델 행렬을 곱해 정점 좌표를 world좌표로 변환할 수 있다. 다음으로 뷰 행렬을 보자 물체가 원점(0,0,0)에 있을 때 장면에서 약간 후방으로 이동하는것을 생각해보자 카메라가 뒤로 이동 == 전체 장면을 앞으로 이동 이것이 뷰 행렬이 하는것. 전체 장면을 반전시켜 카메라를 움직이기 원하는 위치로 이동시킴 OpenGL은 right-handed시스템 == z축의 양의 방향으로 이동해야한다. 장면을 음의 z축 방향으로 변환하면 된다. (뒤로 움직이고 있다는 느낌을 줌) Right-handed system: 기본적으로 양의 x축은 오른쪽으로, 양의 y축은 위로, 양의 z축은 뒤로 향하는것 화면은 3축의 중심. 양의 z축은 화면을 통해 사용자쪽으로 향하게된다, 축은 아래와 같이 그려짐 z축이 뒤바뀐것은 left-handed system, 일반적으로 DirectX에서 사용, 정규화된 장치 좌표에서 OpenGL은 실제로 left-handed system을 사용한다. 현재 뷰행렬은 다음과 같다.glm::mat4 view = glm::mat4(1.0f);// note that we&#39;re translating the scene in the reverse direction of where we want to moveview = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); 마지막으로 projection 행렬glm::mat4 projection;projection = glm::perspective(glm::radians(45.0f), 800.0f / 600.0f, 0.1f, 100.0f); 이제 변환행렬은 다 만들었고, 이를 쉐이더에 전달해야한다. 먼저 변환행렬을 정점 쉐이더에 유니폼으로 선언, 정점 좌표를 곱한다. #version 330 corelayout (location = 0) in vec3 aPos;...uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main(){ // note that we read the multiplication from right to left gl_Position = projection * view * model * vec4(aPos, 1.0); ...} 이제 행렬을 쉐이더에 보내야한다.int modelLoc = glGetUniformLocation(ourShader.ID, &quot;model&quot;);glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));... // same for View Matrix and Projection Matrix mvp행렬을 통해 변환되므로, 최종 객체는 다음과 같다. 뒤쪽 바닥으로 기울어짐 우리한테 조금 멀어짐 원근법으로 표시 More 3D 이제 2D 평면을 3D 큐브로 확장해보자 큐브렌더링 == 총 36개의 꼭짓점 큐브가 시간이 지남에 따라 회전하도록하자 model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f)); 이제 glDrawArrays함수로 큐브를 그려보자.glDrawArrays(GL_TRIANGLES, 0, 36);영상 주소 위의 영상은 큐브같지 않다. 큐브의 일부 측면이 큐브의 다른 측면 위에 그려지고 있음. 삼각형 단위로 그리기 때문에 발생하는 현상 다른 픽셀이 이미 그려져 있음에도 불구하고 위에 픽셀을 그리는것 깊이 정보를 담는 z-buffer를 활용해서 OpenGL이 픽셀 위에 그릴 것인지 안 그릴것인지 결정하게 할 수 있다. depth-testing Z-buffer OpenGL은 모든 깊이 정보를 깊이 버퍼라고하는 z버퍼에 저장한다. GLFW는 이와 같은 버퍼를 자동으로 생성한다.(출력 이미지의 컬러를 저장하는 컬러버퍼처럼) 깊이는 각 fragment(fragment의 z값으로)안에 저장됨. fragment가 출력되길 원할때마다 OpenGL은 해당 깊이값과 z 버퍼를 비교함 그 후 현재 fragment가 다른 fragment 뒤에 있으면 폐기되고, 그렇지 않으면 덮어쓴다. 이 과정을 깊이 테스트라 하고, OpenGL에 의해 자동으로 수행됨 하지만 OpenGL이 실제 이를 수행하려면 사용할 것이라는 것을 알려줘야한다. glEnable함수를 사용하여 활성화할 수 있다. 이 함수는 특정 기능을 활성화/비활성화할 수 있다. glEnable(GL_DEPTH_TEST); 깊이 버퍼를 사용하고 있기 때문에, 이 버퍼도 정리해줘야한다.(그렇지 않으면 이전 프레임 정보가 그대로 남아 있음)glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);전체 소스코드More cubes! 10개의 정육면체를 출력해보자 똑같이 생겼지만, 위치와 회전도 다름. 레이아웃은 이미 정의됨 =&amp;gt; 버퍼나 attribute배열들을 수정할 필요가 없다. 수정해야하는것은 model행렬 glm::vec3 cubePositions[] = { glm::vec3( 0.0f, 0.0f, 0.0f), glm::vec3( 2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3( 2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3( 1.3f, -2.0f, -2.5f), glm::vec3( 1.5f, 2.0f, -2.5f), glm::vec3( 1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f)}; 이제 게임루프 안에서 glDrawArrays함수를 여러번 호출하면, 렌더링할 때마다 다른 model 행렬을 vertex shader에게 보낼것이다.glBindVertexArray(VAO);for(unsigned int i = 0; i &amp;lt; 10; i++){ glm::mat4 model = glm::mat4(1.0f); model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); ourShader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 36);} 이 코드는 각 새로운 정육면체가 렌더링될 때마다 model행렬을 수정하고, 이것을 총 10번 반복한다. 그러므로 10개의 정육면체가 그려진다. 전체코드2출처Coordinate-Systemsnear" }, { "title": "[learn-opengl] Transformations", "url": "/posts/2022/02/14/07/09/learn_opengl6/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-14 07:09:26 +0900", "snippet": "벡터, 내적, 외적, 행렬은 생략그래픽스 변환 강체 변환(rigifbody transformation) 이동변환 + 회전변환 모습은 불변 유사변환(similarity transformation) 강체변환 + 균등크기조절변환 + 반사변환 물체사이의 각이 유지 물체내부 정점간의 거리가 일정한 비율로 유지 어파인 변환(affine transformation) 유사변환 + 차등 크기조절 + 전단 : 물체의 타입이 유지, 변환행렬의 마지막 행이 (0, 0, 0, 1) 원근 변환(perspective transformation) 평행선이 만남, 소실점에서 만남, 마지막행이 (0, 0, 0, 1) 이 아님 선형 변환(linear transformation) 어파인 + 원근 : 선형조합으로 표시되는 변환 비선형변환 Scaling matrix 비균일 스케일, 차등 크기조절(non-uniform)의 예시인 위 사진은 x축으로 0.5, y축으로 2 스케일링한것 균일 스케일, 균등 크기조절(uniform) 은 모든 축이 동일한 스케일링 스케일 변환 행렬은 단위 행렬에 각 대각 요소가 대응하는 벡터 요소와 곱해진 것과 같다. Translation 벡터를 이동하는 행렬 단위 벡터에 이동할만큼 맨 끝 열에 추가 동차좌표계의 장점이 돋보임 Rotationhttps://www.youtube.com/watch?v=gxUcgc88tD4&amp;amp;list=PL8327DO66nu9qYVKLDmdLW_84-yE4auCR&amp;amp;index=12Most rotation functions require an angle in radians, but luckily degrees are easily converted to radians:angle in degrees = angle in radians * (180 / PI)angle in radians = angle in degrees * (PI / 180)Where PI equals (rounded) 3.14159265359.3d 공간에서의 회전은 각 그리고 회전축을 사용한다. 주어진 회전축에 대해 회전시키는것 삼각법을 사용하여 주어진 각에 대해 벡터를 회전하여 새로운 벡터로 변환하는것 sin , cos 의 조합 (싸코 공식) 회전행렬을 사용하면 위치 벡터를 세가지 축 중 하나에 대해 변환시킬 수 있다. 여러 회전을 조합할 수 있음 (하지만 Gimbal lock 문제가 일어날 수 있음) 회전 행렬을 조합하는 것 대신 임의의 단위 축을 중심으로 즉시 회전하는것이 더 바람직함 밑은 회전축이 (Rx, Ry, Rz) 일 경우의 회전행렬(완벽히 gimbal lack을 예방하지 못함) 완전히 안전한것은 사원수(quaternions)를 사용하여 회전하는것 Combining Matrices 여러 변환 행렬을 조합해서 사용할 수 있다는것은 행렬의 장점중 하나이다. 곱의 교환법칙이 성립하지 않으므로 곱하는 순서를 정하는것이 중요하다. 가장 오른쪽에 있는 행렬이 벡터와 처음 곱해짐. GLM 사용#include &amp;lt;glm/glm.hpp&amp;gt;#include &amp;lt;glm/gtc/matrix_transform.hpp&amp;gt;#include &amp;lt;glm/gtc/type_ptr.hpp&amp;gt; 0.9.9 버전 부터 초기화된 기본행렬이 단위행렬이 아니고 0으로 초기화됨 다음 함수를 사용하여 단위행렬로 초기화해야함. glm::mat4 mat = glm::mat4(1.0f)translate 동차좌표계를 사용하고 있다는것을 주의해야한다. (1, 1, 0) 만큼 이동시키는 예 glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);glm::mat4 trans;trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));vec = trans * vec;std::cout &amp;lt;&amp;lt; vec.x &amp;lt;&amp;lt; vec.y &amp;lt;&amp;lt; vec.z &amp;lt;&amp;lt; std::endl;rotate, scaleglm::mat4 trans = glm::mat4(1.0f);trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5)); rotate = (0.0, 0.0, 1.0): z축을 기준으로 회전 (x, y평면이기 때문) 중심으로 돌리기 위한 축은 반드시 단위벡터여야함. 정규화 필수. scale = (0.5, 0.5, 0.5): 균등 크기조절, 2배 작개 GLM 함수에 행렬을 전달하기 때문에, 서로곱한 결과로 모든 변환이 조합된 행렬이 리턴 shader에서 변환행렬 가져오기#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoord;out vec2 TexCoord;uniform mat4 transform;void main(){ gl_Position = transform * vec4(aPos, 1.0f); TexCoord = vec2(aTexCoord.x, aTexCoord.y);} glsl mat4 타입으로 uniform으로 선언한다음, 각 연산에 vertex pos에 곱해줌 스칼라-행렬 곱, 행렬-벡터 곱, 행렬-행렬 곱 같은 연산 지원해줌 uniform 설정unsigned int transformLoc = glGetUniformLocation(ourShader.ID, &quot;transform&quot;);glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));glUniformMatrix4fv 파라미터 1 : location 파라미터 2 : 행렬의 개수 파라미터 3 : column-major ordering : GLM의 기본행렬 레이아웃인 내부행렬 레이아웃을 사용, 행과 열을 바꿀 필요가 없음, false로 지정 파라미터 4 : 실제 행렬 데이터, value_ptr함수를 사용하여 행렬을 변환해서 타입을 맞춤. reinterpret_cast&amp;lt;float*&amp;gt;(&amp;amp;trans) == glm::value_ptr(trans) == &amp;amp;trans[0][0] reinterpret_cast: 모든 포인터 타입간의 형변환을 허용.(static_cast는 오직 상속관계의 포인터 끼리만, 컴파일 시간에 캐스팅 완료), 이전 값에 대한 바이너리를 유지(타입에 따라 출력되는 값이 다를 수 있음, 값만 달라질 뿐)제자리 회전, 이동glm::mat4 trans;trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f)); 실제 변환순서는 거꾸로 읽어야한다. (정점을 기준으로 제일먼저 곱해져 변환이 행해지는것은 rotate)출처Transformations" }, { "title": "[learn-opengl] Textures", "url": "/posts/2022/02/14/04/00/learn_opengl5/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-14 04:00:58 +0900", "snippet": "Textures 각 모델에는 더많은 vertex들이 필요, 각 vertex는 컬러 attributes이 필요 =&amp;gt; 오버헤드 텍스처 : 2D, 1D, 3D image vertex를 추가하지 않아도 오브젝트가 매우 세밀하게 묘사된것처럼 텍스쳐는 많은 양의 데이터를 저장하여 shader에 보낼 수 있음. 삼각형에 매핑 각 vertex에 텍스처의 어느 부분이 해당하는지 알려주어야함. 각 vertex에는 샘플링할 texture coorfinate 가 있어야함 fragment 보간을 통해 텍스처 좌표 를 보간 텍스처 좌표의 범위 x와 y축상의 0~1 텍스쳐 좌표를 사용하여 텍스쳐 컬러를 가져오는것을 sampling이라고 함. 좌측하단 vertex : (0, 0) 우측하단 vertex : (1, 0) 중앙상단 vertex : (0.5, 1.0) vertex shader에 3개의 텍스처 좌표를 전달 fragment shader에 전달 =&amp;gt; 모든 텍스처 좌표를 각 fragment에 보간 float texCoords[] = { 0.0f, 0.0f, // lower-left corner 1.0f, 0.0f, // lower-right corner 0.5f, 1.0f // top-center corner}; OpenGL에게 sample 하는 방법을 알려줘야함Texture Wrapping 텍스처 좌표의 범위는 (0, 0) ~ (1, 1) 이다 OpenGL의 기본 동작은 텍스처 이미지를 반복하는 것. 기본적으로 텍스처 좌표에 정수 부분을 무시. 아래와 같은 옵션을 사용할 수 있다. GL_REPEAT: 텍스처의 기본 동작, 이미지를 반복 GL_MIRRORED_REPEAT: GL_REPEAT와 같지만 반복할때마다 이미지를 반대로 뒤집음 GL_CLAMP_TO_EDGE: 0과 1 사이의 좌표를 고정, 결과적으로 큰 좌표가 가장자리에 고정되어 가장자리의 패턴이 늘어남. GL_CLAMP_TO_BORDER: 범위 밖의 좌표에 사용자가 지정한 테두리 색이 지정. = 기본 범위 밖의 좌표를 사용할 때 각 옵션을 통해 출력 형식 설정= 각 옵션들은 glTexParameter* 함수를 사용하여 좌표축별로 설정 가능glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 파라미터 1 : 텍스처 타겟을 지정, 2D = GL_TEXTURE_2D 파라미터 2 : 설정할 옵션과 어떤 축에 적용할 것인지 지정 (s, t, r == x, y , z) WRAP 옵션을 s, t 에 파라미터 3 : wrapping 모드를 설정 GL_MIRRORED_REPEAT : 현재 활성화된 텍스처의 옵션을 설정 GL_CLAMP_TO_BORDER 옵션인 경우 테두리 색 정해줘야함. fv를 사용하는 glTexParameter 함수를 호출 =&amp;gt; 파라미터로 GL_TEXTURE_BORDER_COLOR 옵션 설정해야됨 float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);Texture Filtering 좌표는 해상도에 의존하지 않음. 하지만 실수 값이 될 수 있음 OpenGL은 텍스처 좌표를 매핑할 텍스쳐 픽셀 (텍셀(texel)) 을 찾아야함 매우 큰 물체에 낮은 해상도의 텍스처가 있는 경우 특히 중요. 이를 위한게 texture filtering 옵션 GL_NEAREST, GL_LINEAR GL_NEAREST nearest neighbor filtering 기본적인 필터링 방법 텍셀의 중심이 텍스처 좌표에 가장 가까운 텍셀을 선택 GL_LINEAR bilinear filtering 텍스처 좌표의 이웃한 텍셀에서 보간된 값을 가져와 텍셀 사이의 색상의 근사치를 가져온다. 텍셀의 중심까지의 거리가 가까울수록 그 색이 더 강함 큰 오브젝트에 해상도가 낮은 텍스처를 사용할 때 (텍스처 스케일 업, 텍셀들이 눈에 띔) Nearest 는 blocked pattern 명확히 볼 수 있음 (8-bit look) Linear 은 smoother pattern 로 개별 픽셀들이 덜 보임. 확대(magnifying), 축소(minifying) 작업에 대해 설정 축소 : nearest 확대 : linear glTexParameter* 함수를 통해 필터링 방법을 지정해야함. glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);Mipmaps 수천개의 오브젝트가 있는 넓은 공간에 각각에 텍스처가 첨부될 경우 오브젝트가 멀리 떨어진것 : 몇개의 fragment만 생성, 텍스쳐의 대부분을 차지하는 fragment를 위한 텍스처 색상을 선택 고해상도 텍스처에서 해당 fragment의 올바른 색상 값을 가져오는데 어려움을 겪는다. 작은 물체에 고해상도 텍스처를 사용하여 메모리 낭비, 물체에 결함이 보일 수 있음 mipmaps 텍스처의 집합, 순차적으로 이전 텍스처보다 2배씩 작아지는 텍스처들 특정 거리 임계값을 넘으면 적합한 mipmap 텍스처를 사용하게됨 작은 해상도의 텍스처는 사용자 눈에 잘띄지않음 성능 향상에 도움 (적은 캐시 메모리의 사용) 수작업 : cumbersome (성가신) OpenGL 은 glGenerateMipmaps 함수를 통해 mipmaps을 생성 렌더링 중 mipmap을 전환할때 OpenGL은 mipmap레이어 사이에, 가장자리가 선명하게 나타날 수 있는 결함이 생길 수 있음 nearest, linear 필터링을 사용하여 mipmap 레벨 사이를 필터링 할 수 있음. mipmap레벨 사이의 필터링 방법을 지정하기 위해 필터링 방법을 4가지 옵션중 하나로 대체가능 glTexParameteri 사용 GL_NEAREST_MIPMAP_NEAREST nearest neighbor 보간법으로 mipmap을 필터링하고, 텍스처 샘플링도 nearest neghbor 보간법을 사용 GL_LINEAR_MIPMAP_NEAREST: nearest neighbor 보간법으로 mipmap을 필터링, 텍스처 샘플링은 linear 보간법을 사용 GL_NEAREST_MIPMAP_LINEAR: linear 보간법으로 mipmap을 필터링, 텍스처 샘플링은 nearest neighbor 보간법을 사용 GL_LINEAR_MIPMAP_LINEAR: linear 보간법으로 mipmap을 필터링, 텍스처 샘플링도 linear 보간법을 사용 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); **주의** : mipmap 필터링 옵션중 하나를 확대 필터로 설정하는것=&amp;gt; mipmap은 축소될때 주로 사용, 확대인 경우 효과 없음=&amp;gt; GL_INVALID_ENUM 오류코드Loading and creating textures 응용프로그램에 텍스처를 로드 텍스처 이미지는 수십가지 파일 형식으로 저장될 수 잇음 각 형식은 고유한 구조와 데이터 순서로 되어있음 해결책1: 파일 형식을 선택(png), 이미지 형식을 큰 바이트 배열로 변환하는 이미지 로더 작성 해결책2: 더 많은 파일 형식을 지원해야하는것 =&amp;gt; 이미지로더를 형식에 맞게 작성 =&amp;gt; stb_image.h 라이브러리 이용 stb_image.h= cpp에 아래 코드 추가.#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot; STB_IMAGE_IMPLEMENTATION : 전처리기(preprocessor) 는 헤더 파일을 관련된 정의 소스코드만 포함하도록함.int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0);// stbi_load(filename_, &amp;amp;tex_width_, &amp;amp;tex_height_, &amp;amp;tex_channels_, STBI_rgb_alpha); 이미지 포맷을 기본적으로 rgba로 읽는 코드 텍스처를 생성하기 위해서, width 와 height 정보가 필요함.Generating a texture 이전 객체들과 마찬가지로 ID로 참조glGenTextures 함수 파라미터 1: 생성할 객체의 크기 파라미터 2: ID 배열 unsigned int texture;glGenTextures(1, &amp;amp;texture);glBindTexture 함수 텍스처를 바인딩, 그 후 명령이 현재 바인딩된 텍스처를 대상으로 설정glBindTexture(GL_TEXTURE_2D, texture);glTexImage2D 이전에 로드된 이미지 데이터를 사용하여, 텍스처를 생성할 수 있음 한번 호출하면 현재 바인딩된 객체가 첨부된 이미지를 가지게됨 mipmap을 사용하고 싶으면 glGenerateMipmap =&amp;gt; 현재 바인딩된 텍스처에 대해 자동 생성 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);glGenerateMipmap(GL_TEXTURE_2D); 파라미터 1 : 텍스처 타겟을 지정(GL_TEXTURE_2D로 바인딩 된 객체에 텍스처 생성하겠다는 것) GL_TEXTURE_1D, GL_TEXTURE_3D 로 바인딩된 객체에는 아무런 영향을 끼치지 않음 파라미터 2 : mipmap 레벨을 수동으로 지정 (수작업으로 mipmap 만들었을 경우) 파라미터 3 : 텍스처가 어떤 포멧을 가져야하는지, 다룰 이미지는 RGB 값만 가지므로 GL_RGB 파라미터 4~5 : 텍스처의 너비와 높이를 설정 파라미터 6 : 항상 0 의 값이 되어야함. (legacy stuff) 파라미터 7~8 : 원본 이미지의 포맷과 데이터 타입 지정, RGB값이 있는 이미지를 로드, chars(bytes)로 저장한것 파라미터 9 : 실제 이미지의 데이터 이미지의 메모리 반환(텍스처와 mipmap들을 생성한 후)stbi_image_free(data);전체적인 과정unsigned int texture;glGenTextures(1, &amp;amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// set the texture wrapping/filtering options (on the currently bound texture object)glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// load and generate the textureint width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0);if (data){ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D);}else{ std::cout &amp;lt;&amp;lt; &quot;Failed to load texture&quot; &amp;lt;&amp;lt; std::endl;}stbi_image_free(data);Applying textures OpenGL에게 텍스처를 샘플하는 방법을 알려주어야하므로, 텍스처 좌표를 vertex 데이터에 추가해야함float vertices[] = { // positions // colors // texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // top left}; vertex attribute를 추가했기 때문에, OpenGL에게 새로운 vertex 포맷을 다시 알려주어야함.텍스쳐 좌표 : stride = 8, offset = 6glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2);vertex shader 에 텍스처 좌표값 추가#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main(){ gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexCoord;}fragment shader 에 sample 넘겨줌 fragment shader 는 텍스처 객체에 접근해야함. sampler 텍스처 객체 타입 사용 : sampler1D, sampler2D, sampler3D 텍스처를 집어넣을 uniform sampler2D를 선언 : fragment shader에 전달 할 수 있음 #version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D ourTexture;void main(){ FragColor = texture(ourTexture, TexCoord);}texture 함수 앞서 설정했던 텍스처 파라미터를 사용하여 해당 컬러값을 샘플링 출력은 보간된 텍스처 좌표에서 필터링된 텍스처의 컬러값임. 파라미터 1 : 텍스처 sampler 파라미터 2 : 텍스처 좌표 glDrawElements 호출하기 전에 텍스처를 바인딩, 텍스처를 fragment shader의 sampler로 자동으로 할당하게 된다.glBindTexture(GL_TEXTURE_2D, texture);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 최종 텍스처 컬러와 vertex 컬러를 혼합할 수 있음FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);Texture Units glUniform 함수를 사용하지 않음에도 sampler2D 변수가 uniform 인지 glUniform1i함수를 사용하여 실제 텍스처 sampler에 위치 값을 할당하여 fragment shader에서 동시에 여러 텍스처들을 설정할 수 있음 이 텍스처 위치는 texture unit이라고 불림 기본 텍스처 유닛은 0 이는 기본으로 활성화된 텍스처 유닛이므로, 앞에서는 할당할 필요가 없었음. 모든 그래픽 드라이버가 기본 텍스처 유닛을 할당하는 것이 아님. 텍스처 유닛의 주 목적 : shader에서 하나 이상의 텍스처를 사용할 수 있도록. sampler 에 텍스처 유닛을 할당함으로, 해당 텍스처 유닛을 활성화하기만 하면 여러 텍스처들을 동시에 바인딩 가능 glActiveTexture 함수glActiveTexture(GL_TEXTURE0); // activate the texture unit first before binding textureglBindTexture(GL_TEXTURE_2D, texture); 바인딩하기전 텍스처 유닛을 전달하여 활성화 활성화한 후에 호출되는 bind 함수는 현재 활성화된 텍스처 유닛에 바인딩. OpenGL은 최소 16개의 텍스처 유닛을 가지고 있음 GL_TEXTURE0에서부터 GL_TEXTURE15 순서대로 선언되어 있음 = GL_TEXTURE8 == GL_TEXTURE0 + 8fragment shader 수정mix 함수#version 330 core...uniform sampler2D texture1;uniform sampler2D texture2;void main(){ FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);} 두개의 텍스처를 혼합 파라미터 3 : 0.0 -&amp;gt; 첫번째 텍스처 , 1.0 -&amp;gt; 두번째 텍스처 , 0.2 -&amp;gt; 첫번째 80% 두번째20% 다른 텍스처를 로드하고 생성 RGBA를 사용하여 alpha 채널을 포함하고 있는 이미지임을 명시unsigned char *data = stbi_load(&quot;awesomeface.png&quot;, &amp;amp;width, &amp;amp;height, &amp;amp;nrChannels, 0);if (data){ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D);} 두개의 텍스처를 해당 텍스처 유닛에 모두 바인딩해야함.glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 각 sampler를 설정함으로써 OpenGL에게 각 sampler가 속하는 텍스처 유닛이 어떤것인지 알려줘야한다.ourShader.use(); // don&#39;t forget to activate the shader before setting uniforms!glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // set it manuallyourShader.setInt(&quot;texture2&quot;, 1); // or with shader classwhile(...){ [...]} OpenGL은 Y축의 0.0좌표를 이미지의 아래쪽으로 인식 하지만 대부분의 이미지는 0.0좌표를 Y축의 맨 위를 가리킴. 이미지를 로드하기전 다음 코드를 추가하면 뒤집을 수 있음. stbi_set_flip_vertically_on_load(true);출처learn-opengl Textures" }, { "title": "[learn-opengl] Shaders", "url": "/posts/2022/02/14/00/17/learn_opengl4/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-14 00:17:20 +0900", "snippet": "Shaders GPU에서 동작하는 프로그램 (little programs tat rest on the GPU) 파이프라인 각 단계마다 사용되는 shader가 다름 shader는 입력값을 출력값으로 변환시키는 프로그램으로 아주 독립적인(isolated) 프로그램 서로 통신할 수 없음. 유일한 통신은 입력값과 출력값을 통해서하는것 GLSL Shader는 C언어와 비슷한 GLSL로 작성한다. GLSL is tailored for use with graphics and contains useful features : vector + matrix manipulation. 항상 버전 선언으로 시작 그다음으로 입력 변수와 출력변수들이 나오게됨 uniform이 나오고, 그 후엔 main 함수 shader의 시작지점은 main 함수부터 -&amp;gt; 모든 입력 변수를 처리, 출력 변수로 결과를 출력 #version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;void main(){// 입력 값을 처리하고 그래픽 작업을 합니다....// 처리된 것을 출력 변수로 출력합니다.out_variable_name = weird_stuff_we_processed;}Vertex shader 각각의 입력변수 : vertex attribute 하드웨어에 의해 제한되어 선언할 수 있는 최대 개수가 정해짐 4-component vertex attribute를 최소 16개까지 보장 (대부분 작업에서 충분) GL_MAX_VERTEX_ATTRIBS 를 통해 하드웨어의 허용 개수를 알 수 있다. int nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;amp;nrAttributes);std::cout &amp;lt;&amp;lt; &quot;Maximum nr of vertex attributes supported: &quot; &amp;lt;&amp;lt; nrAttributes &amp;lt;&amp;lt; std::endl;GLSL Types c언어와 같은 언어에서 볼 수 있는 기본적인 타입들의 대부분을 가지고 있다. (int, float, double, uint, bool) 두가지 컨테이너 타입 vector, matrics GLSL Vectors Vector 는 1~4가지 요소를 가진 컨테이너 n은 components의 개수 vecn: n개의 float 타입 bvecn: n개의 boolean 타입 ivecn: n개의 integer 타입 uvecn: n개의 unsigned integer 타입 dvecn: n개의 double 타입 float 타입이 대부분 충분하기 때문에 vecn을 보통 사용 component 접근 : vec.x .y .z .w rgba : 컬러값 stpq : 텍스쳐 좌표 GLSL Vector swizzlingvec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy; 새로운 벡터를 성성하기위해, component의 조합을 표시vec2 vect = vec2(0.5, 0.7);vec4 result = vec4(vect, 0.0, 0.0);vec4 otherResult = vec4(result.xyz, 1.0); 모든 유형의 입출력에 사용할 수 있는 유연한 데이터 타입Ins and Outs 입력과 출력 : 키워드 in, out 로 정의 각 shader는 이 키워드들로 출력 변수가 다음 shader의 어떤 입력 변수와 맞는지 지정할 수 있음 vertex shader : 일정한 형태의 입력을 받아야함. vertex 데이터를 곧바로 입력으로 받음. 어떻게 구성되어있는지 정의 = location 메타데이터와 함께 입력변수지정 CPU에 vertex attribute를 구성할 수 있음 layout (location = 0) =&amp;gt; 입력에 대해 별도의 layout 명시, vertex 데이터와 연결 glGetAttribLocation 함수를 사용하여 연결할 수 있으나 shader에 설정하는것이 권장됨 fragment shader : 최종 출력 컬러를 생성해야함 vec4 타입의 컬러 출력 변수가 필요 fragment shader에서 출력 컬러 지정하는 것이 실패되면 검정 or white 로 렌더링됨 shader 간 통신 데이터를 shader 에서 shader로 넘기고싶으면, 보내는 shader에서 출력을 선언해야하고 받는쪽에서도 출력을 선언해야함. 양쪽의 타입과 이름이 같으면 OpenGL은 그 변수들을 연결 시켜 shader 간에 데이터를 보낼 수 있음 (program 객체의 연결이 완료되면)#version 330 corelayout (location = 0) in vec3 aPos; // the position variable has attribute position 0out vec4 vertexColor; // specify a color output to the fragment shadervoid main(){gl_Position = vec4(aPos, 1.0); // see how we directly give a vec3 to vec4&#39;s constructorvertexColor = vec4(0.5, 0.0, 0.0, 1.0); // set the output variable to a dark-red color}#version 330 coreout vec4 FragColor;in vec4 vertexColor; // the input variable from the vertex shader (same name and same type)void main(){FragColor = vertexColor;} vertex shader 에 vec4 타입 선언 =&amp;gt; 출력 , fragment shader =&amp;gt; 입력 선언 =&amp;gt; 통신Uniforms 설정 CPU위의 응용 프로그램에서 GPU 위의 shader 로 데이터를 전달하는 vertex attribute와는 다른 방법. uniform 은 전역변수로, shader 프로그램 객체에서 고유한 변수ㅀ 모든 파이프라인의 단계에서 모든 쉐이더가 접근할 수 있는것 uniform 은 값을 reset 하거나 updated 하기 전까지 유지한다. 타입과 이름 앞에 uniform 키워드를 추가해야함. #version 330 coreout vec4 FragColor;uniform vec4 ourColor; // we set this variable in the OpenGL code.void main(){FragColor = ourColor;} 전역 변수이기 때문에 fragment shader에서 다시 vertex 로 갈 필요가 없음 Vertex shader 에서 uniform을 사용하지 않으므로, 정의할 필요 없음 GLSL shader 코드에서 사용하지 않는 uniform 변수를 선언하면, 컴파일된 버전에서 자동으로 그 변수를 삭제하여 오류가 생길 수 가 있다. 현재 uniform 변수인 ourColor는 비어있음,float timeValue = glfwGetTime();float greenValue = (sin(timeValue) / 2.0f) + 0.5f;int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);데이터 삽입방법 shader 에서 uniform attribute의 index/ location을 찾아야함. uniform의 index/ location을 알아내기만 하면, 값을 수정할 수 있음. 시간에 따라 색 변경 glfwGetTime =&amp;gt; 초단위로 실행시간 검색 (timer measures time elapsed since the call to glfwInit) sin 함수로 0.0 - 1.0 사이의 값으로 변환 glGetUniformLocation glGetUniformLocation 함수가 -1 리턴 : location을 찾지 못한것. glUniform4f 함수를 사용하여 uniform 변수의 값을 설정할 수 있음. Uniform 값을 수정할때 현재 활성화된 shader program의 값을 변경하는거니 glUseProgram을 호출해서 활성화 오버로딩을 지원하지 않음 =&amp;gt; core : C라이브러리 =&amp;gt; 접미사 f: the function expects a float as its value. i: the function expects an int as its value. ui: the function expects an unsigned int as its value. 3f: the function expects 3 floats as its value. fv: the function expects a float vector/array as its value.Uniforms 사용 렌더링 루프안에서 uniform을 수정을 해줘야함.while(!glfwWindowShouldClose(window)){ // input processInput(window); // render // clear the colorbuffer glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); // be sure to activate the shader glUseProgram(shaderProgram); // update the uniform color float timeValue = glfwGetTime(); float greenValue = sin(timeValue) / 2.0f + 0.5f; int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;); glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); // now render the triangle glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); // swap buffers and poll IO events glfwSwapBuffers(window); glfwPollEvents();}More Attributes컬러 데이터 추가float vertices[] = {// positions // colors0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom right-0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // bottom left0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // top}; vertex shader에 보낼 추가 데이터가 있기 때문에 vertex attribute 입력으로 컬러값도 받도록 vertex shader 수정 layout (location = 1) 로 컬러값을 받음 #version 330 corelayout (location = 0) in vec3 aPos; // the position variable has attribute position 0layout (location = 1) in vec3 aColor; // the color variable has attribute position 1out vec3 ourColor; // output a color to the fragment shadervoid main(){gl_Position = vec4(aPos, 1.0);ourColor = aColor; // set ourColor to the input color we got from the vertex data} fragment의 컬러를 위해 uniform을 사용할 필요가 없으니 in 키워드 사용#version 330 coreout vec4 FragColor;in vec3 ourColor;void main(){FragColor = vec4(ourColor, 1.0);}vertex attribute pointer 추가적인 vertex attribute를 추가하고, VBO의 메모리를 수정하였기 때문에 vertex attribute pointer를 다시 구성해야함. VBO 메모리의 수정된 데이터는 위와 같음. 현재 layout을 알고 있으면 glVertexAttribPointer 함수를 사용하여 vertex 형식을 수정할 수 있다. // position attributeglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// color attributeglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));glEnableVertexAttribArray(1); stride 값을 다시설정해야고, 컬러에서 offset 지정 fragment interpolation 으로 인해 색이 퍼짐 삼각형을 렌더링할때 rasterization 단계는 더 많은 fragment를 생성 삼각형의 어느 부분을 맡고 있는지에 기반하여, 각 fragment를 생성 그다음 fragment의 위치를 결정 이 위치들을 기반으로, fragment shader의 모든 입력 변수를 보간 (interpolate)함. fragment interpolation은 fragment shader의 모든 입력 attribute에 적용됨. shader class 소스코드로 관리, 디스크에서 shader를 읽고, 컴파일, 연결, 오류확인하는 class를 만들면 편리하다. 이식성을 위해 헤더파일에 전체적으로 클래스 생성. #ifndef SHADER_H#define SHADER_H#include &amp;lt;glad/glad.h&amp;gt; // include glad to get all the required OpenGL headers#include &amp;lt;string&amp;gt;#include &amp;lt;fstream&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;iostream&amp;gt;class Shader{public:// the program IDunsigned int ID; // constructor reads and builds the shader Shader(const char* vertexPath, const char* fragmentPath); // use/activate the shader void use(); // utility uniform functions void setBool(const std::string &amp;amp;name, bool value) const; void setInt(const std::string &amp;amp;name, int value) const; void setFloat(const std::string &amp;amp;name, float value) const;};#endifReading from file 파일 -&amp;gt; string : filestreamShader(const char* vertexPath, const char* fragmentPath){ // 1. retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // ensure ifstream objects can throw exceptions: vShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions (std::ifstream::failbit | std::ifstream::badbit); try { // open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // read file&#39;s buffer contents into streams vShaderStream &amp;lt;&amp;lt; vShaderFile.rdbuf(); fShaderStream &amp;lt;&amp;lt; fShaderFile.rdbuf(); // close file handlers vShaderFile.close(); fShaderFile.close(); // convert stream into string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); } catch(std::ifstream::failure e) { std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &amp;lt;&amp;lt; std::endl; } const char* vShaderCode = vertexCode.c_str(); const char* fShaderCode = fragmentCode.c_str(); [...]compile &amp;amp; link &amp;amp; error// 2. compile shadersunsigned int vertex, fragment;int success;char infoLog[512];// vertex Shadervertex = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertex, 1, &amp;amp;vShaderCode, NULL);glCompileShader(vertex);// print compile errors if anyglGetShaderiv(vertex, GL_COMPILE_STATUS, &amp;amp;success);if(!success){ glGetShaderInfoLog(vertex, 512, NULL, infoLog); std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;};// similiar for Fragment Shader[...]// shader ProgramID = glCreateProgram();glAttachShader(ID, vertex);glAttachShader(ID, fragment);glLinkProgram(ID);// print linking errors if anyglGetProgramiv(ID, GL_LINK_STATUS, &amp;amp;success);if(!success){glGetProgramInfoLog(ID, 512, NULL, infoLog);std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;}// delete the shaders as they&#39;re linked into our program now and no longer necessaryglDeleteShader(vertex);glDeleteShader(fragment);void use(){glUseProgram(ID);}void setBool(const std::string &amp;amp;name, bool value) const{ glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);}void setInt(const std::string &amp;amp;name, int value) const{glUniform1i(glGetUniformLocation(ID, name.c_str()), value);}void setFloat(const std::string &amp;amp;name, float value) const{glUniform1f(glGetUniformLocation(ID, name.c_str()), value);}shader class 사용Shader ourShader(&quot;path/to/shaders/shader.vs&quot;, &quot;path/to/shaders/shader.fs&quot;);[...]while(...){ ourShader.use(); ourShader.setFloat(&quot;someUniform&quot;, 1.0f); DrawStuff();} vertex/fragment shader 코드를 두개의 파일로 저장 .vs .fs 확장자가 직관적 attribute, uniform, varingstackoverflowtistory출처Shaders" }, { "title": "[learn-opengl] Triangle", "url": "/posts/2022/02/12/19/16/learn_opengl3/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-12 19:16:36 +0900", "snippet": "Shader그래픽스 파이프라인의 두가지 부분 3D -&amp;gt; 2D 2D -&amp;gt; 화소픽셀 대부분 vertex shader, fagment shader만 사용. Geometry shader는 선택적으로 사용 GPU에 기본 vertex/fragment shader 가 없음 =&amp;gt; 스스로 작성해야함 그래픽 파이프라인의 입력 : 3D 좌표 여러단계를 거침 각 단계는 전 단계의 결과를 입력으로. 모든 단계는 특성화됨 병렬로 실행됨 각 단계에서 GPU 위에 작은 프로그램들을 실행시킴 데이터를 빠르게 처리 (GPU의 수많은 작은 프로세싱 코어들) 이런 작은 프로그램들이 바로 shader쉐이더 존재하는 기본 쉐이더를 대체할 수 있음 설정가능한 쉐이더 : 파이프라인의 특정한 부분을 좀 더 세밀한 조작을 가능하게함. GPU 위에 실행 =&amp;gt; CPU 시간을 절약=&amp;gt; OpenGL Shading Language (GLSL)그래픽 파이프라인 많은 일을 하는것을 위 그림에서 볼 수 있음. 각 부분들은 정점 데이터를 완전히 렌더링된 픽셀로 변환하는 데, 각자 하나의 특정 부분을 관리. 삼각형 렌더링 그래픽 파이프라인의 입력 : 삼각형을 구성할 수 있는 정점 데이터 : 3개의 3D좌표리스트 정점(vertex) 3D 좌표에 대한 데이터의 집합 정점 속성(vertex attributes)를 사용하여 정점의 데이터 표현 이 속성은 모든 데이터를 포함할 수 있지만 대표적으로 3D 위치, 컬러값 OpenGL이 이런 집합을 만들기 위해, 어떤 종류의 렌더링 유형인 것인지 알려줘야함 이러한 힌트들을 primitives 라고함: GL_POINTS, GL_TRIANGLES, GL_LINE_STRIP vertex shader 파이프 라인의 첫번째 부분 하나의 정점을 입력으로 받는 정점 쉐이더(vertex shader) vertex 쉐이더의 주 목적 1 : 3D 좌표를 다른 3D 좌표로 변환하는것 vertex 쉐이더의 주 목적 2 : vertex 속성에 대한 기본적인 처리 primitive assembly 단계 primitive 를 구성 (primitive 도형의 모든 점들을 조립하는 vertex 쉐이더로부터) 입력 값 : 모든 정점들을 받는다. (GL_POINTS 같은 경우 하나의 정점) 결과 값 : geometry shader로 전달 geometry shader 입력값 : 정점들의 집합 이 정점들의 집합은 primitive를 구성하고, 새로운 정점을 생성하여 새로운 primitive를 형성, 다른 도형으로 변환 위 그림에선 삼각형한개를 두개로 생성 결과 값 : rasterization stage로 전달 rasterization stage 결과 primitive 를 최종 화면의 적절한 픽셀과 매핑 그 결과 fragment shader에서 사용할 fragment(조각)이 도출 fragment shader를 실행하기 전 clipping을 수행 clipping 성능을 증가시키기 위해 뷰 밖에 있는 모든 fragment들을 제거 OpenGL 에서 fragment는 하나의 픽셀을 렌더링 하기 위해 필요한 모든 데이터 fragment shader 목적: 픽셀의 최종 컬러를 계산하는것 advanced OpenGL effects 가 발생하는 단계 일반적으로 fragment shader는 3D scene에 대한 데이터를 가지고 있음 이 데이터를 가지고 최종 픽셀 컬러(광원, 그림자, 빛의 색 등)를 계산 alpha test and blending stage 최종 결과물의 마지막 단계 fragment의 해당 깊이(deepth and stencill) 값을 체크 최종 fragment가 다른 오브젝트보다 앞에 있는지 뒤에 있는지 체크 다른 오브젝트보다 뒤에 있는 fragment는 즉시 폐기. 이 단계에서 alpha값(오브젝트의 투명도)를 확인 그에 맞춰 다른 오브젝트와 blend fragment shader에서의 출력 색 과 최종 픽셀 컬러는 여러개의 삼각형을 렌더링할 때 완전히 다른 색이 될 수 있음 투상 파이프라인모델좌표| ---- 모델행렬전역좌표| ---- 뷰 행렬시점좌표| ---- 투상 행렬 =&amp;gt; 후면 제거절단좌표 (동차좌표계에서 절단)| ---- 원근분할정규화장치좌표(NDC)| ---- 뷰포트 변환 -&amp;gt; 정수화 glViewport화면좌표(뷰포트좌표)| ---- 래스터 변환 -&amp;gt; 은면제거 (깊이테이스) -&amp;gt; z값제거디스플레이Vertex 입력OpenGL : 3D 라이브러리 명시한 좌표는 3D 공간의 좌표 모든 3D 좌표가 (x, y, z) 에서 값이 -1.0 와 1.0 사이에 있어야 처리(normalized device coordinates 범위) 삼각형 3개의 정점 명시 normalized device coordinates 범위, float 배열 로 z = 0.0 으로 설정, 2D처럼 보이도록 depth를 같게 float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f};NDC(Normalized Device Corrdinates) vertex coordinates 가 vertex shader에서 처리되고나면 정점들이 NDC 공간으로 변환 각 범위는 모두 -1.0 ~ 1.0 이 범위 밖의 점은 버려짐 뷰포트 변환을 통해 screen-space coordinates 로 변환 screen-space coordinates 는 fragment로 변환되어 fragment shader의 입력값으로 전달vertex shader GPU에 정점 데이터를 저장할 공간의 메모리를 할당. OpenGL이 어떻게 메모리를 해석할 것인지 구성 데이터를 어떻게 그래픽 카드에 전달할 것인지에 대해 명시 작업 완료한 다음 정점들을 전달한 만큼 메모리에서 처리 VBO(vertex buffer objects) 정점들을 처리하는 메모리를 관리 많은 양의 정점들을 GPU 메모리상에 저장할 수 있음 대량의 데이터를 한꺼번에 GPU로 전송 CPU &amp;lt;-&amp;gt; GPU : 느리기 때문에 가능한 많이 보내야함 데이터가 그래픽 카드 메모리에 할당되면 vertex shader는 빠르게 정점들에 접근 가능 OpenGL의 객체로, 이 버퍼도 고유한 ID를 가짐, 버퍼 ID를 생성할 수 있다. glGenBuffer(GLsizei size, GLuint* buffers)unsigned int VBO;glGenBuffers(1, &amp;amp;VBO);GLuint vbos[5];glGenBuffers(5, vbos);OpenGL에는 많은 타입의 버퍼 객체가 있음 VBO 의 버퍼 타입은 GL_ARRAY_BUFFER 다른 버퍼 타입 또한 bind 할 수 있다. 새롭게 생성된 버퍼를 glBindBuffer 함수를 사용하여 GL_ARRAY_BUFFER로 바인딩 할 수 있음 glBindBuffer(GL_ARRAY_BUFFER, VBO); 이후부터 호출되는 GL_ARRAY_BUFFER를 타겟으로하는 모든 버퍼는 현재 바인딩 된 버퍼(VBO)를 사용하게됨glBufferData 함수 미리 정의된 정점 데이터를 버퍼의 메모리에 복사glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); 사용자가 정의한 데이터를 현재 바인딩된 버퍼에 복사. 첫번째 파라미터 : 데이터를 집어넣을 버퍼의 유형(현재 바인딩된 vbo) 두번째 파라미터 : 버퍼에 저장할 데이터의 크기 (바이트 단위. size of) 세번째 파라미터 : 보낼 실제 데이터 네번째 파라미터 : 그래픽 카드가 주어진 데이터를 관리하는 방법 GL_STATIC_DRAW: 데이터가 거의 변하지 않음 (현재 예제에선 적절) GL_DYNAMIC_DRAW: 데이터가 자주 변경됩니다. GL_STREAM_DRAW: 데이터가 그려질때마다 변경됩니다. 2, 3 번일 경우, 그래픽 카드가 빠르게 쓸 수 있는 메모리에 데이터를 저장 정점데이터를 메모리에 저장 완료 : 이 메모리는 VBO가 관리, vertex/fragment shader가 처리 Vertex shader 프로그래밍 할 수 있는 shader 중 하나 GLSL 를 통해 vertex shader를 작성, 컴파일, 응용프로그램에서 사용 아래는 기초적인 vertex shader 코드이다. #version 330 corelayout (location = 0) in vec3 aPos;void main(){ gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);} glsl는 c 와 유사함.#version 330 core 처음으로 버전 선언, OpenGL3.3 이상 부터, glsl 버전과 OpenGL과 맞아야함. (ex, 4.2 == 420) core profile 기능 사용 명시 in vec3 aPos; in 키워드 : 모든 입력 정점 속성을 선언 현재는 위치 데이터만 사용, 오직 하나의 정점 속성만 필요 vector 타입 은 1~4개의 실수, 각 정점은 3차원이기 때문에 vec3 타입 생성 layout (location = 0) 입력 변수의 location을 설정vector glsl의 벡터는 최대 크기가 4 vec.x, vec.y, vec.z , vec.w 로 접근 w : perspective division : 원근 분할 : 동차 좌표계에서 사용 gl_Position 출력값 설정하기위해 미리 선언된(predefined) gl_Position 변수에 위치 데이터를 할당 vec4 타입이므로 형변환, w 값을 1.0으로 설정 현재 shader는 가장 간단한것: 입력데이터에 대해 처리 x, 간단히 출력값으로 전달, 먼저 입력데이터를 OpenGL의 표시할 수 있는 영역 내에 있는 좌표로 변환해야함Compiling a shader 세이더 소스코드를 const char 로 저장.const char *vertexShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) in vec3 aPos;\\n&quot; &quot;void main()\\n&quot; &quot;{\\n&quot; &quot; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot; &quot;}\\0&quot;;glCreateShader OpenGL이 shader를 사용하려면, 런타임시에 소스코드를 동적으로 컴파일해야함 ID를 참조하여 shader 객체를 생성해야함. 그러기 위해선 unsigned int 타입으로 세이더를 저장해야하고, glCreateShader함수로 생성해야함. (에러시 0리턴) unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER); glCreateShader함수의 파라미터로 shader의 유형 입력 : GL_VERTEX_SHADERglShaderSourceglShaderSource(vertexShader, 1, &amp;amp;vertexShaderSource, NULL);glCompileShader(vertexShader); 그리고 소스코드를 객체에 첨부, shader를 컴파일 glShaderSource 함수는 shader 소스를 객체에 바인딩함. 첫번째 파라미터(shader): shader 객체 두번째 파라미터(count): 소스코드가 몇개의 문자열인지 (string array의 크기) 세번째 파라미터(string): vertex shader의 실제 코드 네번째 파라미터(length): an array of string lengths glCompileShader 함수 컴파일이 성공적으로 완료됬는지, 어떤 오류가 발생했는지 아래 함수들을 사용하면 알 수 있음 getShaderiv : 컴파일의 성공 유무 getGetShaderInfoLog : 에러메시지 확인, int success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;amp;success);if(!success){ glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &amp;lt;&amp;lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &amp;lt;&amp;lt; infoLog &amp;lt;&amp;lt; std::endl;}Fragment shader 삼각형을 렌더링하기위해 생성해야할 쉐이더 픽셀의 출력 컬러값을 계산하는 것에 관한 쉐이더. 컬러값 = RGBA 의 리스트 각 값들의 범위 0.0 ~ 1.0 주어진 3개의 색으로 1600만개 이상의 색을 만들 수 있음. #version 330 coreout vec4 FragColor;void main(){ FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);} 오직 하나의 출력 변수 크기가 4인 벡터 최종 컬러를 정의 out 키워드 출력값 선언compile 컴파일은 vertex와 비슷. GL_FRAGMENT_SHADER로 설정하면됨unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader);Shader Program 여러 shader를 결합한 마지막 연결된 버전 컴파일된 shader들을 shader program 객체로 연결(link) 객체를 렌더링할때 이 shader program을 활성화 하면됨. 활성화된 shader program 안의 shader 들은 렌더링 명령이 호출될 때 사용됨 입력정점 데이터을 GPU한테 보내고, 어떻게 처리해야하는지 vertex 와 fragment 를 통해 명령해야함. 연결 한 세이더의 출력값을 다음 세이더의 입력값으로 연결 출력과 입력이 일치하지 않으면 linking error 발생 Program 객체 생성unsigned int shaderProgram;shaderProgram = glCreateProgram(); glCreateProgram 함수 : program을 생성, 생성된 객체의 ID를 리턴 glAttachShader 함수 : shader를 program 객체에 붙임. glLinkProgram 사용하여 연결 glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);연결여부확인glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;amp;success);if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); ...}link 결과 결과는 glUseProgram 함수를 호출하여 활성화할 수 있는 program 객체이다.glUseProgram(shaderProgram);glUseProgram 함수를 호출한 이후의 모든 shader와 렌더링 명령은이 객체를 통해 내부의 세이더들을 사용하게됨shader들을 program객체로 연결하고나면, shader 객체들을 제거해야함glDeleteShader(vertexShader);glDeleteShader(fragmentShader);Linking Vertex Attributes OpenGL은 메모리 상의 정점 데이터를 어떻게 해석해야하는지 아직 모름 정점데이터를 vertex shader의 속성들과 어떻게 연결해야하는지 모름 OpenGL한테 알려줘야함 vertex vertex shader 는 원하는 모든 입력들을 정점 속성의 형식으로 지정할 수 있도록해줌. 유연성이 좋은 반면, 입력 데이터의 어느 부분이 vertex shader의 어떠한 정점 속성과 맞는지 직접 지정해야함 삼각형의 3점 : float vertices[3] position data 는 32-비트(4 바이트)의 floating point values. 각 position 은 3가지값으로 구성됨 각 3개 값의 집합들은 tightly packed array임.(연속적, 공백이 없음) 데이터의 첫 번재 값은 버퍼의 시작지점에 있음. glVertexAttribPointer함수glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); 위의 정보들과 함께 OpenGL에게 vertex 데이터(vertex 속성)를 어떻게 해석해야하는지를 알려줄 수 있다. 파라미터 1 : vertex attribute, vertex shader code 에서 layout (location = 0) 코드를 사용하여 속성위치 지정, vertex 속성의 위치(location)을 0으로 설정하고, 데이터를 vertex 속성에 전달 파라미터 2 : vertex 속성의 크기를 지정, 이 vertex 속성은 vec3 타입, 따라서 3개의 값 파라미터 3 : 데이터의 타입, (glsl에서 vec* 은 실수형) 파라미터 4 : 데이터를 정규화할 것인지?, TRUE일 때 int, byte type 이면 =&amp;gt; 값을 0(signed : -1) ~ 1 범위의 float 값으로 변환. 파라미터 5 : stride, 연속적인 vertex 속성의 크기를 알려줘야함. xyz 로 3개의 float 뒤에 다음 속성이 있음을 알려줌. 만약 값들이 빽빽하게 저장되어있으면 0으로 지정. 파라미터 6 : void* 타입, 형변환이 필요. 이는 버퍼에서 데이터가 시작하는 위치의 offset, 시작부분에 있으면 0으로지정 각 vertex 속성은 VBO에 의해 관리되는 메모리로부터 데이터를 받는다. 데이터를 받을 VBO (여러 VBO를 가질 수 있음)는 glVertexAttribPointer 함수를 호출할때 GL_ARRAY_BUFFER에 현재 바인딩된 VBO로 결정됨, glVertexAttribPointer 함수가 호출하기전에 미리 정의된 VBO가 바인딩되어있으므로 vertex 속성 0 이 해당하는 vertex 데이터와 연결된다.glEnableVertexAttribArray 함수 vertex 속성 location을 전달하고 호출, vertex 속성을 사용할 수 있도록함 vertex 속성의 default : disabled draw vertex buffer 객체를 사용하여 vertex 데이터를 초기화, vertex shader 와 fragment shader 설정 OpenGL에게 vertex 데이터가 vertex shader의 vertex 속성에 연결하면 모든 설정이 끝난다. // 0. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 1. then set the vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 2. use our shader program when we want to render an objectglUseProgram(shaderProgram);// 3. now draw the objectsomeOpenGLFunctionThatDrawsOurTriangle(); 객체를 그려야할 때마다 이 과정을 반복해야함 굉장히 번거로운 과정이기 때문에 이 객체를 바인딩하여 상태를 저장하는게 VAO Vertex Array ObjectVAO (Vertex Array Object) vbo와 같이 바인딩될 수 있으며, vertex 속성 호출은 VAO에 저장됨. vertex 속성 포인터를 구성할 때 오직 한 번 호출하기만 하면 되고 오브젝트를 그려야 할 때마다 해당 VAO를 바인딩하면 된다는 장점을 가짐. 서로 다른 vertex 데이터와 속성들을 다른 VAO를 바인딩함으로써 손쉽게 교체할 수 있음 설정한 모든 상태가 VAO 내부에 저장됨. Core OpenGL 정점 입력과 관련하여 VAO를 사용하도록 요구. VAO를 바인딩하는데에 실패한다면 OpenGL은 어떤것이든 그리기를 거부할 수 도있음. Vertex array object는 다음 항목을 저장함 glEnableVertexAttribArray 함수나 glDisableVertexAttribArray 함수의 호출 glVertexAttribPointer 함수를 통한 Vertex 속성의 구성 glVertexAttribPointer 함수를 통해 vertex 속성과 연결된 Vertex buffer objects(VBOs) 생성VAO를 생성하는 과정 == VBO와 비슷한 과정unsigned int VAO;glGenVertexArrays(1, &amp;amp;VAO);glBindVertexArray VAO를 바인딩 그 후 부터 해당 VBO와 속성 포인터를 바인딩하여 구성하고 VAO를 나중에 사용하기 위해 언바인딩해야함. 오브젝트를 그리려면 간단히 원하는 세팅과 함께 VAO를 바인딩하면됨. // ..:: Initialization code (done once (unless your object frequently changes)) :: ..// 1. bind Vertex Array ObjectglBindVertexArray(VAO);// 2. copy our vertices array in a buffer for OpenGL to useglBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. then set our vertex attributes pointersglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);[...]// ..:: Drawing code (in render loop) :: ..// 4. draw the objectglUseProgram(shaderProgram);glBindVertexArray(VAO);someOpenGLFunctionThatDrawsOurTriangle();VAO vertex 속성 구성을 저장 처음에 VAO(and thus the required VBO, attribute pointers)를 생성하고 설정 그리고 그것들을 나중에 사용하기위해 저장 오브젝트들 중에 하나를 그리고싶으면, 해당 VAO를 가지고와 바인딩 오브젝트를 그린 후 VAO를 언바인딩해야한다. (VAO와 VBO를 언바인딩) unsigned int VBO, VAO; glGenVertexArrays(1, &amp;amp;VAO); glGenBuffers(1, &amp;amp;VBO); // bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#39;s bound vertex buffer object so afterwards we can safely unbind glBindBuffer(GL_ARRAY_BUFFER, 0); // You can unbind the VAO afterwards so other VAO calls won&#39;t accidentally modify this VAO, but this rarely happens. Modifying other // VAOs requires a call to glBindVertexArray anyways so we generally don&#39;t unbind VAOs (nor VBOs) when it&#39;s not directly necessary. glBindVertexArray(0);삼각형 그리기 OpenGL은 glDrawArrays 함수를 제공해줌. 현재 활성화된 shader, 이전에 정의된 vertex 속성구성, VBO의 vertex 데이터(VAO를 통해 간접적으로 바인딩된)들을 사용하여 primitives 를 그린다. glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3);glDrawArrays 함수 파라미터 1 : primitive 타입 : GL_TRIANGLES 파라미터 2 : vertex 배열의 시작 인덱스 파라미터 3 : 몇개의 vertex를 그리는지 전체 코드Element Buffer Objects(abbreviated to EBO) 정점들을 렌더링할 때 생각해야하는 것사각형 2개의 삼각형을 사용하여 사각형을 그릴 수 있음 (OpenGL 면의 최소단위는 삼각형) 다음과 같은 정점들로 생성할 수 있음 float vertices[] = { // first triangle 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, 0.5f, 0.0f, // top left // second triangle 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left};EBO가 필요한 이유 정점을 명시하는데 중복되는것이 생김 (bottom right and top Left) 오버헤드가 50% 발생 4개의 정점만 저장하는 대신, 그리는 순서를 지정해야함 EBO VBO 와 같은 버퍼 어떠한 정점들을 그려야할 지 결정할 수 있는 인덱스들을 저장 indexed drawing이라고 불리는 문제 해결방법임. float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left};unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first triangle 1, 2, 3 // second triangle}; EBO 버퍼를 생성해야함unsigned int EBO;glGenBuffers(1, &amp;amp;EBO); VBO와 유사하게 glBufferData 사용하여 데이터 복사 : bind 와 unbind 사이에 설정해줘야함. 버퍼 타입 주의 : GL_ELEMENT_ARRAY_BUFFER glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); GL_ELEMENT_ARRAY_BUFFER를 타겟으로 지정하고, 바인딩하여 glDrawElements 함수를 사용하여 그림을 그림.glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 파라미터 2 : 최종적으로 6개의 정점을 그려야하기때문에 6 파라미터 3 : 인덱스의 타입 파라마터 4 : offset glDrawElements GL_ELEMENT_ARRAY_BUFFER 를 타겟으로 현재 바인딩 된 EBO로 부터 인덱스를 가져옴 해당 EBO를 렌더링 할 때마다 바인딩해야한다는것을 의미 VAO VAO 는 하지만 EBO 또한 저장함. VAO가 바인딩 되어있는 동안 EBO가 바인딩되면 VAO버퍼객체로 저장됨 VAO가 바인딩하면 자동으로 내부에 있는 EBO도 바인딩 타겟이 GL_ELEMENT_ARRAY_BUFFER 일 때의 glBindBuffer 함수호출 또한 저장, 언바인드 호출 또한 저장하기때문에 EBO 보다 VAO를 먼저 언바인드해야한다Wireframe mode glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) primitive 를 어떻게 그릴것인지 파라미터 1 : 후면과 전면 중 적용할것 선택 파라미터 2 : GL_LINE = 선으로 그리기 , GL_FILL = 채워서 그리기 출처LearnOpenGL - Hello Triangle" }, { "title": "[learn-opengl] Creating a window", "url": "/posts/2022/02/12/15/09/learn_opengl2/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-12 15:09:15 +0900", "snippet": "1. window 생성헤더 파일#include &amp;lt;iostream&amp;gt;#include &amp;lt;glad/glad.h&amp;gt;#include &amp;lt;GLFW/glfw3.h&amp;gt;GLFW 초기화, 설정메인 함수에서glfwInit 로 GLFW 초기화glfwWindowHint로 GLFW설정 : GLFW_ 접두어의 옵션들GLFW_CONTEXT_VERSION_MINORGLFW_CONTEXT_VERSION_MAJOR 을 3으로 설정한것은 opengl3.3 을 다루고있기 때문 적절한 OpenGL 버전이 아닐시 GLFW 실행되지않음glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 명시적으로 core-profile을 사용 glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);=&amp;gt; Mac OSint main(){ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); return 0;}윈도우 객체 생성GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL);if (window == NULL){ std::cout &amp;lt;&amp;lt; &quot;Failed to create GLFW window&quot; &amp;lt;&amp;lt; std::endl; glfwTerminate(); return -1;}glfwMakeContextCurrent(window);이 객체는 모든 window 데이터를 유지, GLFW의 다른 함수에서 사용하는 데이터이다.glfwCreateWindow(width , height , name, monitor, share)monitor : 풀스크린모드 or 윈도우모드(NULL)share : 자원을 다른 창과 공유하는지glfwMakeContextCurrent(window)glfw에게 현재 window context를 current thread에 main context로 삼음GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &amp;lt;&amp;lt; &quot;Failed to initialize GLAD&quot; &amp;lt;&amp;lt; std::endl; return -1; }OpenGL의 function pointer 들을 관리하는 GLAD를 초기화OpenGL 함수들을 호출하기 전에 초기화 해야함OS 마다 다른 OpenGL함수 포인터의 주소를 로드하기 위해 GLAD 함수를 거침.GLFW는 OS에 따라 the correct function 을 정의하는 주소를 제공해줌.Viewport glViewport(0, 0, 800, 600);렌더링을 하기전OPENGL에게 렌더링 윈도우 사이즈를 알려줘야함.(x, y, width, height)(왼쪽 모서리 좌표, 렌더링 윈도우의 너비와 높이를 픽셀로 설정) 뷰포트와 (가시부피)투상면의 종횡비가 일치해야함. (왜곡 방지) 창의 크기 조절할때마다 뷰포트도 조정 void framebuffer_size_callback(GLFWwindow * window, int width, int height); void framebuffer_size_callback(GLFWwindow* window, int width, int height){ glViewport(0, 0, width, height);}resize 콜백함수를 등록해야함. 창의 크기가 변경될 때마다 GLFW는 이 함수를 호출, 뷰포트 리사이즈 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);창을 처음 표시할때도 호출됨.창크기 조절할때도 호출됨. 레티나 디스플레이는 width와 height의 값이 원래 입력값보다 훨씬 높아짐Ready your Enginewhile(!glfwWindowShouldClose(window)){ glfwSwapBuffers(window); glfwPollEvents();}프로그램이 명시적으로 중지하라는 메시지를 받기전까지 계속해서 이미지들을 그리고입력들을 처리하도록해야함 render loop 라는 while 루프를 만들어야함. GLFW에게 그만하라고 할때까지 계속 실행됨.close 함수 각 루프가 시작될 때마다 GLFW가 종료하도록 지시받았는지 확인함swapBuffers 함수 컬러버퍼(GLFW 창 안의 각 픽셀들에 대한 컬러값을 가지고 있는 큰 버퍼)를 교체 반복중에 이미지를 그리고 화면에 출력하는 기능을 함. PollEvent 함수 이벤트가 발생했는지 확인, 윈도우 상태 업데이트, 콜백함수 호출더블버퍼=&amp;gt; single 버퍼의 문제점 (이미지 플리커링) goth=&amp;gt; front : 최종 출력이미지를 담음=&amp;gt; back : 모든 렌더링 명령이 그려지는 버퍼=&amp;gt; 모든 렌더링 명령이 완료되면 swap =&amp;gt; 즉시표시종료glfwTerminate();return 0;할당된 모든 자원들을 정리, 삭제2. inputvoid processInput(GLFWwindow *window){ if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);} while (!glfwWindowShouldClose(window)) { processInput(window); glfwSwapBuffers(window); glfwPollEvents(); }glfwGetKey 함수를 사용하여 키보드 키와 함께 윈도우의 입력을 받을 수 있음.(눌러져 있는지 여부를 리턴)=&amp;gt; 함수를 만들어 체계적으로 코드를 구성할 수 있음render loop=&amp;gt; 모든 프레임에서 특정 키가 눌러져 있음을 확인 할 수 있다.3. Rendering// render loopwhile(!glfwWindowShouldClose(window)){ // input processInput(window); // rendering commands here ... // check and call events and swap the buffers glfwPollEvents(); glfwSwapBuffers(window);}모든 렌더링 명령을 렌더링 루프 안에 넣어야한다.ex)glClear (상태 사용, state-using)==&amp;gt; GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT=&amp;gt; 버퍼를 초기화glClearColor (상태 설정, state-setting)=&amp;gt; 초기화할 색 샐정glClearColor(0.2f, 0.3f, 0.3f, 1.0f);glClear(GL_COLOR_BUFFER_BIT);전체 코드#include &amp;lt;iostream&amp;gt;#include &amp;lt;glad/glad.h&amp;gt;#include &amp;lt;GLFW/glfw3.h&amp;gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height);void processInput(GLFWwindow *window);int main(){ glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == NULL) { std::cout &amp;lt;&amp;lt; &quot;Failed to create GLFW window&quot; &amp;lt;&amp;lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &amp;lt;&amp;lt; &quot;Failed to initialize GLAD&quot; &amp;lt;&amp;lt; std::endl; return -1; } glViewport(0, 0, 800, 600); glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); while (!glfwWindowShouldClose(window)) { processInput(window); glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); return 0;}void framebuffer_size_callback(GLFWwindow* window, int width, int height){ glViewport(0, 0, width, height);}void processInput(GLFWwindow *window){ if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true);}출처LearnOpenGL - Hello WindowLearnOpenGL - Hello Triangle" }, { "title": "[learn-opengl] Introduction: OpenGL", "url": "/posts/2022/02/12/14/20/learn_opengl1/", "categories": "graphics, graphics-opengl", "tags": "opengl", "date": "2022-02-12 14:20:38 +0900", "snippet": "1. OpenGLimmediate mode (fixed function pipeline) 예전에 쓰였던 방식 대부분 기능이 내부에 숨겨져있음, 내부에서 작동확인 어려움 그대신 사용하기 쉽고 이해하기 쉬움 그러나 비효율적 OpenGL 3.2 이후 core-profile mode core-profile mode 최신 기술(modern practices)을 사용하도록 유도 (deprecated functions 사용시 정지) 따라서 배우기 어려움. 하지만 매우 유연하고 효율적 내부에서의 동작을 확인하기 쉬워짐 OpenGL 3.3버전 을 배우는 이유 :이후버전은 기능이 추가되거나 함수가 더 효율적으로 바뀐것.2. Extensions 그래픽 카드 회사에서 렌더링을 위해 새로운 기술을 개발하거나 최적화 작업을 한것을 사용가능하거나 안하게 할 수 있음. (하드웨어에 맞게 주어진 기능을 활성화하는 Functional Mode 이야기인거 같음) if(GL_ARB_extension_name){ // Do cool new and modern stuff supported by hardware}else{ // Extension not supported: do it the old way}3. State MachineOpenGL은 커다란 상태 머신(상태변수 설정하는 역할, 하드웨어가 불가능함)상태 변수 == context상태, 옵션을 설정하고 버퍼를 조작한다음current context(현 상태)를 변경해야함(상태 = 점의 크기, 색, 길이 등등)(현상태는 변경하기전 까지 계속 유지)4. Objectscore 는 C 라이브러리,추상화를 고려하여 개발된 OpenGL추상화중 하나인객체는 상태를 나타내는 옵션들의 모음 객체를 생성하고, 레퍼런스를 id 로 저장 (실제 데이터는 scenes 뒤에 저장) 객체를 id를 이용하여, context의 대상 위치에 바인딩 옵션을 설정 바인딩 해제 -&amp;gt; id가 참조하는객체에 옵션은 저장됨, context의 대상 위치는 복원됨) 여러 객체를 정의하고 옵션을 설정할 수 있음, 특정 모델을 그리려 할때마다 해당 옵션을 다시 설정하지 않아도 저장된 옵션이 설정됨, 해당 객체를 바인딩만 하면됨.struct object_name { float option1; int option2; char[] name;};// The State of OpenGLstruct OpenGL_Context { ... object_name* object_Window_Target; ...};// create objectunsigned int objectId = 0;glGenObject(1, &amp;amp;objectId);// bind/assign object to contextglBindObject(GL_WINDOW_TARGET, objectId);// set options of object currently bound to GL_WINDOW_TARGETglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);// set context target back to defaultglBindObject(GL_WINDOW_TARGET, 0);출처LearnOpenGL - IntroductionLearnOpenGL - OpenGL" }, { "title": "[백준][C++] 5427: 불 (bfs)", "url": "/posts/2022/01/05/19/25/5427/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-01-05 19:25:18 +0900", "snippet": "문제5427풀이 전형적인 bfs 문제이지만 처리해야할게 하나 더 있다. 탈출하려는 사람이 먼저 움직여야 한다는 것이다. (아니면 가장 마지막에) 그 이유는 다음과 같다. 현재 상태에서 불이 이동하는 위치는 현재 사람의 위치에 올 수 있다. 그래도 현재 사람은 이동할 수 있다. 불이 먼저 이동하면, 아무런 검사를 하지 않아도 된다. 사람이 먼저 이동하면, 다음 상태에서 불이 붙었는지 검사해야한다. (이동한 위치에 불도 그 위치에 옮겨 붙음) 중간에 끼어서 이동하면, 먼저 움직인 불은 신경쓰지 않아도 되지만, 후에 움직인 불은 신경써야한다. 그렇기 때문에 이를 처리하는 코드를 추가해야하며, 이를 구별하기는 까다롭다. (만약 사람이 있는 타일에 불이 붙으면, 먼저움직인 불은 제외하고 후에 움직인 불을 처리해야함) 그렇기 때문에 deque로 사람을 앞에 추가하였다.코드int dx[4] = {1, -1, 0, 0};int dy[4] = {0, 0, 1, -1};deque&amp;lt;tuple&amp;lt;int, int, int, char&amp;gt; &amp;gt; q; int r, c;char board[1001][1001];int bfs() { while(!q.empty()){ auto [y, x, day, what] = q.front(); q.pop_front(); for(int i = 0; i &amp;lt; 4; i++) { int yy = y + dy[i]; int xx = x + dx[i]; if(what == &#39;@&#39;&amp;amp;&amp;amp;board[y][x] == &#39;*&#39;) { continue; } if(yy &amp;lt; 0|| yy &amp;gt;= r|| xx &amp;lt; 0|| xx &amp;gt;=c) { if(what == &#39;@&#39;) { return day + 1; } continue; } if(board[yy][xx] == &#39;.&#39; ||(board[yy][xx] ==&#39;@&#39; &amp;amp;&amp;amp; what == &#39;*&#39;)) { board[yy][xx] = what; q.push_back({yy, xx, day+1, what}); } } } return -1;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T; cin &amp;gt;&amp;gt; T; while (T--) { cin&amp;gt;&amp;gt;c&amp;gt;&amp;gt;r; q.clear(); for(int i = 0; i &amp;lt; r; i++) { for(int j = 0; j &amp;lt; c; j++) { cin&amp;gt;&amp;gt;board[i][j]; if(board[i][j] == &#39;*&#39;) { q.push_back({i, j, 0, &#39;*&#39;}); } if (board[i][j] ==&#39;@&#39;){ q.push_front({i, j, 0, &#39;@&#39;}); } } } int answer = bfs(); if(answer == -1) { cout&amp;lt;&amp;lt;&quot;IMPOSSIBLE\\n&quot;; } else { cout&amp;lt;&amp;lt;answer&amp;lt;&amp;lt;&quot;\\n&quot;; } }} 아래는 사람을 나중에 이동시킨 것이다.deque&amp;lt;tuple&amp;lt;int, int, int, char&amp;gt; &amp;gt; q; int r, c;char board[1001][1001];int bfs() { while(!q.empty()){ auto [y, x, day, what] = q.front(); q.pop_front(); for(int i = 0; i &amp;lt; 4; i++) { int yy = y + dy[i]; int xx = x + dx[i]; if(yy &amp;lt; 0|| yy &amp;gt;= r|| xx &amp;lt; 0|| xx &amp;gt;=c) { if(what == &#39;@&#39;) { return day + 1; } continue; } if(board[yy][xx] == &#39;.&#39; ||(board[yy][xx] ==&#39;@&#39; &amp;amp;&amp;amp; what == &#39;*&#39;)) { board[yy][xx] = what; q.push_back({yy, xx, day+1, what}); } } } return -1;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int T; cin &amp;gt;&amp;gt; T; while (T--) { cin&amp;gt;&amp;gt;c&amp;gt;&amp;gt;r; q.clear(); for(int i = 0; i &amp;lt; r; i++) { for(int j = 0; j &amp;lt; c; j++) { cin&amp;gt;&amp;gt;board[i][j]; if(board[i][j] == &#39;*&#39;) { q.push_front({i, j, 0, &#39;*&#39;}); } if (board[i][j] ==&#39;@&#39;){ q.push_back({i, j, 0, &#39;@&#39;}); } } } int answer = bfs(); if(answer == -1) { cout&amp;lt;&amp;lt;&quot;IMPOSSIBLE\\n&quot;; } else { cout&amp;lt;&amp;lt;answer&amp;lt;&amp;lt;&quot;\\n&quot;; } }}" }, { "title": "[csapp]챕터1 컴퓨터 시스템으로의 여행", "url": "/posts/2022/01/05/05/20/csapp/", "categories": "cs, cs-csapp", "tags": "csapp", "date": "2022-01-05 05:20:32 +0900", "snippet": "챕터1 컴퓨터 시스템으로의 여행 (컴퓨터 시스템 = 하드웨어 + 시스템 소프트웨어) =&amp;gt; 응용프로그램 실행 버퍼 오버플로우 위험성으로부터 시스템을 보호해야함 링커 과정에서 발생하는 심각한 에러를 이해하고 회피하는 방법을 알아야함 + 유닉스 쉘, 동적 메모리 할당 패키지, 웹 서버 작성, 동시성의 가능성과 위험성 프로세서: 메인 메모리에 저장된 바이너리 인스트럭션을 읽고 해석 컴퓨터가 대부분의 시간을 메모리, 입출력장치, CPU레지스터 간에 데이터를 복사하는 데 쓰고 있으므로, 저장장치들은 계층구조로 순차적으로 위치시킴 계층구조의 상부는 하부를 위한 캐시 역할 운영체제의 커널은 응용프로그램과 하드웨어 사이에서 중간다리 역할, 운영체제는 세 가지 근본적인 추상화를 제공 파일 &amp;lt;=&amp;gt; 입출력장치 가상메모리 &amp;lt;=&amp;gt; 메인 메모리와 디스크 프로세스 &amp;lt;=&amp;gt; 프로세서, 메인 메모리, 입출력 장치 네트워크: 컴퓨터 시스템이 서로 통신하는 방법 제공, 특정 시스템 관점으로는 네트워크 또한 하나의 입출력 장치정보는 비트와 컨텍스트로 이루어진다 텍스트 파일 : 오로지 아스키 문자들로만 이루어진 파일 바이너리 파일 : 텍스트 파일이 아닌 모든 파일프로그램은 다른 프로그램에 의해 다른 형태로 번역된다 (전처리기 + 컴파일러 + 어셈블러 + 링커) = 컴파일 시스템 전처리 단계: C프로그램 수정(# 디렉티브) =&amp;gt; .i 컴파일 단계: .i =&amp;gt; .s (어셈블리어) 어셈블리 단계: 어셈블러가 .s =&amp;gt; 기계어 인스트럭션 =&amp;gt; 재배치가능 목적프로그램의 형태로 묶어서 .o라는 목적파일에 그 결과를 저장한다. 링크단계: 함수는 이미 컴파일된 별도의 목적파일에 들어있음. 이 파일과 다른 목적파일과 결합하기위해 링커 프로그램(ld)이 통합작업. =&amp;gt; 결과파일은 실행파일로 메모리에 적재 =&amp;gt; 시스템에 의해 실행컴파일 시스템이 어떻게 동작하는지 이해왜? 프로그램 성능 최적화: 프로그램 작성 시 올바른 판단 + 오버헤드 파악 링크 에러 이해: 큰 규모의 시스템의 경우 복잡하다.(정적 변수와 전역변수 차이?, 정적 라이브러리와 동적 라이브러리 차이? 컴파일 명령 라이브러리들 순서?), 링커 에러들은 실행하기 전까지는 나타나지 않음 보안 약점 피하기: 오버플로우 취약성, 비신뢰 데이터 제한 필요성, 스택 이해프로세서는 메모리에 저장된 인스트럭션을 읽고 해석시스템의 하드웨어 조직 버스: 시스템 내를 관통하는 배선, 컴포넌트 간 바이트 정보 전송, word(워드)라는 고정 크기의 바이트 단위로 데이터 전송 word의 바이트 수: 기본 시스템 변수(32, 64비트) 입출력 장치: 시스템과 외부세계와의 연결 담당, 입출력 버스와 컨트롤러나 어댑터를 통해 연결됨(키보드, 마우스, 디스플레이, 디스크 드라이브) 컨트롤러: 디바이스 자체가 칩셋 or 머더보드 어댑터: 머더보드의 슬롯에 장착된 카드 메인 메모리: 프로세서가 프로그램을 실행하는 동안 데이터 + 프로그램을 모두 저장하는 임시 저장 장치 DRAM칩들로 구성 논리적으로 메모리는 연속적인 바이트들의 배열, 고유의 주소를 가짐 프로세서: CPU 또는 프로세서는 메인 메모리에 저장된 인스트럭션들을 실행하는 엔진, 그 중심에는 PC(program counter) PC: 어느 한순간에 메인 메모리의 기계어 인스트럭션을 가리킴 프로세서 전원이 끊어질 때까지 프로세서는 PC가 가리키는 인스트럭션을 반복적으로 실행, PC 업데이트 자신의 Instruction set architecture로 정의되는 인스트럭션 실행 모델을 따라 작동 이 모델에서 인스트럭션은 규칙적인 순서로 실행 여러 단계에 걸쳐 실행 연속적으로 실행되는 인스트럭션들은 메모리상에서 연속적이지 않을 수 있다. ALU(수식/논리 처리기)주위를 순환하는 동작들 프로세서의 마이크로 구조와 인스트럭션 집합 구조를 구별프로그램 실행 쉘 프로그램 =&amp;gt; 자신의 인스트럭션 실행 =&amp;gt; 명령 입력 대기 =&amp;gt; “.\\program” 입력 =&amp;gt; 레지스터에 읽어 들임 =&amp;gt; 메모리 저장 직접 메모리 접근(DMA) 기법을 이용하여 데이터는 프로세서를 거치지 않고 디스크에서 메인 메모리로 직접 이동캐시의 중요성 시스템은 정보를 다른 곳으로 이동시키는 일이 많음 이러한 이동, 즉 복사는 느리게 하는 오버헤드 물리학 법칙 =&amp;gt; 더 큰 저장장치들은 작은거 보다 더 느림 더 빠른게 만들려면 비싸짐 프로세서-메모리 간 격차가 지속적으로 증가 메인 메모리 개발비용 &amp;gt; cpu 개발비용캐시 프로세서와 메모리의 격차 대응 단기간에 필요할 정보 저장 L1 캐시: 대략 수천 바이트 L2 캐시: 조금 더 큼, 수백 킬로바이트~ 수 메가 바이트, 전용 버스로 연결 L1,L2: SRAM (static randoam access memory) 지엽적인 영역의 코드와 데이터를 접근하는 경향인 지역성을 활용한 아이디어저장장치들은 계층구조를 이룸 밑으로 갈 수 록 느리고 크고 싸다 레지스터 파일은 L0 아이디어: 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할운영체제는 하드웨어를 관리 os가 제공하는 서비스를 활용 하드웨어와 소프트웨어 사이에 위치한 소프트웨어 계층 os의 목적: 하드웨어의 잘못된 사용 차단, 응용프로그램들이 단순하고 균일한 메커니즘을 사용하여 저수준 hw 조작 기능프로세스: context switching 실행 중인 프로그램에 대한 운영체제의 추상화 다수의 프로세스들은 동일한 시스템에서 동시에 실행될 수 있다. 즉, 한 프로세스의 인스트럭션들이 다른 프로세스의 인스트럭션들과 섞임 멀티코어 프로세서들 =&amp;gt; 여러 개의 프로그램 동시에 가능 프로세서가 프로세스들을 바꿔주는 방식으로 한개의 CPU가 다수의 프로세스를 동시에 실행하는 것 처럼함.문맥전환 교차실행 수행 모든 상태정보의 변화를 추적 context: pc, 레지스터 파일, 메인 메모리의 현재 값을 포함 어느 한 순간에 단일 프로세서 시스템은 한 개의 프로세스의 코드만 실행 가능 OS의 커널에 의해 관리 커널: 운영체제 코드의 일부분, 메모리에 상주, 컴퓨터는 응용 프로그램의 작업요청에 대해 특정 시스템 콜을 실행하여 커널에 제어를 넘겨줌 커널은 받은 작업을 수행, app으로 리턴 커널은 별도의 프로세스가 아님 커널은 모든 프로세스를 관리하기 위해 시스템이 이용하는 코드와 자료구조의 집합 프로세스의 추상화 구현 저수준의 하드웨어와 os 의 긴밀한 협력 필요 쓰레드(Thread) : 동시성 시스템에서는 프로세스가 실제로 쓰레드라고 하는 다수의 실행 유닛으로 구성되어 있다. 각각의 쓰레드는 해당 프로세스의 컨택스트에서 실행 동일한 코드와 전역 데이터를 공유 다수의 프로세스들에서보다 데이터의 공유가 더 쉽다 쓰레드가 프로세스보다 더 효울적가상 메모리아래가 0 추상화된 메모리: 각 프로세스들이 메인 메모리 전체를 독점하는 것 같이 보임 각 프로세스는 가상주소 공간이라는 균일한 메모리의 모습을 가짐 리눅스에서 주소공간의 최상위 영역은 모든 프로세스들이 공통으로 사용하는 os의 코드와 데이터를 위한 공간 주소공간의 하위 영역은 사용자 프로세스의 코드와 데이터를 저장 각 프로세스들에게 보여지는 가상주소공간은 몇 개의 정의된 영역으로 구성되어 있다. 가상메모리가 작동하기 위해서는 프로세서가 만들어내는 모든 주소를 하드웨어로 번역이 필요(hw &amp;lt;-&amp;gt; os 복잡한 상호작용) 기본적인 아이디어: 프로세스의 가상메모리의 내용을 디스크에 저장, 메인 메모리를 디스크의 캐시로 사용 프로그램 코드와 데이터: 코드: 모든 프로세스들이 같은 고정 주소에서 시작한 후 전역변수같은 데이터 위치들이 따라옴 코드와 데이터 영역은 실행가능 목적파일로부터 직접 초기화힙: 코드와 데이터 영역 (런타임 힙) 프로세스가 실행되면서 malloc, free 등에 의해 런타임에 동적으로 크기가 변함.공유 라이브러리: 주소공간의 중간 부근에 표준 라이브러리와 같은 공유 라이브러리의 코드와 데이터를 저장스택: 사용자 가상 메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용하는 사용자 스택이 있음. 동적으로 런타임에 크기가 변함. 함수 호출 시 스택이 커짐. 함수에서 리턴시 줄어든다.커널 가상메모리: 주소공간의 맨 윗부분은 커널을 위해 예약됨 응용프로그램들은 접근 금지됨 커널 함수 직접 호출 금지됨 커널을 호출해야만 접근 가능파일 연속된 바이트들 모든 입출력장치는 파일로 모델링 시스템의 모든 입출력: 유닉스 io 라는 시스템 콜들 이용. 응용프로그램에 시스템에 들어 있는 다양한 입출력 장치들의 통일된 관점 제공(추상화: 디스크의 기술에대해 몰라도됨)시스템은 네트워크를 사용하여 다른 시스템과 통신한다 최신 시스템: 다른 시스템과의 연결 인터넷 =&amp;gt; 다른 컴퓨터로의 정보 복사 일종의 입출력 장치중요한 주제들 시스템은 hw 그 이상의 것암달의 법칙 아이디어: 어떤 시스템의 한 부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 그 부분이 얼마나 중요한가와 이 부분이 얼마나 빨라졌는가에 관계됨. 전체 시스템을 빠르게 하기위해 전체 시스템의 매우 큰 부분의 성능을 개선해야 한다. 모든 작업을 개선하기 위한 일반적인 원칙을 설명 동시성과 병렬성 한번에 더 많이| | ||-|-||동시성| 다수가 동시에 벌어지는 일을 갖는 시스템||병렬성| 동시성을 사용해 시스템을 보다 빠르게 동작하도록 하는 것, 다양한 수준의 추상화에서 활용| 책에선 3개의 수준 강조 (쓰레드, 인스트럭션, SIMD) 쓰레드 수준 동시성     동시성 프로세스 추상화 개념 이용 =&amp;gt; 다수의 프로그램이 동시에 실행 쓰레드 한개의 프로세스 내에 실행되는 다수의 제어흐름 시간공유 기법 동시 실행에 대한 지원이 컴퓨터 시스템에 나타남 단일 프로세서 시스템 대부분의 실질적 계산은 한 개의 프로세서에 의해 이루어짐, 다수의 태스크 전환 멀티프로세서 시스템 여러 개의 프로세서를 가지고 하나의 os 커널의 제어 하에 동작하는 경우 (멀티코어 프로세서 + 하이퍼 쓰레딩 기법 =&amp;gt; 일반적 환경) 멀티코어 프로세서 여러 개의 CPU(코어)를 하나의 집적화된 칩에 내장(각각 별도의 L1, L2 캐시 사용, 메모리 인터페이스와 상위 수준 캐시 공유) 멀티쓰레딩(하이퍼쓰레딩) 하나의 CPU가 여러 개의 제어 흐름을 실행할 수 있게 해주는 기술. 기존의 프로세서는 쓰레드들 간의 전환을 약 2만 클럭 사이클이 요구되지만, 하이퍼쓰레드 프로세서에서는 매 사이클마다 실행할 쓰레드를 결정 멀티프로세싱으로 시스템 성능 개선 다수의 작업을 실행할 때, 동시성을 시뮬레이션할 필요를 줄여줌 멀티프로세싱으로 한 개의 응용프로그램을 빠르게 실행할 수 있음 하지만, 프로그램이 병렬로 효율적으로 실행할 수 있는 멀티쓰레드의 형태로 표현되었을 때에만 가능 인스트럭션 수준 병렬성 여러개의 인스트럭션 한 번에 실행 1978년 초기: 한개의 인스트럭션 실행 약 3.1 사이클 최근 2010년대: 매 클럭마다 2.3개의 인스트럭션 실행 인스트럭션들은 시작부터 종료까지 긴 시간(20사이클 이상)이 필요하지만 여러 기법으로 한번에 100개 처리 가능 파이프라인 기법: 요구되는 일들을 여러 단계로 나누고 프로세서 하드웨어가 일련의 단계로 구성되어 이들 단계를 하나씩 각각 수행, 병렬로 단계를 하나씩 수행 슈퍼스케일러: 사이클당 한 개 이상의 인스트럭션을 실행할 수 있는 프로세서 이 모델을 통해 작성된 코드가 보다 높은 수준의 인스트럭션 수준 병렬성을 갖게됨 (응용프로그래머들은 이 모델을 통해서 자신들이 작성한 프로그램의 성능을 이해할 수 있게됨) 싱글 인스트럭션, 다중 데이터 병렬성(SIMD) 최신 프로세스: 한개의 인스트럭션이 병렬로 다수의 연산을 수행할 수 있는 특수 하드웨어를 가짐 SIMD 인스트럭션들은 보통 영상, 소리, 동영상 데이터 처리를 위한 응용프로그램의 속도를 개선하기 위해 제공된다. 일부 컴파일러들이 자동으로 SIMD 병렬성 사용하도록 시도 중이지만 GCC같은 컴파일러에서 지원하는 특수 데이터 타입을 사용하여 작성하는게 안정적컴퓨터 시스템에서 추상화의 중요 좋은 프로그래밍 연습: 함수들을 간단한 응용프로그램 인터페이스 API로 정형화 컴퓨터 시스템의 주요 주제는 실제 구현의 복잡성을 감추기위해 여러 수준에서 추상화하는것 프로세서 측면: 인스트럭션 집합구조 운영체제 측면: 파일 &amp;lt;=&amp;gt; 입출력 장치, 가상메모리 &amp;lt;=&amp;gt; 프로그램 메모리, 프로세스 &amp;lt;=&amp;gt; 실행 중인 프로그램 가상머신: 운영체제, 프로세서, 프로그램 모두를 포함하는 컴퓨터 전체의 추상화를 제공" }, { "title": "[백준][C++] 14002: 가장 긴 증가하는 부분 수열 4 (dp)", "url": "/posts/2022/01/05/03/17/14002/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-01-05 03:17:31 +0900", "snippet": "문제14002가장 긴 증가하는 부분 수열의 해를 직접 구하는 문제.풀이: 크기 구하기먼저 크기를 구해보자O(NlogN)으로 풀기위해서cached라는 vector 타입을 선언하였고이 배열안에 수열의 원소를 앞에서 부터 cached에 집어넣었다.이 때 집어넣은 원소는 cached에서 어느 위치에 올 수 있는지 검사한다.이 위치는 현재 집어넣을 원소보다 큰 첫번째 원소이다.이렇게 값을 업데이트해주어도 상관이 없는 이유는 추가하려는 원소는 오직 자기 자신보다 큰 값이 있는가만 생각하기 때문이며 업데이트 되어도 업데이트 된 값으로 다시 그 길이 만큼 수열을 만들 수 있기 때문이다.풀이: 해 구하기문제는 해를 직접 구해야한다는 것이다.이를 구하기 위해 cached를 이차원 벡터로 변경하였고, 원래 수열의 인덱스를 포함시키기 위해 pair 자료구조를 이용하였다.이렇게 하면 맨 끝에서부터 이진 탐색으로 뒤의 원소보다 인덱스가 작은것을 찾을 수 있다.즉, 뒤에서부터 답을 추적할 수 있다는 것이다. 해를 구하는 track 함수void track(int idx, int before){ if (idx == -1) { return; } auto compare = [](const pii &amp;amp;a, const pii &amp;amp;b) { return a.second &amp;lt; b.second; }; vector&amp;lt;pii&amp;gt; &amp;amp;vp = cached[idx]; auto it = lower_bound(vp.begin(), vp.end(), pii(0, before), compare); if (it != vp.begin()) { it--; } track(idx - 1, it-&amp;gt;second); cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &quot; &quot;;} 이차원 벡터의 lower_bound를 다음과 같이 구현할 수 있다.int my_lower_bound(vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; &amp;amp;vvp, int low, int high, int X){ if (low &amp;gt; high) { return low; } int mid = low + (high - low) / 2; if (mid &amp;gt;= vvp.size() || vvp[mid].back().first &amp;gt;= X) { return my_lower_bound(vvp, low, mid - 1, X); } return my_lower_bound(vvp, mid + 1, high, X);} cached는 아래의 push 함수를 통해 업데이트 시킬 수 있다.void push(int item, int idx){ if (cached.empty()) { cached.push_back(vector&amp;lt;pii&amp;gt;(1, {item, idx})); } else { int loidx = my_lower_bound(cached, 0, cached.size(), item); if (loidx == cached.size()) { cached.push_back(vector&amp;lt;pii&amp;gt;(1, {item, idx})); } else { cached[loidx].push_back({item, idx}); } }}코드// start : 2022-01-04 15:36:45#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;tuple&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;using pii = pair&amp;lt;int, int&amp;gt;;// start : 2022-01-04 15:36:45vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; cached;int my_lower_bound(vector&amp;lt;vector&amp;lt;pii&amp;gt;&amp;gt; &amp;amp;vvp, int low, int high, int X){ if (low &amp;gt; high) { return low; } int mid = low + (high - low) / 2; if (mid &amp;gt;= vvp.size() || vvp[mid].back().first &amp;gt;= X) { return my_lower_bound(vvp, low, mid - 1, X); } return my_lower_bound(vvp, mid + 1, high, X);}void push(int item, int idx){ if (cached.empty()) { cached.push_back(vector&amp;lt;pii&amp;gt;(1, {item, idx})); } else { int loidx = my_lower_bound(cached, 0, cached.size(), item); if (loidx == cached.size()) { cached.push_back(vector&amp;lt;pii&amp;gt;(1, {item, idx})); } else { cached[loidx].push_back({item, idx}); } }}void track(int idx, int before){ if (idx == -1) { return; } auto compare = [](const pii &amp;amp;a, const pii &amp;amp;b) { return a.second &amp;lt; b.second; }; vector&amp;lt;pii&amp;gt; &amp;amp;vp = cached[idx]; auto it = lower_bound(vp.begin(), vp.end(), pii(0, before), compare); if (it != vp.begin()) { it--; } track(idx - 1, it-&amp;gt;second); cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &quot; &quot;;}int main(){ int N; cin &amp;gt;&amp;gt; N; for (int i = 0; i &amp;lt; N; i++) { int a; cin &amp;gt;&amp;gt; a; push(a, i); } cout &amp;lt;&amp;lt; cached.size() &amp;lt;&amp;lt; &quot;\\n&quot;; track(cached.size() - 1, N);}" }, { "title": "[백준][C++] 9095, 15988: 1,2,3 더하기 (dp)", "url": "/posts/2022/01/05/00/21/9095/", "categories": "algorithm, algorithm-ps", "tags": "ps", "date": "2022-01-05 00:21:21 +0900", "snippet": "문제9095159881, 2, 3의 합으로 나타내는 방법을 구하는 문제들.풀이완전탐색으로 경우의 수를 전부 세볼 수 있지만이 문제는 특정한 규칙을 찾아야하는 문제이다. 1 : 1 2 : 1 + 1, 2 3 : 1 + 1 + 1, 2 + 1, 1 + 2 , 3 4 : [3] + 1, [2] + 2, [1] + 3이렇게 나열해보면 n에서의 경우의 수는 [n-1]의 경우의 수 에서 각각에 1을 붙인것 [n-2] ‘’’ 2를 붙인것 [n-3] ‘’’ 3을 붙인것을 전부 합한것으로 볼 수 있다.즉 점화식은 다음과 같다.$dp[n] = dp[n-1] + dp[n-2] + dp[n-3]$코드#include &amp;lt;iostream&amp;gt;using namespace std;int n;int cached[12];void init(){ cached[0] = 1; cached[1] = 1; cached[2] = 2; for(int i = 3; i &amp;lt; 11; i++) { cached[i] = cached[i - 1] + cached[i - 2] + cached[i - 3]; }}int main(){ init(); int T; cin &amp;gt;&amp;gt; T; while (T--) { cin &amp;gt;&amp;gt; n; cout&amp;lt;&amp;lt;cached[n]&amp;lt;&amp;lt;&quot;\\n&quot;; }}" }, { "title": "[js] 자주 사용할만한 정규표현식", "url": "/posts/2021/12/30/19/27/regex1/", "categories": "lang, lang-javascript", "tags": "regex", "date": "2021-12-30 19:27:48 +0900", "snippet": "목차 특정 단어로 시작하는지 검사 특정 단어로 끝나는지 검사 숫자로만 이루어진 문자열인지 검사 하나 이상의 공백으로 시작하는지 검사 아이디로 사용 가능한지 검사 메일 주소 형식에 맞는지 검사 핸드폰 번호 형식 검사 특수 문자 포함 여부 검사 레퍼런스특정 단어로 시작하는지 검사 ‘http://’ or ‘https://’const url = &quot;https://&quot;;/^https?:\\.\\./.test(url); // true/^(http|https):\\/\\//.test(url); // true특정 단어로 끝나는지 검사 ‘html’ 로 끝나는지 검사const target = &quot;index.html&quot;;/html$/.test(fileName); // -&amp;gt;true숫자로만 이루어진 문자열인지 검사const target = &quot;12345&quot;;/^\\d+$/.teset(target); // -&amp;gt; tru자하나 이상의 공백으로 시작하는지 검사 [\\s] == 여러가지 공백문자등을 의미한다 [\\s] == [\\t\\r\\n\\v\\f]const target = &quot; Hi!&quot;;/^[\\s]+/.test(target); // -&amp;gt; true아이디로 사용 가능한지 검사const id = &quot;abc123&quot;;// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사/^[A-Za-z0-9]{4,10}$/.test(id); // true메일 주소 형식에 맞는지 검사const email = &#39;sdfjd@xxxx.dfd&#39;/^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]{2,3}$/.test(email); RFC 5322 이메일 정규식/(?:[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*|&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/.test( email);핸드폰 번호 형식 검사const phone = &quot;010-1234-5678&quot;;/^\\d{3}-\\d{3,4}-\\d{4}$/.test(phone);특수 문자 포함 여부 검사 (/[^A-Za-z0-9]/gi).test(target) (/[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+&amp;lt;&amp;gt;@\\#$%&amp;amp;\\\\\\=\\(\\&#39;\\&quot;]/gi).test(target); 특수문자 제거 : target.replace(/[^A-Za-z0-9]/gi, &#39;&#39;);레퍼런스 모던 자바스크립트 Deep Dive 591p mozilla-Regular_Expressions" }, { "title": "[js] 정규표현식 기본", "url": "/posts/2021/12/30/07/20/regex/", "categories": "lang, lang-javascript", "tags": "regex", "date": "2021-12-30 07:20:10 +0900", "snippet": "목차 정규 표현식 패턴(표현식)과 플래그로 구성 예시 플래그 정규식 생성 정규식 리터럴을 사용하는 방법 생성자 함수 호출 방법 RegExp 메서드 RegExp.prototype.exec RegExp.prototype.test String.prototype.match String.prototype.search String.prototype.replace String.prototype.split 예제들 문자열 검색 대소문자 구별 대소문자 구별 x 모든 문자열 전역 검색 임의의 문자열 검색 반복 검색 /A{m,n}/ /A+/ /A?/ OR 검색 A|B [A] NOT 검색 시작 위치 검색 마지막 위치 검색 괄호로 둘러싼 패턴 사용 레퍼런스정규 표현식 형식 언어(formal language) 정규 표현식은 문자열의 특정 문자 조합과 대응시키기 위해 사용되는 패턴이다. 대부분 프로그래밍 언어와 코드 에디터에 내장 패턴 매칭 기능 제공: 특정 패턴과 일치하는 문자열을 검색 or 추출 or 치환 정규식은 주석이나 공백을 허용하지 않는다. 여러가지 기호를 혼합하여 사용하여 가독성이 좋지않다.패턴(표현식)과 플래그로 구성 패턴은 문자열의 일정한 규칙을 표현한다. 패턴은 메타문자 또는 기호로 표현할 수 있다. 패턴과 일치하는 문자열이 존재할 때 ‘정규식과 매치한다’라고 한다. 패턴은 “/”로 감싸 표현한다. 플래그는 정규 표현식의 검색 방식을 설정하기 위해 사용한다.예시 아래와 같이 반복문 없이 패턴을 정의하고 테스트할 수 있다.const tel = &quot;010-1234-오오칠칠&quot;;const regex = /^\\d{3}-\\d{4}-\\d{4}$/; // -&amp;gt; 숫자3개, 숫자4개, 숫자 4개 라는 패턴regex.test(tel); // -&amp;gt; false플래그 플래그 의미 설명 i Ignore case 대소문자 구별 x 패턴 검색 g Global 패턴과 일치하는 모든 문자열 전역 검색 m Multi line 다중행 검색 s   .에 개행 문자도 매칭 u Unicode 패턴을 유니코드 포인트의 나열로 취급한다 y Sticky 문자열의 현재 위치부터 검색을 수행한다 플래그 == 옵션 선택적 사용가능하다. 순서와 상관없이 하나 이상의 플래그 동시 사용가능하다. 어떠한 플래그를 사용하지 않은 경우 대소문자 구별하고, 첫 매칭한 대상만 검색하고 종료한다. ‘m’ 플래그는 입력 문자열을 여러 줄로 다루기 위해 사용한다. 이 때 ‘^’, ‘$’ 는 전체 문자열의 첫과 끝을 나타내는것이 아니라 각 줄의 첫과 끝을 나타낸다.정규식 생성 정규표현식 리터럴 or RegExp 생성자 함수를 사용하여 생성정규식 리터럴을 사용하는 방법 슬래시 “/”로 감싸는 패턴 + 플래그(flag)var re = /ab+c/;const target = &quot;is this all there is?&quot;;const regex = /is/i; // i 플래그 : 대소문자 구별 x 검색regex.test(target); // -&amp;gt; true 정규식 리터럴은 스크립트가 불러와질 때 컴파일된다.(정규식이 상수라면 성능 향상)생성자 함수 호출 방법/** * pattern: 정규 표현식의 패턴 * flags: 정규 표현식의 플래그(g, i, m, u, y) */new RegExp(pattern[, flags])var re = new RegExp(&quot;ab+c&quot;);const target = &#39;is this all there is?&#39;;const regex = new RegExp(/is/i); //ES6//const regex = new RegExp(/is/,&#39;i&#39;);//const regex = new RegExp(&#39;is&#39;,&#39;i&#39;);regex.test(target); // -&amp;gt; true 실행 시점에 컴파일된다. 패턴이 변경될 수 있는 경우 사용한다. 사용자 입력과 같이 다른 곳에서 패턴을 가져올 때 사용한다.RegExp 메서드RegExp.prototype.exec 인수로 전달받은 문자열에 대해 정규식의 패턴을 검색, 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null 문자열 내의 모든 패턴을 검색하는 g 플래그를 지정해도 첫 매칭 결과만 반환한다.const target = &quot;Is this is&quot;;const regex = /is/;regex.exec(target);//-&amp;gt; (1) [&#39;is&#39;, index: 5, input: &#39;Is this is&#39;, groups: undefined] ‘g’ 플래그를 사용하면, 진행상황에 대한 정보가 반환된다.var xArray;var str = &quot;fee fi fo fum&quot;;var re = /\\w+\\s/g;while ((xArray = re.exec(str))) console.log(xArray);// [&quot;fee &quot;, index: 0, input: &quot;fee fi fo fum&quot;]// [&quot;fi &quot;, index: 4, input: &quot;fee fi fo fum&quot;]// [&quot;fo &quot;, index: 7, input: &quot;fee fi fo fum&quot;]RegExp.prototype.test 매칭결과를 불리언 값으로 반환한다.const target = &quot;Is this is&quot;;const regex = /is/;regex.test(target);//-&amp;gt; trueString.prototype.match String 표준 빌트인 객체가 제공하는 메서드 매칭결과를 배열로 반환한다. exec 메서드와는 다르게 g 플래그로 모든 매칭 결과를 반환한다.const target = &quot;Is this is&quot;;const regex = /is/g;const regex1 = /is/;target.match(regex);//-&amp;gt; (2) [&#39;is&#39;, &#39;is&#39;]target.match(regex1);//-&amp;gt; (1) [&#39;is&#39;, index: 5, input: &#39;Is this is&#39;, groups: undefined]String.prototype.search 대응되는 문자열이 있는지 검사한다. 대응된 부분의 인덱스를 반환한다. 문자열을 찾지 못하면 -1을 반환한다.String.prototype.replace 대응되는 문자열을 찾아 다른 문자열로 치환한다. 아래는 특수문자 제거 예제이다.target.replace(/[^A-Za-z0-9]/gi, &#39;&#39;)String.prototype.split 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환한다.예제들문자열 검색대소문자 구별const target = &quot;Is this is&quot;;const regex = /is/;regex.test(target); //-&amp;gt; truetarget.match(regex); //-&amp;gt; (1) [&#39;is&#39;, index: 5, input: &#39;Is this is&#39;, groups: undefined]대소문자 구별 xconst target = &quot;Is this is&quot;;const regex = /is/i;target.match(regex); //-&amp;gt; (1) [&#39;Is&#39;, index: 0, input: &#39;Is this is&#39;, groups: undefined]모든 문자열 전역 검색const target = &quot;Is this is&quot;;const regex = /is/gi;target.match(regex); //-&amp;gt; (3) [&#39;Is&#39;,&quot;is&quot;, &quot;is]임의의 문자열 검색 .은 임의의 문자 한 개를 의미한다. 아래는 문자의 내용과 상관없이 3자리 문자열과 매치한다.const target = &quot;Is this is&quot;;// 임의의 3자리 문자열을 대소문자를 구별하여 전역 검색한다.const regex = /.../g;target.match(regex); //-&amp;gt; (3) [&#39;Is &#39;, &#39;thi&#39;, &#39;s i&#39;]반복 검색/A{m,n}/ {m, n}은 앞 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 동작하지 않는다. m &amp;lt;= n, 양의 정수 n이 생략되면 ∞ 취급const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A{1,2}/g;target.match(regex); //-&amp;gt; (5) [&#39;A&#39;, &#39;AA&#39;, &#39;A&#39;, &#39;AA&#39;, &#39;A&#39;] {n}은 앞 패턴이 n번 반복되는 문자열을 의미한다. {n} == {n, n}const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A{2}/g;target.match(regex); //-&amp;gt; (2) [&#39;AA&#39;, &#39;AA&#39;] {n,}은 앞 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A{2,}/g;target.match(regex); //-&amp;gt; (2) [&#39;AA&#39;, &#39;AAA&#39;]/A+/ +는 앞 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. + == {1,} const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A+/g;target.match(regex); //-&amp;gt; (2) [&#39;A&#39;, &#39;AA&#39;, &#39;A&#39;,&#39;AAA&#39;]/A?/ ?는 앞 패턴이 0 또는 1회 등장하는 부분과 대응된다. ? == {0,1} 수량자 *, +, ?, {} 바로뒤에 사용하여 가능한 많이 대응시키지 않기위해 사용한다. (ex. A{1,3}일경우 AAA가 대응되지만, A{1,3}? 의 경우 A 만 대응됨) 사전 검증을 위해서도 사용한다.const target = &quot;color colour colouur colouuur colou colo our&quot;;const regex = /colou?r/g;target.match(regex); //-&amp;gt; (2) [&#39;color&#39;, &#39;colour&#39;]OR 검색A|B | 은 or의 의미한다.const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A|B/g;target.match(regex);//-&amp;gt; (11) [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;, &#39;A&#39;, &#39;A&#39;] +를 붙여 분해하지 않을 수 있다.const target = &quot;A AA B BB Aa Bb AAA&quot;;const regex = /A+|B+/g;target.match(regex);//-&amp;gt; (7) [&#39;A&#39;, &#39;AA&#39;, &#39;B&#39;, &#39;BB&#39;, &#39;A&#39;, &#39;B&#39;, &#39;AAA&#39;][A] [] 내의 문자는 or로 동작한다. /[AB]/+/g == /A+|B+/g [] 내에 -를 사용하면 범위를 지정할 수 있다. /[A-Z]+/gconst target = &quot;A AA AaA B aa Bb aB 1 2&quot;;const regex = /[A-Z]+/g;// regex = /[A-Z]+/gi; // (7) [&#39;A&#39;, &#39;AA&#39;, &#39;AaA&#39;, &#39;B&#39;, &#39;aa&#39;, &#39;Bb&#39;, &#39;aB&#39;]// regex = /[A-Za-z]+/g; // (7) [&#39;A&#39;, &#39;AA&#39;, &#39;AaA&#39;, &#39;B&#39;, &#39;aa&#39;, &#39;Bb&#39;, &#39;aB&#39;]// regex = /[0-9]+/g; // (2) [&#39;1&#39;, &#39;2&#39;]target.match(regex); // (7) [&#39;A&#39;, &#39;AA&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;] 숫자의 경우 쉼표(“,”)가 붙으면 매칭 결과가 분리되므로 패턴에 넣어줘야한다.const target = &quot;A AA 12,345&quot;;// const regex = /[0-9,]/g; // (2) [&#39;12&#39;, &#39;345&#39;]const regex = /[0-9,]+/g;target.match(regex); // (1) [&#39;12,345&#39;] [0-9] == [\\d] [\\D] == [\\d]가 아닌 것 [\\w] == 알파벳, 숫자, 언더 스코어 == [A-za-z0-9_] [\\W] == [\\w] 가 아닌것 [\\s] == 여러가지 공백문자등을 의미한다 [\\s] == [\\t\\r\\n\\v\\f]NOT 검색 […] 내의 ^은 not 이다. [^\\d] == [\\D]시작 위치 검색 […] 밖의 ^은 문자열의 시작을 의미한다. 단, […] 내의 ^은 not의 의미를 가진다.const target = &quot;https://&quot;;const regex = /^https/; // http 로 시작하는지 검사target.match(regex); // true마지막 위치 검색 $은 문자열의 마지막을 의미한다const target = &quot;https:// .com&quot;;const regex = /com$/; // com으로 끝나는지 검사target.match(regex); // true괄호로 둘러싼 패턴 사용 괄호는 해당 부분에 대응된 문자열을 기억한다. 기억된 문자열은 이후 다른 곳에서 사용한다.var re = /(\\w+)\\s(\\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);console.log(newstr);// &quot;Smith, John&quot;레퍼런스 모던 자바스크립트 Deep Dive 578p~ mozilla-Regular_Expressions" }, { "title": "[vscode] front matter gen", "url": "/posts/2021/12/29/01/50/front-matter-gen/", "categories": "vscode", "tags": "vscode, 프로젝트", "date": "2021-12-29 01:50:53 +0900", "snippet": "# front matter gen깃허브 블로그에 포스팅하기위해서는 마크다운에 front matter를 작성해야한다.그렇기 때문에 템플릿을 만들어주는 vscode 확장을 찾게되었고 belikejekyll이라는 확장프로그램을 찾았다.이 확장프로그램은 날짜와 파일이름을 대치할 수 있게 해주지만, 폴더이름은 해주지 않았다.나는 카테고리를 폴더명으로 하고 있기 때문에 폴더이름을 대치할 수 있게 코드를 수정하였고 아래 사진에서 볼 수있듯이 여러 템플릿을 사용할 수 있게 하였다.아래는 템플릿 예시이다.---layout: posttitle:date: %yyyy%-%mm%-%dd%T%hh%:%ii%:%ss%Zcategory: %dir0%author: Usertags: [tag1, tag2]summary: Summary of the article---또한 기본확장자를 지정할 수 있게 하여 마크다운 뿐만이 아니라 다른 곳에서도 사용가능하도록 설정을 추가하였다.(ex. 알고리즘 문제 템플릿)# 링크front-matter-gen-marketplacefront-matter-gen-gitvscode marketplace manage" }, { "title": "[vscode] vim 노말모드 영문키 자동 변환", "url": "/posts/2021/12/28/02/01/vscode-vim-ime/", "categories": "vscode", "tags": "vscode", "date": "2021-12-28 02:01:24 +0900", "snippet": "vim을 사용하다보면 노말모드에서 한영키가 거슬리는 일이 많이 일어난다.vscode vim 의 vim.autoSwitchInputMethod 을 세팅하면 이런 불편함을 어느정도 해결할 수 있다.# im-select 설치im-select위 경로에서 윈도우인 경우 im-select.exe를 다운받는다.mac m1은 im-select를 다운받으면 된다.# vscode-vim 설정 vscode 세팅에 다음과 같이 defaultIM에 윈도우 영문 입력기 코드인 1033과 im-select 경로를 입력해주면 끝. &quot;vim.autoSwitchInputMethod.enable&quot;: true, &quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;1033&quot;, &quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;D:\\\\Study\\\\im-select.exe&quot;, &quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;D:\\\\Study\\\\im-select.exe {im}&quot;, mac m1은 아래와 같다. &quot;vim.autoSwitchInputMethod.enable&quot;: true, &quot;vim.autoSwitchInputMethod.defaultIM&quot;: &quot;com.apple.keylayout.ABC&quot;, &quot;vim.autoSwitchInputMethod.obtainIMCmd&quot;: &quot;/Users/Downloads/im-select&quot;, &quot;vim.autoSwitchInputMethod.switchIMCmd&quot;: &quot;/Users/Downloads/im-select {im}&quot;,# 주의점 다른 모드에서 노말 모드로 변경 시에만 적용이된다. 즉, 다른 창에서 에디터로 들어오면 한영키는 그대로. 따로 설정하지 않았다면, 영문 입력기 사용 중 한영키를 누르지 말것.(alt + shift시 변경가능) 당연히 영문 입력기가 설치되어 있어야한다. vscode vim에 한글과 관련한 버그가 있다. permission denied 해결: sudo chmod -R 777 im-select# 공식문서vim input method" } ]
