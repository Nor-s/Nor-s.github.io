---
title: "[unreal4] 개발자를 위한 언리얼 엔진 시작하기_1"
date: 2022-02-16T11:34:51Z
category: ["game", "game-unreal4"]
tags: [unreal4]
---

- 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서.

# **인트로**

- 8개의 주제
  1. 엔진구조
  2. 렌더링
  3. 월드 빌딩
  4. 마테리얼
  5. 블루프린트
  6. 프로그래밍
  7. 캐릭터
  8. 애니메이션

# **월드 빌딩**

## **철학**

- 언리얼: 시각적 지향성을 추구하는 완성형 툴셋
- 레벨에 중점을 맞춘 워크플로, 레벨에디터로 시작한 언리얼 엔진
- 에디터: 기본적으로 서브에디터와 툴이 포함
- 툴과 서브에디터가 전부 에디터와 엔진의 일부,
  - 핵심적인 철학: 모든게 함께 빌드, 모두 같은 스타일, 같은 로직, 모든게 끊김없이 함께 작동해야함

## **Schematic**

### **Placeable Actors excluding 3D Actors**

- 월드에 배치가능하면서 3D 액터가 아닌것

- emitter Actors
- Reflection Captures
- static Lighting + stationary Light + Dynamic Lighting => Light Actors
  - 다섯가지 라이트(스태틱: 구운것)
- geometry Editing => volumes

  - 트리거, 블로킹, 킬z 등등 게임플레이 영향, 포스트 프로세스 변경
  - 볼륨이 중요함

- 게임플레이 + 워크플로우 => BP Actor
  - 블루프린트: 임베디드 스크립트
  - 게임플레이에만 국한되지 않는다. 월드 빌드와 콘텐츠 관리에 도움을 주는 기능도 있음.
- 게임플레이: 트리거, 스폰포인트, 플레이 스타트

### **Placeable 3D Mesh Actors**

- 모델이나 캐릭터

- static mesh: 변형되지않고 이동되지 않는다. 변형 기반 본이 없다는것.(vertex shader를 사용하면 변형되긴한다.)

- Lodding, HLOD , Instanced Static Meshes, Splines => staticmesh

  - Lodding: Dithered Lod Transition (디더링된 트랜지션 옵션)- 스무드를 조절,
  - HLOD: 계층형 LOD
    - 노멀LOD: 멀리있을 때 폴리곤 수가 줄어드는 데서 끝난다.(여전히 다양한 드로콜)
    - HLOD: 멀리서 메시를 한데 합치는것
    - window/HLOD outline 툴에서 생성(자동으로 생성해냄)
    - 한번의 드로콜을 사용하게 끔, 폴리곤 수가 줄어든다.
    - 텍스처를 하나로 합침
  - Instanced Static Meshes:
    - 인스턴스 렌더링.
    - 엔진에서 메시를 자동으로 처리
    - 기본적으로 언리얼 엔진의 메시는 인스턴트 스태틱 메시가 없기 때문에 언제나 메모리에서 처리된다.
    - 이 메시는 메모리에 한 번만 로드되지만, 드로콜이 여러개 있다면 렌더링도 여러번 이뤄진다.
    - 인스턴트 스태틱 렌더링으로 렌더링 처리가 된다.
    - instancedStaticmesh 컴포넌트:
      - 하나를 여러번 렌더링
  - Spline
    - 로프트 스플라인
    - revolve 스플라인
    - 메시를 스플라인으로 로프트나 리볼브 시켜 파이프나 울타리 등을 만들 수 있다.
    - 메시가 스플라인을 따르게 만드는것

- skeletal meshes
  - Lodding
  - 애니메이션과 캐릭터를 다룰 때
  - 보통 캐릭터에 사용할 본이 있는 매시를 다룰 때
  - 차량 등의 다른 요소에도 사용 가능
- Geometry
  - Geometry Editing
  - old and outdata
  - 프로토타입 작업, 화이트 박싱 작업에만 사용
  - 노멀 메시가 아님
    - BSP라고 부르는 바이너리 스페이스 파티셔닝(CSG)
    - 단점만 있음 거의.
- Procedural Mesh
  - 플러그인으로 활성화 해야한다.
  - vertex들을 설정하여 메시를 설정
- Foliage(야외)
  - Foliage Tool
    - 배치한 폴리지가 하나의 오브젝트로 작동한다.(배치 렌더링)
  - Grass
    - 랜드스케이프 전체를 덮는 작업에 아주 유용
    - 잔리 레이어: 터레인 전체에 자동 적용, 아래에 깔린 랜드스케이프의 라이트 정보를 재사용함.(이 메시는 라이팅맵을 굽거나 라이팅을 계산하지도 않음) -> 일관성 개선, 대규모 환경에 대한 스케일링도 나아짐.
  - Procedural Foliage: 지정한 매시를 좀더 똑똑하게 배치(나무를 심으면 나무가 퍼져 자라는 것처럼, 성장 시뮬 가능),(나무 그늘에서 뭔가가 자라게 설정 가능)
- Geometry Collections
  - Chaos Destructibles: 카오스는 새로운 피직스 시스템
  - 기본적으로 메시를 균열시켜서 저장하는 것
- Landscapes(야외)
  - Landscape Layers
  - Landscape Components
  - Landscape Gizmos: 일정영역을 선택해 복사가능
  - Landscape Visibility
  - Landscape Painting
  - 하이트맵: 원하는대로 제거, 수정, 확장 가능, 방대한 규모로 스케일링 가능(단일 하이트맵을 거대하게 유지하는 것보다는 나음)
  - Landscape Splines: 강이나 도로같은 요소를 작업할 때 유용
  - Landmass Plugin: (활성화 필요) 협곡같은거, 리얼타임 배치는 불가능, 에디터에서 배치, 평탄화된 지면 위 에 건물이 자동으로, 새 메시를 간단히 배
    - Landscape Brushes
- Skies
  - 거대한 메시, 거대한 구체, 구체가 머티리얼로 존재
  - PBSA-> materals -> static Meshes
  - Physically Based Sky Atmosphere - visual effect에서 선택 가능 - Light의 directional Light의 컴포넌트 조합 좋음 (필수요소) - directional Light에서 atmosphere 활성화(개인설정) - 내부의 태양으로 그레이디언트 생성 - 일광의 각도 파악, 모든 색상을 자동으로 조정
    - CTRL + L 키가 태양을 제어하는 단축키 - 오존등 조절하여 색 시뮬 가능(다른 행성 등 표현) - 스카이 시스템 전체가 머티리얼로도 캡쳐가 됨

### **3D Tools**

- 3D 메시 배치에 충실한 기능 (아직 한창 개발 중)
- sculpting Tools -> Modeling Tools
  - 이전에는 메시를 임포트만 할 수 있었음.
- UVTools -> Modeling Tools
  - 엔진내의 UV를 다시 수정 가능
  - 라이트맵 UV수정 등
  - 엔진이 라이트맵을 생성하는 시점은 메시를 임포트할 때나 그 이후로 선택할 수 있다.
- Mesh Simplification
  - 모든 모델의 일부
  - 기본적으로 메시를 간소화 가
  - LOD 생성 가능
  - 작은 유틸리티 플루프린트도 약간의 스크립팅으로 빌드 가능
  - 모든 콘텐츠의 LOD를 한 번에 생성허거나 임포트를 할 때 생성(엔진 자동화 기능)

### **Controlling The Level**

- World Properties
  - 모든 레벨에 있는 프로퍼티 목록
- Timeline-> Level Blueprint
  - 일종의 레벨 블루프린트, 각 레벨에는 내장된 블루프린트가 있다.
  - 타임라인 추가: 간단한 애니메이션(스켈레탈 애니메이션을 쓰지 않을 요소에 사용), (문, 엘리베이터, 버튼, 레버 등 간단한것)
    - 시퀀서: 영상 에디터로 사용가능
    - 단점: 재생할 때까지 프리뷰 못함
- Variants Manager
  - 편차를 관리하는 매니저
  - Level Variance Set 애셋-> 바닥 등을 선택-> 할당가능

> CE 콘솔입력: 블루프린트를 사용하면 사용가능, 함수나 이벤트 강제 실행 가능, 테스트에 좋음

- 시퀀서: 가장 큰 트랙 에디터(영상용)
  - 간단한 작업에는 과하다.
  - 월드에 시퀀서 플레이어로 배치되어있음.
  - 레벨 시퀀스 열기라는 버튼-> 시퀀서 에디터가 실행됨
  - 시퀀스는 값만으로 모든것을 수정가능
  - 머티리얼 프로퍼티 같은 다양한 요소에 키를 부여할 수 있다.
  - 이 키로 시퀀서 제어 가능

### **(Re)building**

![](/img/unreal_rebuild.png)

- 필수는 아님, 작업에 따라 달라짐.
- 사전 연산이 전혀 없이 월드와 레벨 빌드하고 싶을 경우

#### **Lightmass Importance Volume**

- **Lightmaps**
  - 라이트맵 생성, 알아서생성됨
  - 메시의 세컨드 채널에 UV좌표가 구성되어있는한 또는 없어도 뭘 해줄 필요가 없음.
  - 올바른 해상도로 알아서 처리
  - 다른 프로그램으로 직접 생성 가능
- **Volumetric Lightmaps**

- 라이트매스 볼륨안에서는 높은 퀄리티의 라이팅을 얻을 수 있다.
- 멀리 떨어진 지오메트리가 아니라 실제 플레이하는 곳에 배치

#### **Lighthing**

- Lightmass Importance Volume
- Precomputed Visibility

#### **HLOD**

- 계산 및 빌드되어야한다.

#### **Reflections Captures**

- 배치된 리플렉션은 모두 업데이트되고 캡처되어야한다.
- 리빌드 과정, 라이트 리빌드 과정에서 이뤄져야한다.
- 게임을 구웠거나 패키징하여 완성된 게임을 만들었다면, 리플렉션 캡처가 구워진것.
- 직접 구운 텍스처를 큐브맵이 생성해냄
- 에디터에서나 굽기전의 시점: 리빌드하거나 레벨을 여는 식으로 매번 리플렉션 캡처를 재생성해야한다.
- 그렇기 때문에 아직 패키징되지 않았거나 굽지 않은 레벨을 열 때 시간이 오래걸리는 것.
- **이런 요소들을 콘텐츠 브라우저에서 에셋으로 두고 리플렉션 캡처로 할당하면 그런 프로세스를 거치지 않아도 됨.**
  - 이러면, 수동으로 작업하거나 아예하지 말아야함
  - 리플렉션을 원하는 대로 정확히 표현하고 싶을 때만

#### **Navmesh**

- 빌드메뉴 => 다양한것들을 빌드 가능

  - 지오메트리 빌드: 스피드 브러시로 지오메트리를 리빌드.(지금은 거의 안씀)
  - 'p'키를 누르면 빌드 패스에 의해 생성된 내비메시가 나타남.
  - 빌드패스: 언리얼 엔진1용어로, 더이상 패스도 아님.

- 라이트맵에 의해 구동됨

- Navmesh Agent

### **Multi User Editing**

- 서버를 구성한 다음 다수의 사람들이 마치 멀티 플레이어 게임처럼 레벨을 실시간으로 편집하면서 그 결과를 확인할 수 있음.
- 두 사람이 정확히 똑같은 레벨을 동시에 수정 가능

### **라이트 시나리오**

- 선택적
- 레벨 스트리밍이나 서브레벨등을 호출하고 싶은데서 호출한다.
- **레벨탭** 에서 설정가능
- 밤이나 저녁
- 라이팅을 서브레벨에 두고 상호교환하거나 다양한 라이트 시나리오를 원하는대로 갖게 만들 수 있음.

- **중요한점은 보간할 수 없다는 점.**
  - 그냥 바꾸는 것.
  - 딜레이가 살짝 걸림.
  - 모든 요소를 불러옴.

### **Multiple Levels/ Streaming**

![](/img/unreal_levels.png)

- 다양한 서브레벨.
- 항상 쓰이는 것이 아님
- 대규모 작업에서 필수적
- 대안은 3가지

  1.  무시하고 쓰지 않는것(소규모 제작에서만 먹히는 방법)

  2.  persistent level

      - streamed level 등 이런 저런 루트를 사용
      - 실제로 레벨을 스트리밍하는 방법을 사용해도 되지만
      - 여러레벨(스트리밍), 실제로 일반적인 표준 레벨이 아니라 다른 레벨에 병합된 레벨(다른 사람이 작업한 레벨과 병합해도 상충 발생 x => 협업에 유리)
      - 레벨 스트리밍 볼륨에 들어가면 관련된 레벨이 로드됨. 이게 바로 레벨 스트리밍 - 에디터상에서는 지연 발생 가능, 하지만 패키징된 게임에서는 완전히 동기화된 상태로 실행됨. (설정에 따라 다름)
      - 위치별 분할이 가능.
      - 작은 묶음을 만들면 잘작동.

        > 스태틱 메시를 show 에서 끄면 볼륨찾기 쉬움.

             ![](/img/unreal_levels2.png)

- 스트리밍 방법:
  - 블루프린트, 코드: Load Stream Level 함수
  - 볼륨
  - 항상 로드
  - world composition: 월드를 다양한 레벨로 나눔. 기본적으로 별개의 셀로 나눈다. 각각이 모두 레벨이됨. 부모레벨인 persistent level의 일부가 됨. 오픈월드 용.
    - 거리 지정 가능.
    - 다음 레벨 근처로 가면 자동으로 로드
    - z 축에는 적용되지 않는다.
    - 레벨이 얼마나 먼 거리부터 보일지 정의 가능
    - 거리 그룹으로 정의 가능
    - 먼 거리에서도 보여야 하는 레벨이면 전부 그 그룹에 넣으면 됨.

### **The playable experience**

- Runtime Navmesh 컴포넌트
  - 미리 계산된 Navmesh를 원하지 않는 경우 (월드가 클 경우 거대한 단일 내비 메시를 두는 것도 이상적인 방식이 아님)
  - 런타임동안 내비매시를 생성할 수 있다.
  - 적들이 돌아다니는 주변에 작은 로컬 내비메시 생성기를 배치하는 것.

### **Performance**

- 통계
  - viewport에 stat
  - `stat scenerendering` : 추천할만한 명령은 아니지만, 씬의 렌더링을 요약, 정확하지않음, 메시드로콜을 파악 가능
  - 드로콜과 씬의 라이트 개수를 파악할 수 있다.
  - `stat game`: 블루프린트 시간
  - `stat none`: stat 지우기
  - `stat physics`
  - `stat Units`: fps를 ms 단위로 보여줌, 스레드별로 나누어줌, game, draw, gpu등의 프레임 시간을 보여줌.
  - `stat FPS`: 프레임속도를 보여줌.
  - 프로젝트를 재시작해도 특정 통계를 계속 보여주도록 설정 가능
- GPU 프로파일러:
  - 내장형 비주얼 프로파일.(대강 비슷한 정보를 보여줌. 가독성을 높여줌, 컨트롤 + 쉬프트 + ,)
  - ms단위 시각적 보여줌.
  - 실시간이 아님, 버튼 누른 순간만 포착
- 통계 패널:
  - window->statistics
  - 라이팅에 대한 통계를 표로 나열해서 보여줌.
  - Texture Stats
  - 폴리지는 하나로 셈(인스턴스 안셈)
- 뷰모드
- Cull/Max Draw Distance
  - 멀리있는 메시를 지움
  - 디스턴스 컬링이지만 볼륨의 제어를 받음.
- Scaleability
  - Render Quality
  - Force LODs
  - Distance Multipliers
  - Etc
  - 엔진 퀄리티: 서로다른 R dot Scalability C vars로 게임이 실행하는 동안 렌더러의 퀄리티를 실시간으로 바꿀 수 있다.
- world detail:
  - 언리얼1,2의 기능이 남아있는것
  - 파티클, 메시 등, 시각적 렌더링이 되는 모든 것의 속성에 적용된다.
  - 속성에서 detailmode에서 설정
    - High: High로 설정된 메시들 제거(규모가 작은 작업에서 사용, 거미줄 경우 투명해서 퍼포먼스가 무거움)
- 월드 구성과 퍼포먼스: 월드 컴포지션과 관련
  - 레벨 전체에 대한 적업도 할 수 있음.
  - 관리도 가능
  - 더 낮은 퀄리티의 새레벨을 만들기도 함.
  - 멀리 떨어진 셀은 시스템이 생성한 레벨의 간소화 버전
  - 랜드스케이프 자체
    - 엔진은 랜드스케이프의 모양을 노멀맵으로 구운다음 그 위에 노멀 맵을 렌더링
    - 랜드스케이프가 엄청나게 간소화되도 마찬가지.
    - 자동 LOD 간소화 기능도 제공하긴함.

## 조언

- 대규모 씬에서 쉽게 작업할 수 있도록 도움이 되는 월드 빌딩 기술, 팁 & 트릭

1. Level organization
2. Level cleanliness
3. Landscapes
4. Foliage
5. Painting Tools

### **Level organization**

#### **important** **actor** **standards, Outliner, Groups**

- 선택하면서 컨트롤 G 누르면 그룹으로 묶을 수 있음.
- 컨트롤 + 쉬프트 + G 키를 누르면 그룹을 잠시 비활성화 할 수 있음.
- 쉬프트 + G는 그룹해제
- 액터의 렌더링 방식은 그룹화해도 바뀌지 않음.(아웃라이너 또한)
- 아웃라이너에 폴더, 그룹, 레이어 등 작업 가능

#### **Layers**

- window ->layers
- 이름이 레이어지만 레이어는 아님
- 그냥 선택 설정임.

#### **Selection** **tools**

- 언리얼 엔진에서 뭔가를 선택할 수 있는 모든 방식
- 레벨을 빠르게 제어할 수 있음.
- 콘텐츠 브라우저에서도 이런 툴을 사용할 수 있음.(컨트롤 + B, 우클릭, 해당 에셋을 사용하는 모든 액터 선택)
- 통계툴 또한 선택하여 제어 가능.

### **Level cleanliness**

- Shadows/Collision은 끌 수 있음. -> 시야 명확, 퍼포먼스 증가. (sky 같은 경우 그림자, 콜리전 x)

#### **Snapping Tool Standard**

![](/img/unreal_sts.png)

- 그리드 스냅, 회전 스냅, 스케일 스냅
  - 월드 빌딩에 도움됨
- 그리드와 어긋나있지 않게 수정 가능(각종 요소들 움직이기 쉬움)

- 컨트롤로 여러 요소를 동시 선택 가능
- 대괄호 Bracket '[', ']'를 사용하면 그리드 크기 조절 가능

### **Landscapes**

- Lodding and Collisio, Per Component Settings

  - 랜드스케이프에서는 자동으로 LOD가 적용됨.
  - 랜드스케이프 세팅에서 설정 가능
  - 보통 LOD 거리를 좀더 높임.(기본 설정이 미묘하기 때문) 좀 더 명확하게해서 성능을 아주조금 높임.
  - 컴포넌트 별 설정도 가능.

  - 콜리전 밉 레벨: 1로 설정하면 콜리전의 정밀도가 낮아짐. 거친 터레인. -> 평평한 랜드스케이프에서 효과적(메모리 상당량 줄어들게함), 컴포넌트마다 해줄 수 있음.
  - 덜중요하거나, 거리에 따라서 머티리얼 간소화 가능

- Material complexity and Shared Samplers
  - 랜드스케이프는 공유 샘플러를 통해 최대 128개의 텍스처를 지원한다. (기본설정으로는 안됨, 머티리얼이 있다면 텍스처에서 sampler source를 From Texture Asset에서 공유 샘플러로 변경하면 128개의 텍스처 배치 가능 )
  - 랜드스케이프 머티리얼의 복잡성: 필요한만큼 조절 가능(보수적으로 작업하는게 좋음- 화면을 차지하는 픽셀의 대부분이 됨)
- Distance Fading scale/textures
  - 트릭
  - 렌더스케이프에서 타일같은 느낌을 없애는것
  - 멀리서 볼 때 보이던 텍스처 타일링이 어느 정도 거리에서 매크로 텍스처에서는 페이드되어 사라짐
  - 픽셀뎁스같은것
  - 스케일한 다음 그 위에 선형보간하는것
- Hard blends
  - 언리얼 엔진은 레이어 간의 하드 블렌딩을 지원한다.
  - 보통 언리얼 엔진의 랜드 스케이프에 페인팅을 하면, 굉장히 부드러운 트랜지션이 나타남,
  - 알파 텍스처를 정의하여 좀 더 확실하고 묵직한 트랜지션을 얻을 수 있음.(weight blend, height blend...)

### **Foliage**

- Foliage Assets

  - 폴리지 패널에 메시를 드래그 하여 넣으면됨.
  - 저장하지 않으면 페인팅 가능한 폴리지로 스태틱 메시를 직접 할당한다.
  - 폴리지 에셋으로 저장 가능.
  - 다른 레벨에서도 똑같은 설정으로 페인팅 가능
  - Foliage Paint Tool 패널의 설정, 에셋에 그 설정이 저장
  - 모든 레벨에서 바뀌기 때문에 엔진 퀄리티도 높아짐.
  - 잔디 (grass)에서 사용

- Range and Shadow

  - 그림자가 있으면 무거워짐
  - 잔디나 조그만 돌에는 그림자를 주지않는것이 좋음
  - 의미도 없음
  - 렌더링 거리는 짧게 유지하는게 좋음 (잔디의 제거 시점, 잔디 렌더링 중지 시점 확실하게 설정)
  - 기본설정으로는 렌더링이 계속해서 이어짐.

- 거리 조정에 특히 도움이 되는 요소 두가지
  - Lower position material trick
    - 확 없어지는것은 보기에 좋지않음.
    - 이 트릭을 이용하면 잔디가 땅 속으로 녹아드는 것처럼 보임
    - 페이드하면 반투명한 잔디가 생기기 때문에 좋지 않음.(디더링이나 트랜지션이 없다면 좋은 생각이 아님)
    - `Object Position`과 `Camera Position` 여기에 `distance`를 곱하여 앞쪽에 약간의 데드존을 `subtract`한 후 안전하게 `clamp`하면 됨.
    - `distance squared`를 사용하는게 더 저렴함.
  - Slope material trick
    - 경사면에 잔디를 심으면 잔디가 튀어나오는게 보임
    - 잔디를 표면의 각도에 정렬하면 잔디가 비스듬하게 자라게된다.(수직으로 자라지 않음)
    - 표면에 따라 정렬하면 잔디도 수직으로 자란다.
    - 메시를 회전 => 어떻게든 수직을 향하려고한다.
    - 다릉 머티리얼을 할당하면 메시를 압축해서 평탄화가 됨.
    - Vert Colors가 적용되었으며 스케일이 굉장히 낮아져서 압축됨.
    - vert colors는 어떤 버텍스를 나타내고 스케일을 높일지 결정
    - 스케일을 높이는 것도 머티리얼을 기반으로 이루어짐.(노멀 기반)
    - 월드 포지션 오프셋을 변경해서 수직으로 높여줌.

### **painting tool**

- 메시가 있는데 타일을 흙으로 페인팅하고 싶은 경우,버텍스 컬러를 페인팅 가능.
- 텍스처도 페인팅 가능, 텍스처를 인식,
- 페인팅이 가능하게 세분화된 메시, 나머지 작업은 머티리얼이

### **질문**

- 레이트레이싱 기술 대신 라이트매스 임포턴스 볼륨을 사용?
  - 모든 라이팅이 다이내믹 해진다면 라이트매스 임포턴스 볼륨은 필요가 없어짐
  - 사전 계산된 라이팅에만 사용하는 수단이기 때문
  - 구운 라이팅이 있다면, 라이트매스 임포턴스 볼륨도 있어야함.
  - 레이트레이싱은 아직 아무데나 가져다 사용하지 않음.
- 현업할 때 레벨은 분야별로 나누는게 좋음.

## **문제**

- 액터를 그룹화하고, 다양한 액터를 프로퍼티를 제어하려고한다면 무엇을 사용?
  - 블루프린트 액터
- 월드 프로퍼티에서 가장 흔히 세팅하는 2가지 프로퍼티세트
  - 게임모드
    - 라이트매스 프로퍼티
