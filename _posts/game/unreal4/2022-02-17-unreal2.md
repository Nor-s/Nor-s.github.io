---
title: "[UE4] 언리얼 엔진에 오신 것을 환영합니다 "
date: 2022-02-17T20:36:17Z
category: ["game", "game-unreal4"]
tags: [unreal4]
---

- [언리얼 엔진에 오신 것을 환영합니다.](https://learn.unrealengine.com/home/learningPath/119025)

- 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서.

# 언리얼 엔진4와의 첫시간

## 머티리얼

- 메시의 외관에 영향을 주는것.

- 머티리얼은 라이팅에 반응항다.

- 뭔가를 보려면 라이트가 있어야한다.

## Directional Light

- 태양을 시뮬레이션하는 아이템

## 디폴트 캐릭터

- 어딘가에 스폰된다.

- 플레이어 스타트나 카메라 위치(뷰포트의)에 스폰된다.

- 액터배치-> 기본 -> 플레이어 스타트

- 플레이어 스타트의 파란색 화살표가 정면을 뜻함.

- 플레이어 스타트의 위치를 조정할 때 플레이어가 바닥과 겹치면 BAD SIZE가 표시됨.

## 스카이 애트머스피어

- 월드의 가장 윗부분이나 대기를 나타냄

- 디렉셔널 라이트에서 애트머스피어의 작동방식을 결정해야함.
  - sun light 설정: 디렉셔널 라이트가 애트머스피어와 상호작용할 수 있게 해줌
  - 태양이 디렉셔널 라이트에 따라 회전한다.

## light

- 디렉셔널 라이트 -> intensity 조절하여 밝기 설정
- 이미시브 라이팅 사용 => self-lit : lighting 영향 받지 않음, 전체적인 광원이 없어도 보임.
- sky light => 앰비언트 라이트: 어두운곳의 밝기, 그림자 속 라이트, 어떤 것 뒤의 라이트
- 그림자 속 라이팅 : 앰비언트, 바운스 라이팅처럼 어디든 있는 라이팅
  - 이 밝기는 장소에 따라 밝기가 달라짐, 자동노출(auto exposure)이나 시각 순응(eye adaptation)
  - 어두운곳에 가면 이 라이트는 밝아짐, 밝은 곳으로 가면 어두워짐
- PostProcessVolume: Lens의 Exposure 에서 최소 최대 밝기. -> 범위== 이펙트의 차이
  - 1로 최대최소 설정해주면 어두운부분이 약간 어두워지고, 밝은곳은 더 어두워지지않음
- 라이트 블룸, 오클루전 라이트 새프트
  - 라이트 새프트: 디렉셔널 라이트에서 shaft occlusion, shaft bloom 설정하면 빛줄기가 생김. tint를 설정하여 푸른 안개 효과 낼 수 있음

### 모빌리티 세팅

- 씬에서 라이팅이 어떻게 쓰이는지를 결정한다.
- movable: 완전히 동적이라는 뜻, 모든것에 새도우, 실시간으로 라이팅이 적용됨, 퍼포먼스 가장 많이 소비
  - 모든 프레임이 정보를 하나하나 계산한다.
- static: 프로젝트가 돌아가기 전부터 모든게 미리 결정, 프레임마다 계산할 필요가 없음. 퍼포머스 가장 적음.
  - 라이트 맵을 사용한다거나, 굽는다고 함.
  - 이 세팅을 키면 화면 위에 라이팅을 다시 빌드해야 뜸.
- stationary: 두 옵션을 섞은것

- 프리뷰가 그림자에 나타나면 -> 빌드 -> 라이팅 빌드

## 블루프린트

- 블루프틴트는 요소의 모음, mesh일 수 도 있다.(Viewport)

- 뷰포트에서 구체는 콜리전, 플레이어가 밟으면 이벤트 발생

- 뭔가를 재사용하기 좋다.

- 에딧 -> 프로젝트 세팅
  - 맵&모드와 입력이 중요
  - 맵모드: 일부 게임 프레임워크나 언리얼 엔진의 유용한 기능을 설정한다.
    - 디폴트 폰 또는 디폴트 플레이어, 화면 뒤의 사람을 나타내는 디폴트 대상이 뭔지 등에 대해, HUD가 있는지, 컨트롤러 클래스가 뭔지(캐릭터에 대한 입력을 모방)
  - 입력: 입력세팅=> 커스텀 캐릭의 세팅과 기본 세팅과 일치하게 해야한다.
    - 동일한 키와 입력에 여러 입력을 매핑할 수 있다.
- 캐릭터 컴포넌트 -> 여러 변수 설정 가능(점프 최대 높이 등)

## 월드 아웃라이너

- 월드를 구성하는 모든 액터가 포함되어있는 패널
- 폴더생성가능 (폴더 삭제시 계층 구조의 루트로 다시 돌아감.)
- 부모-자손관계를 사용할 수 있음
  - 라이트를 블루프린트로 드래그하여 자손으로 종속시키면, 함께이동
- 한번에 여러 항목 영향: 전부 선택 -> 우클릭, 그룹선택 or 컨트롤 G

## 디테일 패널

- 현재 선택된 항목과 컴포넌트, 그리고 그 프로퍼티를 표시
- 프로퍼티 값을 변경하고, 컴포넌트를 추가하고, 선택된 항목을 블루프린트로 변환
- 다수의 디테일 패널을 사용하여 항목간의 프로퍼티를 서로 맞춤.

- Show hidden properties while playing: 플레이 도중 숨겨진 프로퍼티 표시
- 한 아이템의 프로퍼티를 다른 프로퍼티로 복사
  - 에디터에는 프로퍼티 매트릭스가 있음. (눈동자 모양 옆에 있는 프로퍼티 매트릭스-> 선택 열기)
  - 선택한 아이템과 공통 프로퍼티가 표시 -> 한번에 모두 같이 변경 가능
- 두 개의 다른 아이템 옵션 비교
  - window->details 에서 디테일 패널을 4개 까지 열 수 있음.
  - 디데일창의 락버튼을 사용하여 비교
- 오브젝트 프로퍼티와 옵션이 표시, 런타임이나 에디터에서 확인하거나 변경 가능.

## 문제1

1. 씬에 게임 안에서 볼 때만 실행되는 파티클 이펙트가 있습니다. 파티클 이펙트 실행을 확인하는 가장 빠른 방법은 무엇일까요?
   - G키 게임뷰

# 언리얼 엔진 소개

## 모드 패널

- 왼상단
- 윈도우 -> 모드
- 모드 설정 -> 랜드스케이프, 폴리지 시 아웃라이너, 뷰포트 설정 못함
  - 적절한 모드 사용, 실수할 가능성 높음

## 콘텐츠 브라우저

- 저장장치, 파일구조
- 프로젝트에 포함된 파일들
- 윈도우 -> 콘텐츠 브라우저: 창을 4개까지 추가 가능
- 폴더에 우클릭, 색변경가능.
- view type-show
  - developer content: 나만의 전용 콘텐츠로 임시 영역과 같다.
    - 프로젝트에 문제가 발생하길 원하지 않을 경우
  - 엔진 콘텐츠: 엔진에서 제공되는 콘텐츠.
    - 간편하게 바로 쓸 수 있는 콘텐츠가 많음.
- 컬렉션
  - 정적: 구성 가능한 항목에 대한 바로가기 옵션
  - 동적: 검색

## 메인툴바

- 프로젝트 작업시 사용함
- 아이템생성, 월드 생성
- 소스콘트롤: git
- 세팅: 프로젝트, 에디터, 플러그인
  - 기본적으로 반투명 아이템은 선택 불가능 (마티리얼이 반투명), 세팅에서 허용 설정(allow translucent selection), T키
  - 엔진 퀄리티 세팅: 변경내용은 에디터에만 영향, 최종 제품에 영향 x(머티리얼 퀄리티 또한 마찬가지)
  - 사운드 조절(게임 플레이시 제외한 사운드 크기)
- 레벨 블루포인트: 레벨에서 직접 액터와 같은 오브젝트를 참조, 연속된 블루프린트를 트리거링 또는 시네마틱 기능에 사용.
- play->시뮬레이션: 씬에서 시뮬레이션 설정을 킨다.
  - 뷰포트에서 시뮬레이션 보기 가능(실행중인 피직스나 파티클 )

## 세팅

### 에디터 개인설정 창

- 에디터가 작업을 수행하고 작동하는 방식에 대한 개인 설정, 세팅, 옵션을 변경할 때
- 편집-> 개인설정-> 에디터 개인설정

### 프로젝트 세팅

- 게임 모드를 오버라이드하여 전체 프로젝트에 적용가능
- 편집-> 프로젝트 세팅 or 툴바 -> 세팅->프로젝트 세팅
- 게임
  - 게임전용프레임워크 세팅
- 엔진
  - 프로젝트에 대해 엔진이 어떻게 설정되었는지
  - 입력이나 렌더링 설정방식
- 에디터
  - 프로젝트에서 에디터 각 부분을 처리하는 방식
- 플랫폼
  - 모든 플랫폼마다 고유의 아이템이 있음.
- 플러그인
  - 플러그인별로 프로젝트 고유의 세팅을 조정

#### 프로젝트

- 프로젝트 이름, 퍼블리셔, 관련 정보들
- **맵모드**
  - 멀티플레이어가 분할화면을 사용하는지 등.
  - Game Instance class
- 패키징
- 플랫폼 지원 설정

#### **엔진**

- 콜리전
  - 피직스를 사용할 때 아이템이 서로 상호작용할 때 사용됨.
  - 특정 아이템만 충돌하게 할 경우, 기본 콜리전은 제대로 작동하지 않을 수 있다.
- 인풋
  - 점프 이동 마우스 등 세팅
  - 마우스로 터치 시뮬, 기본 가상 조이스틱(모바일)
- 렌더링
  - **default** **setting** : 기본적으로 Bloom 활성화, Ambient Occlusion 활성화, Auto Exposure, Motion Blur 세팅
  - 포스트 프로세서 이펙트를 사용하거나, 카메라나 다른 세팅을 직접 조정하는것 대신 가능

#### 에디터

- 레벨 시퀀스 세팅

#### 플랫폼

- 플랫폼별 세팅 가능
  - direct, opengl, vulkan 설정

### 월드 세팅

- 현재 작업중인 레벨 고유의 세팅을 조정하거나, 오버라이드할 수 있다.
- 윈도우-> 월드 세팅, 툴바 -> 세팅 -> 월드 세팅

#### 월드

- Kill Z 조정
  - 세로축, 액터가 이 기준 이하면 사라짐

#### 게임모드

- 기본 게임 모드를 오버라이드
- 메인 메뉴가 있지만 일반게임모드에서 모든 기능이 다 필요하지는 않을 경우
  - 새로운 게임 모드를 만들고, GameMode Override를 해당 레벨에만 설정하는 것.

#### Lightmass

- 라이트매스 시스템은 양질의 결과를 제공할 수 있도록 설정되어있음.
- 라이트매스 시스템은 정적인 빌드된 라이팅.
- 라이팅을 빌드하고 굽는데 이 시스템이 사용된다.
- 이 세팅을 오버라이드하여 라이팅 퀄리티 개선,

- 구워진 라이팅을 사용하고 있지 않으면, 이 섹션은 걱정하지 않아도 된다.
- 대안은 Lightmaps => Force No Precomputed Light => 리빌드
- 이렇게하면 공간에 약간의 여유가 생긴다.(빌드된 라이트맵이 삭제되기 때문.)

#### Physics

- 기본 중력값 설정(오버라이드) 가능
  - water world를 설정할 경우 이 레벨의 중력값을 변경하려면, 이 설정을 변경하면됨.

#### VR시스템옵션

- World to Meters 월드 스케일 같은 기본설정을 변경할 수 있다.

#### Tick

- 레벨기준으로 설정
- 이 레벨에서는 틱속도를 조정할 수 있다.
- Mini/Max Global Time Dilation을 설정, Allow Tick Before Begin을 설정하면 시작전 틱을 허용할 수 있음.
- 이 설정은 월드 세팅에서 오버라이드할 수 있다.

  - 월드세팅은 작업중인 레벨 고유의 세팅창으로 여기에서 레벨 전용 세팅을 오버라이드하고 조정할 수 있다.

## 문제2

1. 프로젝트에 독립 게임 모드가 필요한 메뉴에 쓸 레벨이 있습니다. 에디터 어디서 이 게임 모드를 설정할까요?

   - 월드 세팅

2. 에디터 실행 -> 기본으로 어떤 맵파일을 로드하도록 : 맵 모드 세팅

# 프로젝트 및 파일 구조 이해

## .uproject

- 이 프로젝트가 엔진과 상호작용하는 방식에 대한 기본 설정을 포함
  - 버전, 플러그인, c++용 모듈, 플랫폼 등
- 게임을 실행할 수 있음.
  - 명령줄에 의해 실행되는 것으로 에디터에서 실행되는것과 동일
- 엔진 버전 변경가능
  - 에셋은 이전 버전과 호환되지 않음(주의)
- 소스cpp => vs 프로젝트 생성 가능
  - .uproject에 모듈이 생겨남. => 이 프로젝트와 연관시킬 코드
  - 모든 모듈 및 타깃, 프로젝트와 연관된 모든 소스코드를 찾아냄
  - 무언가를 활성화 하거나 비활성화 할 경우에만 편집
  - 플러그인 활성화 여부 확인 가능

## 프로젝트 폴더 구조

### 기본 구조

- CONFIG: 프로젝트별로 제어할 수 있는 설정
- CONTENT: 프로젝트의 모든 콘텐츠가 들어있다.
  - collections, developers (콘텐츠 브라우저의 컬렉션 표시등): 바로가기나 스크래치 파일
- SAVED: Intermediate폴더와 비슷, 확실한 경우가 아니면 제거x, 일단 삭제하면 그 안에 있던 내용물 재생성 불가, 게임의 실행 로그등,
  - 장애가 발생할 경우 엔진은 이 폴더를 살펴봄, 파일 및 폴더 복구를 시도.
- SOURCE: C++소스, 이 폴더가 없다면 프로젝트가 제대로 컴파일 x
  - 일부 코드가 제대로 작동 x, 뭔가 변경, 프로젝트 리셋 => 이 폴더를 삭제하는 방법(.uproject에서 모듈제거 ) => 블루프린트만 있는 프로젝트로 리셋 (비권장)

#### 삭제 가능한 파일 및 폴더

- INTERMEDIATE: 프로젝트를 작성하고 엔진을 사용하는 중간단계에 사용하는 임시파일과 폴더를 보관 (삭제하면 프로젝트를 다시열 때 시간이 더 걸림, 매번 재생성, 교체 )
- vs 솔루션 파일(모듈감지, 다시 생성됨)
- .vs 폴더 (자동완성을 위한 임시 데이터, 기타 VS기능들)
- Binaries는 임시폴더.
  - 컴파일된 바이너리 코드, C++ 소스 모듈과 dll 파일
  - 프로젝트를 컴파일할 때 생성.
  - 프로젝트가 제대로 패키징되지 않는 문제 -> 이 폴더를 삭제하면 해결될 수 있음.(프로젝트 리셋)

### 캐시에 저장된 다운로드

- 프로젝트를 만들거나, 엔진에 아이템을 설치해야 아이템이 다운로드됨
- 런처 설정-> edit vault cache location : 기본 캐시 폴더

### DDC 폴더

- 파생 데이터 캐시: 타깃 플랫폼에 대해 UE가 사용하는 특정 포맷, 에셋의 버전을 저장하는 캐시.
- 프로젝트 시작시간을 단축시켜줌
- Appdata>local>unrealengine
- 프로젝트 재실행시 셰이더를 다시 컴파일할 필요가 없음

- 각 버전에 대한 디렉터리, common 디렉터리
- DDC는 자체적으로 재생성, 필요에 따라 최신상태를 유지
- 필수는 아님, 재생성됨
- 폴더로 구성할 수 있으므로 공유할 수 있음(프로젝트 작업에 참여하는 사람들 모두가 같은 ddc사용 ) => 필요한 시간 단축

# **더** **나은** **파이프라인** **구축**

---

- 총 4가지 주제
  - Working with Others
  - Building Better 3D Meshes & Textures
  - Creating Materials & Material Instances
  - Performance & Optimization

## **소스컨트롤**

---

- 대부분 Perforce 와 Subversion을 사용한다.
  - 데이터 동기화, push, pull, revert, add, remove data
- 반드시 최종 애셋만을 임포트해야함
  - 같은 메시의 다른 버전을 임포트하지말아야함.

## **더 나은 3D 메시와 텍스처1**

---

- 명명 규칙, 알파 정보와 RGB 마스크 패킹, 처리하는 방법 등.
- UE4로 임포트할 수 있는 다양한 텍스처 자장 포맷에 대해
- 밉맵, 임포트, 텍스처 그룹의 용도
- 텍스처 압축

### **Naming** **Conventions**

- `SM_Rock_00` : 스태틱 메시, 00 버전
  - 좋은 명명 규칙=> 파싱 가능, 어떤 파이프라인에 연결하여 정보 추출가능
- `T_Rock_00_BC`: Base Color Texture

- `SKM_RockBunch_00`: Skeletal Mesh

### **텍스쳐 제작**

- 텍스처는 항상 2의 제곱이어야함(x와 y축이)
  - 16x256 등
  - 이 텍스처가 마지막에 메모리로 패킹되는 방식과 밉맵이나 텍스처 스트리밍 같은 언리얼의 내장 최적화에서 활용되는 방식이기 때문
  - 언리얼의 스트리밍 시스템에 사용되기 위해, 밉햅을 사용하기 위해 => 퍼포먼스 좋음.(거리에 따라 적절한 크기의 텍스처 생성 가능)

### **알파 정보 처리방법**

- 두 가지 방법

  - 삽입된 알파(Embed Alpha) : 독립된 알파보다 비용이 두배
    - 해당 텍스처에 저장된 정보인 알파 채널이 압축되지 않은 채 언리얼로 들어오기 때문.
    - 임포트될싶대 전체 해상도를 얻게됨: 해당 텍스처의 비용이 두 배라는 것.
  - 독립된 알파(Separate Alpha):
    - 베이스 컬러 사이즈로부터 알파 채널 사이즈를 독립적으로 제어할 수 있다는 점.

- 프로젝트 실행을 좀 빠르게 하고 싶을 경우
  - 모든 알파맵의 사이즈를 줄임
    - 삽입된 알파 => LOD 바이어스 5 => 알파의 크기가 작아짐 => 원하는대로 리소스 사이즈가 줄어든다. => 하지만 외형은 박살(베이스 컬러 역시 픽셀화됨)
    - 독립된 알파 => 조금 픽셀화 => 베이스 컬러는 거의 유지 => 알파 채널 정보를 정말 저렴하게 만들면서, 베이스 컬러 정보는 정확히 동일하게 유지
- 두 방법을 선택하는 것은 프로젝트와 워크플로에 달려있음.
  - 처음부터 독립된 알파를 사용하면 기존의 것 수정할 필요 없이, 퍼포먼스 문제를 확실하게 해결

### **RGB 마스크 패킹**

프로젝트 전체에 사용되는 텍스처의 양과 메모리를 줄이는 방법.

- 다양한 텍스처들 => RGB와 가끔은 텍스처의 알파 채널로 저장
  - Texture Sample 채널의 핀에서 이런 다양한 정보를 얻을 수 있음.
- 주로 VFX나 정말 높은 수준의 표면 디테일이 필요할 때, 그리고 일부 캐릭터 모델에 사용함
- 주의: 현재 사용하고 있는 채널의 흑백 정보만을 얻는다는점
  - 컬러정보를 얻으려면 이 결과에 특정 유형의 컬러 파라미터를 곱해 주어야하나.
- 참고: 텍스처 프로퍼티 자체에서 sRGB를 반드시 비활성화 해야한다.
  - 이걸 머티리얼에서 사용할 때는 sampler type이 masks로 설정되어야한다.
  - 이유: sRGB를 비활성화하면, 해당 텍스처의 감마 보정도 비활성화 되기 때문
    - 마스크 텍스처는 픽셀의 표시 여부를 정의하고 있기 때문에 감마보정이 되어서는 안됨.(이 정보가 단순히 렌더러에게 뭔가 표시될지의 여부만을 알려주기 때문.)

### **Saving Textures**

UE4에서 지원하는 다양한 텍스처 포맷

- BMP
- FLOAT
- PCX
- IPG
- EXR
- DDS - cubemap Texture(32 bits/channel 8.8.8 ARGB32bpp, unsigned)
- HDR - Cubemap Texture(longlat unwrap) => 2의 제곱 규칙을 따를 필요가 없음.
- **embed** **alpha** 지원
  - **PNG**
  - **PSD**
  - **TGA**

### **Mip Mapping**

- 프로젝트가 작동되는 데 중대한 역할.

- 텍스처의 레벨 오브 디테일

- 밉맵생성 == 텍스처를 UE4로 임포트할 때 발생

  - 특별한 경우가 아니라면 신경 쓸 필요 없다.

- 밉체인: 언리얼로 텍스처를 임포트할 때 자동생성
  - 프로젝트를 볼 때 대부분 이 체인에서 2단계나 3단계 쯤의 밉맵을 보게됨
- 텍스처가 화면에서 이 텍스처를 전체 해상도로 보여줄 필요가 없음

  - 거리가 먼 경우, 메모리는 여전히 텍스처를 크게 보여줄 때와 똑같은 비용이 들게됨.

- 밉맵 필터링 == Level of Detail 의 Mip Gen Setting에서, 밉맵이 생성될 때 날카롭게 보이거나, 흐리게 보이도록 할 수 있음.
  - 밉맵이 일종의 일렁거림을 일으킬 수 있음.
    - 쇠사슬로 연결된 울타리나 전선 메시처럼 작은 선을 가진 애셋에서 보이는 현상
    - 멀리 있는 텍스처 => 계단 현상 or 일렁임 형상 => Mip Gen Setting을 Sharpen 이나 Blur로 바꿔야함.
    - 프로젝트마다 해결할 수도 없을 수도 있다. (계속 세팅을 바꿔보면서 확인해야함)

### **Importing Textures**

- 윈도우 탐색기 => 콘텐츠 브라우저에 드래그 드랍
- import 버튼 => 탐색기 => 선택 => 열기

- 언리얼엔진은 파일의 특정 값을 보고 노말맵인지 뭔지 알아서 처리
  - 어떤 유형의 텍스처를 임포트하든 언리얼은 특정한 텍스처에 특정한 프로퍼티가 적용되어 있어야 한다는 걸 잘안다.
  - 임포트되는 노멀맵 : 노멀맵으로 자동 구성

### **Texture Groups**

- 텍스처가 프로젝트에서 사용되고 표시되는 방식을 관리하는데 도움.

- 어떤 유형의 텍스처를 사용하든 그 텍스처의 텍스처 그룹이 있음
  - 항상 프로젝트의 텍스처들이 올바른 텍스처 그룹에 있는지 확실하게 확인해야 할 것이다.
  - 실제로 그룹 안의 텍스처가 프로젝트에서 그려질 크기를 제어하기 때문.
- 텍스처를 축소하고 확대하는 정도 제어
- GPU를 통해서 텍스처에 적용할 필터링 종류도 제어

- Level of Detail에서 결정됨

- 최소 사이즈와 최대 사이즈를 제어할 수 있다.

- 프로젝트에서 텍스처 메모리가 바닥이 나면
  - 텍스처 메모리를 좀 되돌릴 수 있을지 실험을 해 봐야한다고 가정
  - 텍스처 그룹은 이처럼 리소스와 관련된 대규모의 실험을 비파괴적으로 할 수 있는 좋은 수단.
  - 이 system settings 로 모든 TEXTUREGROUP \_World 노멀맵에 접근할 수 있으며, LOD 바이어스를 변경하여 이걸 2나 3으로 설정해 밉맵 체인의 2나 3번째의 LOD를 취하게, 그 LOD가 주로 사용되도록 만들 수 있다.
  - 대략 2048쯤 되는 텍스처를 취해서 1024나 512 정도로 줄임 => 줄어든 텍스처로 프로젝트 실행가능 => 자신이 원했던 퍼포먼스 상 효과를 얻음 => 원하는거 얻지 못했으면 다시 되돌리기
    - 텍스처를 빼고 사이즈를 줄인 후 리임포트하는것보단 싸다

```cpp
[SystemSettings]
TEXTUREGROUP _World = (MinLOdSize = 1, MaxLOdSize = 8192, LODBias = 0, MinMagFilter = aniso, MipFilter = point)
```

### **텍스처 압축**

- 텍스처 더블클릭 => 압축 세팅 => 설정

- UI, 최대 해상도 필요할 경우 => UI or Vector Displacement
  - 전혀 압축되지 않은 텍스처
- srgb: 활성화된 텍스처에 감마보정
  - 하지만 노멀맵, 마스크 텍스처 같은 애셋은 텍스처 정보가 아니라 활용할 렌더러 정보를 포함하기에 이 텍스처에 포함된 정보는 어떤 방법, 형태, 형식으로든 절대 조정되지 않고, 지정된 방식을 정확히 그대로 고수해야함.

## **더 나은 3D 메시와 텍스처2: 스태틱 메시**

---

- System Units
- Lightmap UV's
- Triangle Counts
- Collision Meshes
- Material ID's
- What Are LOD's
- Pivot Points
- Creating LOD's
- What Are Lightmaps
- Limiting Overdraw

### **시스템 단위(system units)**

- 어떤 DDC앱을 사용하든 아이템 제작을 시작하기 전에 우선 시스템 단위를 확실하게 구성해야함.
  - (이 강의에선 3d studio max를 사용하지만 모두 적용되는것)
  - 우선 시스템단위가 센티미터로 설정됐는지 확인.
  - UE4의 기본 측정단위가 센티미터임.(1 언리얼 유닛 == 1 센티미터)
  - 몰입감때문에 이를 언리얼엔진과 DDC앱의 유닛 단위를 맞춰줘야함.

### **Triangle Counts**

- 트라이앵글 수: 퍼포먼스와 연관
- DDC에서 삼각형 수를 확인하며 작업해야함.
- 너트볼트와 같은 수준까지 디테일을 신경쓰지 않아도 됨.
  - 작은 디테일 => 플레이어도 모름 지나친 폴리곤 낭비

### **Material ID's**

- 모든 머티리얼은 하나 이상의 ID를 가진다.
- 어떤 폴리곤 면에 어떤 머티리얼이 적용되는지를 결정
  - ID가 5개면 렌더링이 5번되어야만 최종적으로 한번 더 렌더링 된 후 표시됨
- 머티리얼 유형: MultiSub-Object Material == 오브젝트에 다수의 머티리얼을 할당할 때
- ID가 많으면, 렌더링 비용도 증가

### **피벗 포인트**

- 올바른 피벗포인트를 설정해야함
  - 오브젝트의 피벗 포인트 위치 잡아야 원하는 곳에 배치 가능
  - DDC에서 잘 설정하고 작업해야함
  - 스케일을 조정할 때 거리또한 스케일됨, 틀어지면 모든 작업이 힘들어짐.

### **What Are Lightmap**

- 라이트맵: 텍스처의 복잡한 빛과 그림자의 정보를 저장하는 데 사용

  - 텍스처가 이러한 유형의 데이터를 저장하는 데 저렴하고 좋음
  - 복잡한 라이팅 계산을 텍스처에 저장하면, 런타임에 이 정보를 거의 비용없이 얻을 수 있다.

- 좋게보이도록, 퍼포먼스 높게 유지하도록, 균형을 맞추게해줌

- 라이트맵/ 섀도맵
  - 라이트맵: 일반적인 텍스처와 다르게 생김. 라이트맵의 RGB채널에 다양한 값들이 저장되었기 때문
    - 다양한 영역의 라이팅 정보가 모두 서로 다른 R,G,B 채널로 패킹된것
  - 섀도맵: 섀도 데이터를 R, G, B채널에 저장한 것

### **Lightmap UV's**

- 라이트맵 제작과 주의할 점

- 라이트맵은 오브젝트의 모든 면이 0-1 공간에 고유하게 배치되어야함
  - 각 면은 고유하게 배치되어야함. UV 아틀라스에서 각자 고유한 공간을 차지해야함.
  - 0-1 space: UV 정보 주변에 위치한 정사각형. 모든 UV가 스페이스에 있음.
  - 라이트맵을 렌더링할 때 라이트매스가 실제로 신경쓰는 데이터: 0-1 공간안에 있는것뿐, 그 외부 공간의 데이터는 잘라냄
  - 0-1공간에서 UV내 각 오브젝트에 각자의 공간을 확보해야함.
  - UV채널 = 2: 라이트맵 UV가 메시의 두 번째 채널에 저장되어야함을 의미 (3DMAX의 채널2는 UE4의 채널1, 언리얼은 0부터 채널 수를 셈)
  - 라이트맵이 언리얼로 임포트 될 때 자동으로 언팩됨
- 스태틱 메시 설정 아래에 라이트맵 해상도, 라이트맵 좌표 인덱스가 있음
  - 해상도: 메시 선택 => 디테일 패널 => Lighting => Overridden Light Map Res 에서 오버라이드 가능

### **Collision Meshes**

- 두 가지 방법으로 만들 수 있음.

- 자신이 사용하는 DCC에서 콜리전을 만든 다음 지오메트리와 함께 임포트

  - 콜리전 메시의 구체적인 식별자가 있는 이름을 지어줘야함.
    - `UCX_(메시 이름)_(콜리전 번호)`

- 언리얼엔진에서 콜리전을 만들 수 있음
  - 상단 메뉴바 => 콜리전 => 콜리전 메시
  - 컨벡스 분해(convex decompos): 콜리전을 만들기 어려운 유기적인 메시에 쓸 복잡한 콜리전을 만들 수 있는 기능
    - 윈도우 => 컨벡스 분해 선택 => 적용
    - 이 기능의 역할: 메시를 복셀화, 그 복셀을 기반으로 콜리전 파라미터를 생성하는 것

### **Limiting Overdraw**

- 오버드로는 투명 혹은 오파시티를 다룰 때 나타남
  - 이 현상은 GPU가 텍스처 곳곳에 다수의 투명을만들거나 여기저기가 뚫려 보이게 해서 유용한 정보를 표시하지 않게한다.
  - 오버드로는 다수의 평면을 겹쳐서 실제 나무, 덤불, 잔디 등과 같은 모습을 보여야 하는 폴리지 메시에서 자주 나타남
- 버텍스를 약간 더 사용하거나 평면의 실제 형태를 조정하여 오버드로의 발생량을 줄일 수 있다.
  - 버텍스를 몇 개 더 렌더링하는게 엄청난 수의 픽셀을 렌더링 한 다음 버리는 것보다는 싸다.(매프레임마다 하는 작업이므로)
- 오버드로 확인 : UE4의 툴 '셰이더 복잡도'라는 모드
  - 뷰포트의 Lit => Optimization Viewmodes => shader complexity
    - 하얀색을 최대한 많이 없애야함.

### **What are LOD's**

- Level of Detail
- 메시와 같지만 트라이 앵글 수가 더 적고 가끔 머티리얼 인스트럭션 수도 더 적은 사본
- 윤곽선이 같지만 해상도는 낮게
- 일정한 유형의 LOD가 있어야함.
- LOD 메시는 많이 있어도 되지만. 너무 많아서 프로젝트가 해가되는 시점이 올 수 있음
- 보통 75%, 35%, 12% 까지 메시를 줄임
  - 이런 수치는 정해진것은 아니지만, 차이가 나도록 설정해야함.
    - 메모리를 아낀다는 목적달성하기 위해

### **Creating LODS**

- (3DMax에서)
- 기존 메시 복붙, Modifier 목록에서 Pro-Optimizer를 추가, Caculate 클릭
  - 폴리 수 줄이기: Optimization level 에서 vertex% 50%로 설정
- 모든 작업 후에 서로 겹침. => 모두 선택한 후 => 메뉴바에서 Group => Group => 이름 LOD => Utilities Panel 탭에서 more.. => LOD 선택 => Create new set 클릭 => File 에서 Export

- (언리얼에서)
- 임포트 => 고급옵션 보기 => 임포트 옵션 => 메시 LOD 임포트의 박스 => 라이트맵 UV 생성은 끔 => DDC에서 만든 라이트맵 UV 사용
  - 메시 LOD임포트를 켜지 않은 상태 => LOD가 없는 기본 메시만 얻음
- 생성 => LOD 세팅 => LOD 그룹 => LargeProp => LOD 다수를 자동생성

## **애샛 임포트 익스포트**

- 스태틱 매시 익스포트
- 스켈레탈 메시 익스포트 + 옵션
- 애셋 리임포트
- 자동 리임포트: 폴더를 수신대기 설정 => 애셋이 변경되면 자동 리임포트
- FBX 를 통한 씬 전체의 임포트
- 수정할 애셋을 UE4에서 임포트

### **스태틱 매시 익스포트**

- UE4는 스태틱과 스케레탈 메시 모두에 FBX 포맷 사용 (애니메이션 포함)
- FBX: 기본 머티리얼 데이터, 스태틱 메시 데이터 , 기본 머티리얼 데이터와 함께 스킨을 입힌 메시 데이터, LOD, 본 기반 애니메이션 데이터

- 스태틱 메시에 선택해야할 FBX 익스포터
  - 지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation
  - 애니메이션이 있거나 Skeletal mesh에는 animation에 클릭해야함
  - 실수로 다른것도 익스포트하지 않도록 주의

### **스케레탈 메시 익스포트**

- 지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation
- 애니메이션: animation

- Deformation (Morph 타겟을 익스포트한다면): Deformations, Skins

### **3D Mesh 임포트**

- 드래그 드랍, 임포트 버튼

#### **3D Mesh 임포트 옵션**

- 대부분은 기본설정으로 충분.
- 콜리전 자동생성: 해당 메시의 콜리전 자동생성
- 라이트맵 UV 생성: 라이트맵 UV 생성, 최고가 아닌 경우가 많음. (강의하는 사람은 비활성화하는 편 ==> DDC에서 모든걸 직접 구성할 경우)
- 버텍스 절대치로 변환: 이 옵션이 꺼지면 콜리전 메시의 피벗 포인트가 전부 0이되어 스태틱 메시 중앙에 놓이게됨
- 머티리얼 임포트, 텍스처 임포트: 보통 비활성화 == 메시 작업 완료와 동시에 임포트와 구성이 될것이기 대문. 테스트 애셋 이 임포트될 수 있음.
- 스켈레톤 메시 에니메이션 임포트: 메시 옵션
- 스켈레톤 메시 활성화, 기존의 스켈레톤을 찾아서 그 애니메이션을 임포트할지 말지 선택
- 나중에 머티리얼과 텍스처를 직접세팅하고 싶기 때문에 머티리얼, 텍스처 임포트 옵션 끔

### **애셋 리임포트**

- 가장 간단하고 빠른 방법: 드래그 드랍 => 자동으로 업데이트
- 우클릭 => 리임포트
- 소스파일 경로 => 리임포트할 때 자동으로 이 경로 팡일로부터 리임포트
- 텍스처 더블클릭 => 리임포트 => 파일 탐색기(경로에 해당파일이 없을 경우) => 설정

### **자동 리임포트 구성**

- 에디터 설정 => General => Loading & Saving => Auto reImport => 폴더 모니터

- 업데이트가 저장될 폴더 수신대기 => 자동으로 업데이트 가능.

- 이 방법은 소스 컨트롤 없이 작업할 때 사용하기 좋음.
- 협업할 경우 프로젝트에 최신 변경사항을 확실하게 반영시키고 싶을 때 사용하기 좋음.

### **Full Scene Import**

- FBX 파일의 전체 씬 임포트
- 건축 시각화와 같은 프로젝트 => 모든 애셋을 가져와서 일일이 정확한 위치에 배치하는 것은 불필요 작업
- 스태틱메시 + 스켈레탈 메시 + 애니메이션 + 머티리얼 + 텍스처 + 리지드 바디 + 모프타깃 + 카메라 + 라이팅 모두 지원
- 머티리얼과 카메라는 일정한 제한이 있음.
  - 머티리얼: 디퓨즈와 노멀맵만 가져옴
  - 카메라: 애니메이션은 가질 수 없음, UE4에서 구성해야함.
- 3dmax에서 전체 선택 => 익스포트
- 임포트하면, 전체 씬을 재구성해 블루프린트에 배치해 주어서 씬의 모든 메시를 쉽고 빠르게 업데이트 할 수 있게 해 줌.

### **UE4로부터의 애셋 익스포트**

- 애셋이주: UE4 외부에서 콘텐츠를 가져오는 또 다른 방법, 모든 내부 연결을 유지해줌.
  - 구 버전의 UE4를 사용했을 때 아주 좋은 방법
  - 새 프로젝트에서 열면 텍스처, 머티리얼, 메시 모두의 내부 연결이 유지.
  - Content 폴더에 배치해야함.(안그러면 모든 연결이 망가질 가능성이 큼)
- 애셋 익스포트: 소스 콘텐츠에 접근할 수 없을 경우, 애셋에 아주 미세한 조정만 하고 싶을 경우

## **머티리얼과 머티리얼 인스턴스**

### **What is PBR**

- Physically Based Rendering: 빛의 실제 작용을 추정하는 것.
  - 더 정확, 더 자연스러운 라이팅
  - 모든 라이팅 시나리오에서 똑같이 잘 작동함.
  - 시나리오별로 다양한 버전의 라이팅을 만들 필요 없음
- 머티리얼도 평소처럼 복잡해질 필요가 없음.
  - 원래 필요했던 머티리얼 인스트럭션 수를 많이 간소화할 수 있다.
- 머티리얼 값 훨씬 덜 복잡, 덜 상호의존적/ 더 직관적으로 조정가능

- 단순히 극 사실적인 렌더링을 돕거나 사실적인 이미지에만 사용할 수 있는 것이 아님.

  - 만화 기반의 이미지에도 적용 가능

- 아트 프록덕션 파이프라인의 통일에 도움이됨.
  - PBR은 애셋 하나만 있어도 어떤 유형의 라이팅을 받든 정확히 똑같은 방식으로 라이팅에 반응함
  - 라이팅 유형 별로 다수의 머티리얼이나 텍스처를 만들필요가 없게됨

### **머티리얼 도메인**

- 각 머티리얼은 도메인과 블렌드 모드 또는 셰이딩 모델만 바꿔서 다양한 필요를 충족시킬 수 있다.
  - 이에 따라 일부 기능을 활성화하거나 비활성화해야함.
    - 주요 셰이더 노드의 각각 다른 출력에 영향이감.
- 머티리얼 도메인: 머티리얼 어트리뷰트가 평가되는 방식
- 블렌드 모드: 머티리얼 색과 배경과 블렌딩되는 방식을 결정
- 셰이딩 모델: 입력이 합쳐져 머티리얼의 최종 색을 만드는 방식을 결정

- ex. 유리: 블랜드= Transparent, 셰이딩= Unlit or Default Lit => 유리의 빛에 대한 반응 방식을 바꿀 수 있음.
- 여러 조합으로 필요를 만족시켜야함.

- 이들은 런타임에 변경할 수 없다.

### **머티리얼**

- 머티리얼은 UE4가 오브젝트 상 텍스처의 표시 방식을 돕거나 조작하는 수단.
- 머티리얼은 HLSL코드의 작은 블록들로 구성됨.
- 작은 블록들은 온갖 다양한 역할을 수행함.
  - 그 중에는 텍스처의 색상대로 색조를 더하거나 두 텍스처의 블렌딩을 돕는다.
  - 사실상 HLSL 함수를다루는것.
- 머티리얼은 먼저 컴파일되어야함.
  - 컴파일: 미리보기 뷰포트 위의 적용 클릭
  - 컴파일 == 스태틱 == 프로젝트 실행 중에는 변경불가
- 머티리얼로 프로젝트 전체의 온갖 다양한 머티리얼에 적용할 수 있는 기능이 있음.

### **머티리얼 인스턴스**

- 머티리얼은 런타임에 변경 불가

  - 색상, 텍스처 등

- 머티리얼 인스턴스는 머티리얼의 특별한 버전
  - 머티리얼을 리컴파일 할 필요 없이 머티리얼에 포함된 값과 텍스처를 런타임에도 바꿀 수 있게 해준다.
  - 덕분에 머티리얼 인스턴스는 반복처리를 정말 빠르게 해줌.
  - 변화가 거의 실시간.
  - 타임라인과 블루프린트로부터 머티리얼 인스턴스와 상호작용해 다양하고 멋진 애니메이션 효과 얻음.
- 퍼포먼스 이점
  - 유연성: 다양하고 수많은 파라미터 사용 => 마스터 머티리얼을 구성 => 복잡한 셰이더 코드를 다수 개발할 필요 없음. 미세 조정 가능

### **마스터 머티리얼**

- 많은 구성을 할 수 있는 머티리얼
  - 수 많은 파라미터 노드 사용
- Base Color라는 백터 파라미터 => 색선택
- 텍스처 파라미터=> 무엇이든 보충할 수 있게, 외형을 완전히 변경 가능
- 스칼라 파라미터 => 스칼라 변수 제어 = 특정 이펙트를 늘리거나 줄일 수 있음.

### **마스터 머티리얼 주의점**

- 가능한것

  - 다수의 마스터 머티리얼 사용

- 해서는 안됨

  - 모든 오브젝트에 작용하는 단 하나의 마스터 머티리얼을 만드는것은 하면안됨 => 성능에 문제 생김

    - 캐릭용 , 아이템용, 불투명한것, 투명한것.. 등등 따로 따로

  - 지레짐작하지말아야함(불필요한 파라미터 삽입금지)

### **마스터 머티리얼 개념**

- 머티리얼 => 좋은 퍼포먼스 + 자신이 목표로한 모든 플랫폼에서의 작동을 보장해야함
- 머티리얼 함수: 머티리얼 그래프 일부를 공유하고 재활용할 수 있게 해줌
  - 수많은 내장 함수들: 오브젝트의 월드 위치 결정, 화면상 마우스의 좌표 위치 파악까지 모든 것을 해냄
  - 머티리얼 라이브러리로 코드 공유 가능
  - 유지보수 간소화
- RGB 마스크 패킹
  - 텍스처의 사용 방식을 지정할 수 있다.
  - R, G, B, A 채널에 다른 텍스처를 저장하게 두는 것 => 메모리에서 텍스처 양을 줄일 수 있는 방법
- 스태틱 스위치(static switches)
  - 머티리얼의 전체 경로를 활성화 또는 비활성화
  - ex. 패럴랙스 오클루전 노멀 매핑을 켜고 끄는 스위치를 만들면 노멀 맵에 굉장히 비용이 높고 사실적으로 보이는 디테일을 구현할 수 있다.
    - 비용이 높아 씬의 머티리얼 다수에 사용할 수 없음 => 스위치로 필요한 메시에만 활성화
- 피처 레벨 스위치
  - 어떤 목표 기기에서든 머티리얼이 실행될 수 있게 해줌.
  - 다양한 플랫폼에 사용할 서로 다른 복잡도 수준에 따라 서로 다른 버전의 머티리얼을 연결
    - ex. 셰이더 모델 5(SM5)을 사용해 거의 무한한 디테일과 아름다움을 얻고 싶으면 => 높은 디테일의 셰이더가 됨.
    - ex. ES2에서 실행되는 것 => 안드로이드 모바일 프리뷰어, 그냥 실행만될 뿐, 부가기능많이 없음

## **마스터 머티리얼 제작**

- 배경 오브젝트에 사용할 마스터 오브젝트 구성 방법
- 배경 오브젝트용 마스터 머티리얼을 유리가 있는 오브젝트용 마스터 머티리얼로 변환
- 머티리얼 함수 만들고 사용

### **마스터 머티리얼 생성**

- 파일 -> 새 레벨 => 새 default 레벨 => 마스터 머티리얼 폴더 => 콘텐츠 브라우저 우클릭 => 새 마티리얼 =>더블클릭

- 색추가
  - 머티리얼 인스턴스 => 벡처 파라미터 노드 추가(BaseColor로 그룹)
  - 머티리얼 에디터 우클릭 => Vector 검색 => 베이스컬러와 연결 (키보드에서 v누르고 에디터 클릭)
- 텍스처 추가

  - T Key를 사용해 머티리얼 내에 배치 (콘텐츠 브라우저에서 우클릭후 텍스처 선택 => 머티리얼 에디터에서 t 누르고 에디터 클릭 or 드래그 드랍)
  - 텍스처를 텍스처 오브젝트로 변환해 설정할 것임.
  - 노드를 바로 BaseColor에 연결하면, 머티리얼을 컴파일하고 머티리얼 인스턴스에서 사용하려고하면 텍스처 샘플을 조정할 수 없게됨
  - Texture Sample 노드에 우클릭 후, 파라미터로 변환해야함. (Base_Color_Texture로 이름 설정, 그룹을 BaseColor)

- 스태틱 스위치 추가(텍스처나 더 저렴한 비용의 벡터 컬러 파라미터의 사용여부를 결정)
  - 머티리얼 에디터 => 우클릭 => 'Switch Parameter' => 'Default Value'를 true로 (bUseBaseColorTexture로 이름 설정, 그룹을 BaseColor)
- 상수 값 추가

  - 키보드 1 키 + 좌클릭 => 노드 우클릭 파라미터 변환 (Metallic으로 설정, 그룹도 Metallic)

- 러프니스 구성
  - 약간의 제어를 위해 Lerp Parameter 를 사용하여 러프니스 값을 높이거나 낮출것임.
  - 텍스처를 하나 더 추가 => 텍스처의 RGB 채널에 패킹된 러프니스 맵을 사용할 수 있도록 러프니스를 구성할것임
    - 이 텍스처에서 샘플 타입을 `Masks`로 설정해야함 => 마스크 파라미터 구해야함(RGB -> static mask param) => 머티리얼 인스턴스에서 텍스처의 다양한 R, G, V 채널을 선택 가능 (RoughnessMasks라고 이름 지음. Roughness 그룹에 넣음)
    - Texture Sample 우클릭 => 파라미터로 변환 => Roughness_Texture 라고 이름지음 => 그룹을 Roughness
  - 키보드 L 을 누르면서 클릭 => Lerp 노드를 생성 => Lerp의 Alpha와 마스크 연결 => A, B에는 스칼라(상수) 값 추가
  - 러프를 Roughness(러프니스)와 연결
    > 컨트롤 쉬프트 왼클릭 => 노드 다중 선택
- 노멀맵 추가

  - 텍스처 샘플러 추가 => 우클릭 => 노멀맵과 연결 => 샘플 타입 노멀로 설정 => 파라미터로 변환 (Normal_Map으로 이름 변경)

- 적용과 저장 버튼 => 마스터 배경(environment) 머티리얼 제작 끝

### **유리 머티리얼 제작**

- 위에서 만든 머티리얼 복붙, 이름 변경, => 오파시티나 오파시티 마스크 사용 (디테일 패널 => Materials 섹션 => Blend Mode)
  - BlendMode: Masked(렌더러에게 이 픽셀을 통과해서 볼 수 있는지 없는지 알려줌)or `Translucent`(통과해 볼 수 있는 정도를 어느정도 조절)
    - Translucency가 0.1 => 거의 다 통과 => 표면이 살짝 더럽거나 하는 경우를 만들 수 있음.
    - 오파시티 or Translucency : 오파시티 마스크보다 비용이 더 많이 든다.(속도를 원한다면 마스크 사용, 퀄리티 => 오파시티)
  - Opacity 상수 만들어 연결(opacity에)
- Shading Model을 Glass로 변경하여 씬의 라이팅과 더 나은 상호작용하도록 해야함
  - Transluncy 섹션 => Lighting Mode => `Surface Forward Shading` : 최고의 라이팅과 반투명 상호작용을 보여줌 + 비용이 가장 비싸기도함.
    - 컴파일 오래걺림

### **머티리얼 함수 제작**

- 서로 다른 머티리얼 간에 셰이더 코드를 공유할 수 있게 해주는 머티리얼 함수 제작

- 머티리얼 함수: 머티리얼 간의 셰이더 코드 공유하는 수단

- ex.

  - 'MF_Tile'이름의 머티리얼 펑션 생성
  - 간단한 텍스처 타일링: 타일링을 동일하게 유지시켜야하기 때문에 만든다. 각각 다른 셰이더에 사용하는 타일링 방식이 다를 필요가 없기 때문(일원화 작업)
  - 텍스처 좌표 추가(Texture Coordinate)
  - FunctionInput 추가 => Texture_Scale로 이름 변경 => Input Type을 인풋 스칼라로 (텍스처 좌표에 값을 곱할 것임) => preview Value의 x를 1로 설정
  - => M키 랑 왼클 => Multiply 노드 생성 => 좌표를 A, Scale 스칼라를 B, 그리고 Multiply 노드를 타일 아웃풋에 연결 => 적용
  - 아웃풋에 우클릭 => 미리보기 중지 => 다시 미리보기 시작

- 머티리얼 함수를 머티리얼 에디터에 드래그 드랍하여 배치 가능

- 머티리얼간에 일관성이 있어야함 => 변수명 등

## **머티리얼 인스턴스 사용**

- 부모 자손
