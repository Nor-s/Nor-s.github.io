---
title: "[UE4] 언리얼 엔진에 오신 것을 환영합니다 "
date: 2022-02-17T20:36:17Z
category: ["game", "game-unreal4"]
tags: [unreal4]
---

- [언리얼 엔진에 오신 것을 환영합니다.](https://learn.unrealengine.com/home/learningPath/119025)

- 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서.

# 언리얼 엔진4와의 첫시간

## 머티리얼

- 메시의 외관에 영향을 주는것.

- 머티리얼은 라이팅에 반응항다.

- 뭔가를 보려면 라이트가 있어야한다.

## Directional Light

- 태양을 시뮬레이션하는 아이템

## 디폴트 캐릭터

- 어딘가에 스폰된다.

- 플레이어 스타트나 카메라 위치(뷰포트의)에 스폰된다.

- 액터배치-> 기본 -> 플레이어 스타트

- 플레이어 스타트의 파란색 화살표가 정면을 뜻함.

- 플레이어 스타트의 위치를 조정할 때 플레이어가 바닥과 겹치면 BAD SIZE가 표시됨.

## 스카이 애트머스피어

- 월드의 가장 윗부분이나 대기를 나타냄

- 디렉셔널 라이트에서 애트머스피어의 작동방식을 결정해야함.
  - sun light 설정: 디렉셔널 라이트가 애트머스피어와 상호작용할 수 있게 해줌
  - 태양이 디렉셔널 라이트에 따라 회전한다.

## light

- 디렉셔널 라이트 -> intensity 조절하여 밝기 설정
- 이미시브 라이팅 사용 => self-lit : lighting 영향 받지 않음, 전체적인 광원이 없어도 보임.
- sky light => 앰비언트 라이트: 어두운곳의 밝기, 그림자 속 라이트, 어떤 것 뒤의 라이트
- 그림자 속 라이팅 : 앰비언트, 바운스 라이팅처럼 어디든 있는 라이팅
  - 이 밝기는 장소에 따라 밝기가 달라짐, 자동노출(auto exposure)이나 시각 순응(eye adaptation)
  - 어두운곳에 가면 이 라이트는 밝아짐, 밝은 곳으로 가면 어두워짐
- PostProcessVolume: Lens의 Exposure 에서 최소 최대 밝기. -> 범위== 이펙트의 차이
  - 1로 최대최소 설정해주면 어두운부분이 약간 어두워지고, 밝은곳은 더 어두워지지않음
- 라이트 블룸, 오클루전 라이트 새프트
  - 라이트 새프트: 디렉셔널 라이트에서 shaft occlusion, shaft bloom 설정하면 빛줄기가 생김. tint를 설정하여 푸른 안개 효과 낼 수 있음

### 모빌리티 세팅

- 씬에서 라이팅이 어떻게 쓰이는지를 결정한다.
- movable: 완전히 동적이라는 뜻, 모든것에 새도우, 실시간으로 라이팅이 적용됨, 퍼포먼스 가장 많이 소비
  - 모든 프레임이 정보를 하나하나 계산한다.
- static: 프로젝트가 돌아가기 전부터 모든게 미리 결정, 프레임마다 계산할 필요가 없음. 퍼포머스 가장 적음.
  - 라이트 맵을 사용한다거나, 굽는다고 함.
  - 이 세팅을 키면 화면 위에 라이팅을 다시 빌드해야 뜸.
- stationary: 두 옵션을 섞은것

- 프리뷰가 그림자에 나타나면 -> 빌드 -> 라이팅 빌드

## 블루프린트

- 블루프틴트는 요소의 모음, mesh일 수 도 있다.(Viewport)

- 뷰포트에서 구체는 콜리전, 플레이어가 밟으면 이벤트 발생

- 뭔가를 재사용하기 좋다.

- 에딧 -> 프로젝트 세팅
  - 맵&모드와 입력이 중요
  - 맵모드: 일부 게임 프레임워크나 언리얼 엔진의 유용한 기능을 설정한다.
    - 디폴트 폰 또는 디폴트 플레이어, 화면 뒤의 사람을 나타내는 디폴트 대상이 뭔지 등에 대해, HUD가 있는지, 컨트롤러 클래스가 뭔지(캐릭터에 대한 입력을 모방)
  - 입력: 입력세팅=> 커스텀 캐릭의 세팅과 기본 세팅과 일치하게 해야한다.
    - 동일한 키와 입력에 여러 입력을 매핑할 수 있다.
- 캐릭터 컴포넌트 -> 여러 변수 설정 가능(점프 최대 높이 등)

## 월드 아웃라이너

- 월드를 구성하는 모든 액터가 포함되어있는 패널
- 폴더생성가능 (폴더 삭제시 계층 구조의 루트로 다시 돌아감.)
- 부모-자손관계를 사용할 수 있음
  - 라이트를 블루프린트로 드래그하여 자손으로 종속시키면, 함께이동
- 한번에 여러 항목 영향: 전부 선택 -> 우클릭, 그룹선택 or 컨트롤 G

## 디테일 패널

- 현재 선택된 항목과 컴포넌트, 그리고 그 프로퍼티를 표시
- 프로퍼티 값을 변경하고, 컴포넌트를 추가하고, 선택된 항목을 블루프린트로 변환
- 다수의 디테일 패널을 사용하여 항목간의 프로퍼티를 서로 맞춤.

- Show hidden properties while playing: 플레이 도중 숨겨진 프로퍼티 표시
- 한 아이템의 프로퍼티를 다른 프로퍼티로 복사
  - 에디터에는 프로퍼티 매트릭스가 있음. (눈동자 모양 옆에 있는 프로퍼티 매트릭스-> 선택 열기)
  - 선택한 아이템과 공통 프로퍼티가 표시 -> 한번에 모두 같이 변경 가능
- 두 개의 다른 아이템 옵션 비교
  - window->details 에서 디테일 패널을 4개 까지 열 수 있음.
  - 디데일창의 락버튼을 사용하여 비교
- 오브젝트 프로퍼티와 옵션이 표시, 런타임이나 에디터에서 확인하거나 변경 가능.

## 문제1

1. 씬에 게임 안에서 볼 때만 실행되는 파티클 이펙트가 있습니다. 파티클 이펙트 실행을 확인하는 가장 빠른 방법은 무엇일까요?
   - G키 게임뷰

# 언리얼 엔진 소개

## 모드 패널

- 왼상단
- 윈도우 -> 모드
- 모드 설정 -> 랜드스케이프, 폴리지 시 아웃라이너, 뷰포트 설정 못함
  - 적절한 모드 사용, 실수할 가능성 높음

## 콘텐츠 브라우저

- 저장장치, 파일구조
- 프로젝트에 포함된 파일들
- 윈도우 -> 콘텐츠 브라우저: 창을 4개까지 추가 가능
- 폴더에 우클릭, 색변경가능.
- view type-show
  - developer content: 나만의 전용 콘텐츠로 임시 영역과 같다.
    - 프로젝트에 문제가 발생하길 원하지 않을 경우
  - 엔진 콘텐츠: 엔진에서 제공되는 콘텐츠.
    - 간편하게 바로 쓸 수 있는 콘텐츠가 많음.
- 컬렉션
  - 정적: 구성 가능한 항목에 대한 바로가기 옵션
  - 동적: 검색

## 메인툴바

- 프로젝트 작업시 사용함
- 아이템생성, 월드 생성
- 소스콘트롤: git
- 세팅: 프로젝트, 에디터, 플러그인
  - 기본적으로 반투명 아이템은 선택 불가능 (마티리얼이 반투명), 세팅에서 허용 설정(allow translucent selection), T키
  - 엔진 퀄리티 세팅: 변경내용은 에디터에만 영향, 최종 제품에 영향 x(머티리얼 퀄리티 또한 마찬가지)
  - 사운드 조절(게임 플레이시 제외한 사운드 크기)
- 레벨 블루포인트: 레벨에서 직접 액터와 같은 오브젝트를 참조, 연속된 블루프린트를 트리거링 또는 시네마틱 기능에 사용.
- play->시뮬레이션: 씬에서 시뮬레이션 설정을 킨다.
  - 뷰포트에서 시뮬레이션 보기 가능(실행중인 피직스나 파티클 )

## 세팅

### 에디터 개인설정 창

- 에디터가 작업을 수행하고 작동하는 방식에 대한 개인 설정, 세팅, 옵션을 변경할 때
- 편집-> 개인설정-> 에디터 개인설정

### 프로젝트 세팅

- 게임 모드를 오버라이드하여 전체 프로젝트에 적용가능
- 편집-> 프로젝트 세팅 or 툴바 -> 세팅->프로젝트 세팅
- 게임
  - 게임전용프레임워크 세팅
- 엔진
  - 프로젝트에 대해 엔진이 어떻게 설정되었는지
  - 입력이나 렌더링 설정방식
- 에디터
  - 프로젝트에서 에디터 각 부분을 처리하는 방식
- 플랫폼
  - 모든 플랫폼마다 고유의 아이템이 있음.
- 플러그인
  - 플러그인별로 프로젝트 고유의 세팅을 조정

#### 프로젝트

- 프로젝트 이름, 퍼블리셔, 관련 정보들
- **맵모드**
  - 멀티플레이어가 분할화면을 사용하는지 등.
  - Game Instance class
- 패키징
- 플랫폼 지원 설정

#### **엔진**

- 콜리전
  - 피직스를 사용할 때 아이템이 서로 상호작용할 때 사용됨.
  - 특정 아이템만 충돌하게 할 경우, 기본 콜리전은 제대로 작동하지 않을 수 있다.
- 인풋
  - 점프 이동 마우스 등 세팅
  - 마우스로 터치 시뮬, 기본 가상 조이스틱(모바일)
- 렌더링
  - **default** **setting** : 기본적으로 Bloom 활성화, Ambient Occlusion 활성화, Auto Exposure, Motion Blur 세팅
  - 포스트 프로세서 이펙트를 사용하거나, 카메라나 다른 세팅을 직접 조정하는것 대신 가능

#### 에디터

- 레벨 시퀀스 세팅

#### 플랫폼

- 플랫폼별 세팅 가능
  - direct, opengl, vulkan 설정

### 월드 세팅

- 현재 작업중인 레벨 고유의 세팅을 조정하거나, 오버라이드할 수 있다.
- 윈도우-> 월드 세팅, 툴바 -> 세팅 -> 월드 세팅

#### 월드

- Kill Z 조정
  - 세로축, 액터가 이 기준 이하면 사라짐

#### 게임모드

- 기본 게임 모드를 오버라이드
- 메인 메뉴가 있지만 일반게임모드에서 모든 기능이 다 필요하지는 않을 경우
  - 새로운 게임 모드를 만들고, GameMode Override를 해당 레벨에만 설정하는 것.

#### Lightmass

- 라이트매스 시스템은 양질의 결과를 제공할 수 있도록 설정되어있음.
- 라이트매스 시스템은 정적인 빌드된 라이팅.
- 라이팅을 빌드하고 굽는데 이 시스템이 사용된다.
- 이 세팅을 오버라이드하여 라이팅 퀄리티 개선,

- 구워진 라이팅을 사용하고 있지 않으면, 이 섹션은 걱정하지 않아도 된다.
- 대안은 Lightmaps => Force No Precomputed Light => 리빌드
- 이렇게하면 공간에 약간의 여유가 생긴다.(빌드된 라이트맵이 삭제되기 때문.)

#### Physics

- 기본 중력값 설정(오버라이드) 가능
  - water world를 설정할 경우 이 레벨의 중력값을 변경하려면, 이 설정을 변경하면됨.

#### VR시스템옵션

- World to Meters 월드 스케일 같은 기본설정을 변경할 수 있다.

#### Tick

- 레벨기준으로 설정
- 이 레벨에서는 틱속도를 조정할 수 있다.
- Mini/Max Global Time Dilation을 설정, Allow Tick Before Begin을 설정하면 시작전 틱을 허용할 수 있음.
- 이 설정은 월드 세팅에서 오버라이드할 수 있다.

  - 월드세팅은 작업중인 레벨 고유의 세팅창으로 여기에서 레벨 전용 세팅을 오버라이드하고 조정할 수 있다.

## 문제2

1. 프로젝트에 독립 게임 모드가 필요한 메뉴에 쓸 레벨이 있습니다. 에디터 어디서 이 게임 모드를 설정할까요?

   - 월드 세팅

2. 에디터 실행 -> 기본으로 어떤 맵파일을 로드하도록 : 맵 모드 세팅

# 프로젝트 및 파일 구조 이해

## .uproject

- 이 프로젝트가 엔진과 상호작용하는 방식에 대한 기본 설정을 포함
  - 버전, 플러그인, c++용 모듈, 플랫폼 등
- 게임을 실행할 수 있음.
  - 명령줄에 의해 실행되는 것으로 에디터에서 실행되는것과 동일
- 엔진 버전 변경가능
  - 에셋은 이전 버전과 호환되지 않음(주의)
- 소스cpp => vs 프로젝트 생성 가능
  - .uproject에 모듈이 생겨남. => 이 프로젝트와 연관시킬 코드
  - 모든 모듈 및 타깃, 프로젝트와 연관된 모든 소스코드를 찾아냄
  - 무언가를 활성화 하거나 비활성화 할 경우에만 편집
  - 플러그인 활성화 여부 확인 가능

## 프로젝트 폴더 구조

### 기본 구조

- CONFIG: 프로젝트별로 제어할 수 있는 설정
- CONTENT: 프로젝트의 모든 콘텐츠가 들어있다.
  - collections, developers (콘텐츠 브라우저의 컬렉션 표시등): 바로가기나 스크래치 파일
- SAVED: Intermediate폴더와 비슷, 확실한 경우가 아니면 제거x, 일단 삭제하면 그 안에 있던 내용물 재생성 불가, 게임의 실행 로그등,
  - 장애가 발생할 경우 엔진은 이 폴더를 살펴봄, 파일 및 폴더 복구를 시도.
- SOURCE: C++소스, 이 폴더가 없다면 프로젝트가 제대로 컴파일 x
  - 일부 코드가 제대로 작동 x, 뭔가 변경, 프로젝트 리셋 => 이 폴더를 삭제하는 방법(.uproject에서 모듈제거 ) => 블루프린트만 있는 프로젝트로 리셋 (비권장)

#### 삭제 가능한 파일 및 폴더

- INTERMEDIATE: 프로젝트를 작성하고 엔진을 사용하는 중간단계에 사용하는 임시파일과 폴더를 보관 (삭제하면 프로젝트를 다시열 때 시간이 더 걸림, 매번 재생성, 교체 )
- vs 솔루션 파일(모듈감지, 다시 생성됨)
- .vs 폴더 (자동완성을 위한 임시 데이터, 기타 VS기능들)
- Binaries는 임시폴더.
  - 컴파일된 바이너리 코드, C++ 소스 모듈과 dll 파일
  - 프로젝트를 컴파일할 때 생성.
  - 프로젝트가 제대로 패키징되지 않는 문제 -> 이 폴더를 삭제하면 해결될 수 있음.(프로젝트 리셋)

### 캐시에 저장된 다운로드

- 프로젝트를 만들거나, 엔진에 아이템을 설치해야 아이템이 다운로드됨
- 런처 설정-> edit vault cache location : 기본 캐시 폴더

### DDC 폴더

- 파생 데이터 캐시: 타깃 플랫폼에 대해 UE가 사용하는 특정 포맷, 에셋의 버전을 저장하는 캐시.
- 프로젝트 시작시간을 단축시켜줌
- Appdata>local>unrealengine
- 프로젝트 재실행시 셰이더를 다시 컴파일할 필요가 없음

- 각 버전에 대한 디렉터리, common 디렉터리
- DDC는 자체적으로 재생성, 필요에 따라 최신상태를 유지
- 필수는 아님, 재생성됨
- 폴더로 구성할 수 있으므로 공유할 수 있음(프로젝트 작업에 참여하는 사람들 모두가 같은 ddc사용 ) => 필요한 시간 단축

# **더** **나은** **파이프라인** **구축**

---

- 총 4가지 주제
  - Working with Others
  - Building Better 3D Meshes & Textures
  - Creating Materials & Material Instances
  - Performance & Optimization

## **소스컨트롤**

---

- 대부분 Perforce 와 Subversion을 사용한다.
  - 데이터 동기화, push, pull, revert, add, remove data
- 반드시 최종 애셋만을 임포트해야함
  - 같은 메시의 다른 버전을 임포트하지말아야함.

## **더 나은 3D 메시와 텍스처**

---

- 명명 규칙, 알파 정보와 RGB 마스크 패킹, 처리하는 방법 등.
- UE4로 임포트할 수 있는 다양한 텍스처 자장 포맷에 대해
- 밉맵, 임포트, 텍스처 그룹의 용도
- 텍스처 압축

### **Naming** **Conventions**

- `SM_Rock_00` : 스태틱 메시, 00 버전
  - 좋은 명명 규칙=> 파싱 가능, 어떤 파이프라인에 연결하여 정보 추출가능
- `T_Rock_00_BC`: Base Color Texture

- `SKM_RockBunch_00`: Skeletal Mesh

### **텍스쳐 제작**

- 텍스처는 항상 2의 제곱이어야함(x와 y축이)
  - 16x256 등
  - 이 텍스처가 마지막에 메모리로 패킹되는 방식과 밉맵이나 텍스처 스트리밍 같은 언리얼의 내장 최적화에서 활용되는 방식이기 때문
  - 언리얼의 스트리밍 시스템에 사용되기 위해, 밉햅을 사용하기 위해 => 퍼포먼스 좋음.(거리에 따라 적절한 크기의 텍스처 생성 가능)

### **알파 정보 처리방법**

- 두 가지 방법

  - 삽입된 알파(Embed Alpha) : 독립된 알파보다 비용이 두배
    - 해당 텍스처에 저장된 정보인 알파 채널이 압축되지 않은 채 언리얼로 들어오기 때문.
    - 임포트될싶대 전체 해상도를 얻게됨: 해당 텍스처의 비용이 두 배라는 것.
  - 독립된 알파(Separate Alpha):
    - 베이스 컬러 사이즈로부터 알파 채널 사이즈를 독립적으로 제어할 수 있다는 점.

- 프로젝트 실행을 좀 빠르게 하고 싶을 경우
  - 모든 알파맵의 사이즈를 줄임
    - 삽입된 알파 => LOD 바이어스 5 => 알파의 크기가 작아짐 => 원하는대로 리소스 사이즈가 줄어든다. => 하지만 외형은 박살(베이스 컬러 역시 픽셀화됨)
    - 독립된 알파 => 조금 픽셀화 => 베이스 컬러는 거의 유지 => 알파 채널 정보를 정말 저렴하게 만들면서, 베이스 컬러 정보는 정확히 동일하게 유지
- 두 방법을 선택하는 것은 프로젝트와 워크플로에 달려있음.
  - 처음부터 독립된 알파를 사용하면 기존의 것 수정할 필요 없이, 퍼포먼스 문제를 확실하게 해결

### **RGB 마스크 패킹**

프로젝트 전체에 사용되는 텍스처의 양과 메모리를 줄이는 방법.

- 다양한 텍스처들 => RGB와 가끔은 텍스처의 알파 채널로 저장
  - Texture Sample 채널의 핀에서 이런 다양한 정보를 얻을 수 있음.
- 주로 VFX나 정말 높은 수준의 표면 디테일이 필요할 때, 그리고 일부 캐릭터 모델에 사용함
- 주의: 현재 사용하고 있는 채널의 흑백 정보만을 얻는다는점
  - 컬러정보를 얻으려면 이 결과에 특정 유형의 컬러 파라미터를 곱해 주어야하나.
- 참고: 텍스처 프로퍼티 자체에서 sRGB를 반드시 비활성화 해야한다.
  - 이걸 머티리얼에서 사용할 때는 sampler type이 masks로 설정되어야한다.
  - 이유: sRGB를 비활성화하면, 해당 텍스처의 감마 보정도 비활성화 되기 때문
    - 마스크 텍스처는 픽셀의 표시 여부를 정의하고 있기 때문에 감마보정이 되어서는 안됨.(이 정보가 단순히 렌더러에게 뭔가 표시될지의 여부만을 알려주기 때문.)

### **Saving Textures**

UE4에서 지원하는 다양한 텍스처 포맷

- BMP
- FLOAT
- PCX
- IPG
- EXR
- DDS - cubemap Texture(32 bits/channel 8.8.8 ARGB32bpp, unsigned)
- HDR - Cubemap Texture(longlat unwrap) => 2의 제곱 규칙을 따를 필요가 없음.
- **embed** **alpha** 지원
  - **PNG**
  - **PSD**
  - **TGA**

### **Mip Mapping**

- 프로젝트가 작동되는 데 중대한 역할.

- 텍스처의 레벨 오브 디테일

- 밉맵생성 == 텍스처를 UE4로 임포트할 때 발생

  - 특별한 경우가 아니라면 신경 쓸 필요 없다.

- 밉체인: 언리얼로 텍스처를 임포트할 때 자동생성
  - 프로젝트를 볼 때 대부분 이 체인에서 2단계나 3단계 쯤의 밉맵을 보게됨
- 텍스처가 화면에서 이 텍스처를 전체 해상도로 보여줄 필요가 없음

  - 거리가 먼 경우, 메모리는 여전히 텍스처를 크게 보여줄 때와 똑같은 비용이 들게됨.

- 밉맵 필터링 == Level of Detail 의 Mip Gen Setting에서, 밉맵이 생성될 때 날카롭게 보이거나, 흐리게 보이도록 할 수 있음.
  - 밉맵이 일종의 일렁거림을 일으킬 수 있음.
    - 쇠사슬로 연결된 울타리나 전선 메시처럼 작은 선을 가진 애셋에서 보이는 현상
    - 멀리 있는 텍스처 => 계단 현상 or 일렁임 형상 => Mip Gen Setting을 Sharpen 이나 Blur로 바꿔야함.
    - 프로젝트마다 해결할 수도 없을 수도 있다. (계속 세팅을 바꿔보면서 확인해야함)

### **Importing Textures**

- 윈도우 탐색기 => 콘텐츠 브라우저에 드래그 드랍
- import 버튼 => 탐색기 => 선택 => 열기

- 언리얼엔진은 파일의 특정 값을 보고 노말맵인지 뭔지 알아서 처리
  - 어떤 유형의 텍스처를 임포트하든 언리얼은 특정한 텍스처에 특정한 프로퍼티가 적용되어 있어야 한다는 걸 잘안다.
  - 임포트되는 노멀맵 : 노멀맵으로 자동 구성

### **Texture Groups**

- 텍스처가 프로젝트에서 사용되고 표시되는 방식을
