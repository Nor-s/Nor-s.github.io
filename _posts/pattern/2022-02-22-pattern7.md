---
title: "[게임 프로그래밍 패턴] Design Patterns Revisited: State"
date: 2022-02-22T16:21:43Z
category: pattern
tags:
---

# **State**

> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴, 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임.

- 유한 상태 기계(FSM), 계층형 상태 기계, 푸시다운 오토마타 또한 다룸.

## **We’ve All Been There**

- 간단한 횡스크롤 플랫포머를 만든다고 가정.
- 주인공이 사용자 입력에 따라 반응하도록 구현해야한다.

<details><summary><font color = "green">무작정 구현하면 코드는 복잡해진다.</font></summary>
<div markdown="1">
- B버튼을 누르면 점프하는 코드는 다음과 같다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    yVelocity_ = JUMP_VELOCITY;
    setGraphics(IMAGE_JUMP);
  }
}
```

- 이 코드는 '공중 점프'를 허용한다.(계속 공중에 떠 있을 수 있다.)
- `isJumping_` 필드를 추가하면 간단히 고칠 수 있다. (토글할 필요가 있다)

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_)
    {
      isJumping_ = true;
      // Jump...
    }
  }
}
```

- 주인공이 땅에 있을 때 아래 버튼을 누르면 엎드리고, 버튼을 떼면 다시 일어서는 기능은 다음과 같을 것이다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    // Jump if not jumping...
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    setGraphics(IMAGE_STAND);
  }
}
```

- 이 코드의 버그
  - 엎드리기 위해 아래 버튼을 누른 뒤, B버튼을 눌러 엎드린 상태에서 점프하고나서 공중에서 아래버튼을 떼면, 점프 중에 땅에 서 있는 모습으로 보임.
  - 플레그 변수가 더 필요하다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ && !isDucking_)
    {
      // Jump...
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      isDucking_ = false;
      setGraphics(IMAGE_STAND);
    }
  }
}
```

- 점프 중, 아래 버튼을 눌러 내려찍기 공격을 할 수 있게 하는 코드는 다음과 같다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ && !isDucking_)
    {
      // Jump...
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
    else
    {
      isJumping_ = false;
      setGraphics(IMAGE_DIVE);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      // Stand...
    }
  }
}
```

- 이번에도 버그가 생긴다. - 또 플래그 변수를 넣어야한다.
- 이런 식으로 코드를 건드리면 계속해서 망가진다.
</div></details>

> 좋은 개발자는 어떤 코드가 버그가 생기기 쉬운지에 대한 감각이 있다. 분기가 복잡하거나 상태가 변경 가능한 코드들은 버그가 쉽게 생긴다.

## **Finite State Machines to the Rescue**

- 위 에서 다룬 동작들을 플로차트로 그려보면 다음과 같다.

![](https://gameprogrammingpatterns.com/images/state-flowchart.png)

- 위와 같은 플로차트를 **유한 상태 기계(FSM)**이라 한다.
- FSM은 **오토마타 이론**에서 나왔다.

  > 오토마타 중 튜링 기계가 유명하다.

- 핵심은 **상태, 입력, 전이**

  - **가질 수 있는 '상태'가 한정**: 서기, 점프, 엎드리기, 내려찍기
  - **한번에 '한가지' 상태만 될 수 있다.**: 주인공은 점프와 동시에 서있을 수 없다. 동시에 두가지 상태가 되지 못하도록 막는게 FSM을 쓰는 이유 중 하나.
  - **'입력'이나 '이벤트'가 기계에 전달**: 버튼 누르기와 버튼 떼기.
  - **각 상태에는 입력에 따라 다음 상태로 바뀌는 '전이'가 있다.**: 입력이 들어왔을 때, 현재 상태에 해당하는 전이가 있다면 전이가 가리키는 다음 상태로 변경된다.

- 서 있는 동안 아래 버튼을 누르면 엎드리기 상태로 전이한다.

- 현재 상태에서 들어온 입력에 대한 전이가 없을 경우 입력을 무시한다.

## **Enums and Switches**

- 위에서 다룬 Heroin 클래스의 문제점은, 불리언 변수 값 조합이 유효하지 않을 수 있다는 점이다.

  - 점프와 엎드리기 동시에 참 불가.

- 여러 플래그 변수 중 하나만 참일 경우 열거형(enum)을 사용하는 것이 좋다.

<details><summary><font color = "green">열거형 사용</font></summary>

<div markdown="1">

```cpp
enum State
{
  STATE_STANDING,
  STATE_JUMPING,
  STATE_DUCKING,
  STATE_DIVING
};
```

- 먼저 상태에 따라 분기하게 했다.
  - 이제 플래그 여러개 대신 state\_ 필드 하나만 있어도 됨.

```cpp
void Heroine::handleInput(Input input)
{
  switch (state_)
  {
    case STATE_STANDING:
      if (input == PRESS_B)
      {
        state_ = STATE_JUMPING;
        yVelocity_ = JUMP_VELOCITY;
        setGraphics(IMAGE_JUMP);
      }
      else if (input == PRESS_DOWN)
      {
        state_ = STATE_DUCKING;
        setGraphics(IMAGE_DUCK);
      }
      break;

    case STATE_JUMPING:
      if (input == PRESS_DOWN)
      {
        state_ = STATE_DIVING;
        setGraphics(IMAGE_DIVE);
      }
      break;

    case STATE_DUCKING:
      if (input == RELEASE_DOWN)
      {
        state_ = STATE_STANDING;
        setGraphics(IMAGE_STAND);
      }
      break;
  }
}
```

- 분기 문을 다 없애진 못했지만, 업데이트해야 할 상태변수를 하나로 줄였고, 하나의 상태를 관리하는 코드는 한곳에 있다.

  - 열거형은 상태 기계를 구현하는 가장 간단한 방법이다.

</div>
</details>

- 열거형만으로 부족할 수 있다.

- 이동을 구현하고, 엎드려있으면 기가 모여, 놓는 순간 특수 공격을 쏠 수 있게 만들면, 엎드려서 기를 모으는 시간 또한 기록해야한다.
  - 이와 관련 있는 패턴: `매서드 패턴`

<details><summary><font color = "green">chargeTime 추가</font></summary>
<div markdown="1">

- 이를 위해 Heroin에 chargeTime\_필드 추가

```cpp
void Heroine::update()
{
  if (state_ == STATE_DUCKING)
  {
    chargeTime_++;
    if (chargeTime_ > MAX_CHARGE)
    {
      superBomb();
    }
  }
}
```

- 엎드릴 때마다 시간을 초기화해야하니 `handleInput()` 또한 수정해야한다.

```cpp
void Heroine::handleInput(Input input)
{
  switch (state_)
  {
    case STATE_STANDING:
      if (input == PRESS_DOWN)
      {
        state_ = STATE_DUCKING;
        chargeTime_ = 0;
        setGraphics(IMAGE_DUCK);
      }
      // Handle other inputs...
      break;

      // Other states...
  }
}
```

- 기 모으기 공격을 추가하기 위해 함수 두 개를 수정하고 `chargeTime_`을 추가했다.

</div></details>

- 이렇게 chargeTime\_을 추가하는 것은 좋지 않다.
  - 모든 코드와 데이터를 한곳에 모아둘 수 있는 게 낫다.

## **The State Pattern**

- 모든 분기문을 동적 디스패치(C++에서는 가상함수)로 바꾸려 하는 것은 과하다.
  - 때로는 if문으로 충분
  - 하지만 위의 예제라면, 객체지향, `상태 패턴`을 사용하는게 좋다.

### **A state interface**

- 다중 선택문에 있던 동작을 인터페이스의 가상 메서드로.

```cpp
class HeroineState
{
public:
  virtual ~HeroineState() {}
  virtual void handleInput(Heroine& heroine, Input input) {}
  virtual void update(Heroine& heroine) {}
};

```

### **Classes for each state**

- 상태별로 인터페이스를 구현하는 클래스 정의.
- 메서드: 어떤 행동을 하는지 정의.
- case 별로 클래스를 만든다.
- chargeTime\_같은 경우 더 분명하게 보여준다.(엎드린 상태에서만 유의미)

```cpp
class DuckingState : public HeroineState
{
public:
  DuckingState()
  : chargeTime_(0)
  {}

  virtual void handleInput(Heroine& heroine, Input input) {
    if (input == RELEASE_DOWN)
    {
      // Change to standing state...
      heroine.setGraphics(IMAGE_STAND);
    }
  }

  virtual void update(Heroine& heroine) {
    chargeTime_++;
    if (chargeTime_ > MAX_CHARGE)
    {
      heroine.superBomb();
    }
  }

private:
  int chargeTime_;
};
```

### **Delegate to the state**

- 주인공 클래스에 현재 상태 객체 포인터 추가, 상태 객체에 위임(다중 선택문 제거)

```cpp
class Heroine
{
public:
  virtual void handleInput(Input input)
  {
    state_->handleInput(*this, input);
  }

  virtual void update()
  {
    state_->update(*this);
  }

  // Other methods...
private:
  HeroineState* state_;
};
```

- **상태 변경 == state\_에 다른 객체 할당**

> 전략패턴, 타입 객체 패턴과 비슷, 하위 객체에 동작을 위임하지만 의도에서 차이.(전략 == 일부 동작으로 부터 디커플링, 타입객체 == 같은 타입 객체 레퍼 공유, 상태 == 동작 변경)

## **Where Are the State Objects?**

- 상태를 변경: state\_에 새로운 상태 객체 할당.
  - 실제 인스턴스가 필요

### **Static states**

- 상태 객체에 필드가 따로 없으면, 인스턴스는 하나만 있으면됨.
- 여러 FSM이 동시에 돌더라도 상태 기계는 다 같음.

> 필드가 없고, 메서드도 하나라면, 정적함수 사용가능. (state\_는 함수 포인터)

```cpp
class HeroineState
{
public:
  static StandingState standing;
  static DuckingState ducking;
  static JumpingState jumping;
  static DivingState diving;

  // Other code...
};
```

```cpp
if (input == PRESS_B)
{
  heroine.state_ = &HeroineState::jumping;
  heroine.setGraphics(IMAGE_JUMP);
}
```

### **Instantiated states**

- 정적 객체만으로 부족할 때

  - `chargeTime_`필드가 캐릭마다 다를 경우

- 전이할 때마다 상태 객체 생성
  - FSM이 상태별로 인스턴스를 가짐.
  - 새로 할당하는 것 == 이전 상태 해제

```cpp
void Heroine::handleInput(Input input)
{
  HeroineState* state = state_->handleInput(*this, input);
  if (state != NULL)
  {
    delete state_;
    state_ = state;
  }
}
```

```cpp
HeroineState* StandingState::handleInput(Heroine& heroine,
                                         Input input)
{
  if (input == PRESS_DOWN)
  {
    // Other code...
    return new DuckingState();
  }

  // Stay in this state.
  return NULL;
}
```

- 저자는 매번 상태 객체를 할당하기 위해 메모리와 CPU를 낭비하지 않아도 되는 정적 상태를 쓰는 편.
  - 동적할당 메모리 단편화 => 오브젝트 풀 패턴

## **Enter and Exit Actions**

## **What’s the Catch?**

## **Concurrent State Machines**

## **Hierarchical State Machines**

## **Pushdown Automata**

## **So How Useful Are They?**

## **출처**

[State](https://gameprogrammingpatterns.com/state.html)
