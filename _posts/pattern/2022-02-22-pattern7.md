---
title: "[게임 프로그래밍 패턴] Design Patterns Revisited: State"
date: 2022-02-22T16:21:43Z
category: pattern
tags:
---

# **State**

> 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 패턴, 객체는 마치 자신의 클래스를 바꾸는 것처럼 보임.

- 유한 상태 기계(FSM), 계층형 상태 기계, 푸시다운 오토마타 또한 다룸.

## **We’ve All Been There**

- 간단한 횡스크롤 플랫포머를 만든다고 가정.
- 주인공이 사용자 입력에 따라 반응하도록 구현해야한다.

<details><summary><font color = "green">무작정 구현하면 코드는 복잡해진다.</font></summary>
<div markdown="1">
- B버튼을 누르면 점프하는 코드는 다음과 같다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    yVelocity_ = JUMP_VELOCITY;
    setGraphics(IMAGE_JUMP);
  }
}
```

- 이 코드는 '공중 점프'를 허용한다.(계속 공중에 떠 있을 수 있다.)
- `isJumping_` 필드를 추가하면 간단히 고칠 수 있다. (토글할 필요가 있다)

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_)
    {
      isJumping_ = true;
      // Jump...
    }
  }
}
```

- 주인공이 땅에 있을 때 아래 버튼을 누르면 엎드리고, 버튼을 떼면 다시 일어서는 기능은 다음과 같을 것이다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    // Jump if not jumping...
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    setGraphics(IMAGE_STAND);
  }
}
```

- 이 코드의 버그
  - 엎드리기 위해 아래 버튼을 누른 뒤, B버튼을 눌러 엎드린 상태에서 점프하고나서 공중에서 아래버튼을 떼면, 점프 중에 땅에 서 있는 모습으로 보임.
  - 플레그 변수가 더 필요하다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ && !isDucking_)
    {
      // Jump...
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      isDucking_ = false;
      setGraphics(IMAGE_STAND);
    }
  }
}
```

- 점프 중, 아래 버튼을 눌러 내려찍기 공격을 할 수 있게 하는 코드는 다음과 같다.

```cpp
void Heroine::handleInput(Input input)
{
  if (input == PRESS_B)
  {
    if (!isJumping_ && !isDucking_)
    {
      // Jump...
    }
  }
  else if (input == PRESS_DOWN)
  {
    if (!isJumping_)
    {
      isDucking_ = true;
      setGraphics(IMAGE_DUCK);
    }
    else
    {
      isJumping_ = false;
      setGraphics(IMAGE_DIVE);
    }
  }
  else if (input == RELEASE_DOWN)
  {
    if (isDucking_)
    {
      // Stand...
    }
  }
}
```

- 이번에도 버그가 생긴다. - 또 플래그 변수를 넣어야한다.
- 이런 식으로 코드를 건드리면 계속해서 망가진다.
</div></details>

> 좋은 개발자는 어떤 코드가 버그가 생기기 쉬운지에 대한 감각이 있다. 분기가 복잡하거나 상태가 변경 가능한 코드들은 버그가 쉽게 생긴다.

## **Finite State Machines to the Rescue**

- 위 에서 다룬 동작들을 플로차트로 그려보면 다음과 같다.

![](https://gameprogrammingpatterns.com/images/state-flowchart.png)

- 위와 같은 플로차트를 **유한 상태 기계(FSM)**이라 한다.
- FSM은 **오토마타 이론**에서 나왔다.

  > 오토마타 중 튜링 기계가 유명하다.

- 핵심은 **상태, 입력, 전이**

  - **가질 수 있는 '상태'가 한정**: 서기, 점프, 엎드리기, 내려찍기
  - **한번에 '한가지' 상태만 될 수 있다.**: 주인공은 점프와 동시에 서있을 수 없다. 동시에 두가지 상태가 되지 못하도록 막는게 FSM을 쓰는 이유 중 하나.
  - **'입력'이나 '이벤트'가 기계에 전달**: 버튼 누르기와 버튼 떼기.
  - **각 상태에는 입력에 따라 다음 상태로 바뀌는 '전이'가 있다.**: 입력이 들어왔을 때, 현재 상태에 해당하는 전이가 있다면 전이가 가리키는 다음 상태로 변경된다.

- 서 있는 동안 아래 버튼을 누르면 엎드리기 상태로 전이한다.

- 현재 상태에서 들어온 입력에 대한 전이가 없을 경우 입력을 무시한다.

## **Enums and Switches**

- 위에서 다룬 Heroin 클래스의 문제점은, 불리언 변수 값 조합이 유효하지 않을 수 있다는 점이다.

  - 점프와 엎드리기 동시에 참 불가.

- 여러 플래그 변수 중 하나만 참일 경우 열거형(enum)을 사용하는 것이 좋다.

<details><summary><font color = "green">열거형 사용</font></summary>
<div markdown="1">

```cpp
enum State
{
  STATE_STANDING,
  STATE_JUMPING,
  STATE_DUCKING,
  STATE_DIVING
};
```

- 먼저 상태에 따라 분기하게 했다.
  - 이제 플래그 여러개 대신 state\_ 필드 하나만 있어도 됨.

```cpp
void Heroine::handleInput(Input input)
{
  switch (state_)
  {
    case STATE_STANDING:
      if (input == PRESS_B)
      {
        state_ = STATE_JUMPING;
        yVelocity_ = JUMP_VELOCITY;
        setGraphics(IMAGE_JUMP);
      }
      else if (input == PRESS_DOWN)
      {
        state_ = STATE_DUCKING;
        setGraphics(IMAGE_DUCK);
      }
      break;

    case STATE_JUMPING:
      if (input == PRESS_DOWN)
      {
        state_ = STATE_DIVING;
        setGraphics(IMAGE_DIVE);
      }
      break;

    case STATE_DUCKING:
      if (input == RELEASE_DOWN)
      {
        state_ = STATE_STANDING;
        setGraphics(IMAGE_STAND);
      }
      break;
  }
}
```

- 분기 문을 다 없애진 못했지만, 업데이트해야 할 상태변수를 하나로 줄였고, 하나의 상태를 관리하는 코드는 한곳에 있다.

  - 열거형은 상태 기계를 구현하는 가장 간단한 방법이다.
    </div>
  </details>

  - 열거형만으로 부족할 수 있다.

- 이동을 구현하고, 엎드려있으면 기가 모여, 놓는 순간 특수 공격을 쏠 수 있게 만들면, 엎드려서 기를 모으는 시간 또한 기록해야한다.

- c

## **The State Pattern**

### **A state interface**

### **Classes for each state**

### **Delegate to the state**

## **Where Are the State Objects?**

### **Static states**

### **Instantiated states**

## **Enter and Exit Actions**

## **What’s the Catch?**

## **Concurrent State Machines**

## **Hierarchical State Machines**

## **Pushdown Automata**

## **So How Useful Are They?**

## **출처**

[State](https://gameprogrammingpatterns.com/state.html)
