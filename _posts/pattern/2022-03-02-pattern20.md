---
title: "[게임 프로그래밍 패턴] Optimization Patterns: Spatial Partition"
date: 2022-03-02T16:4:5Z
category: pattern
tags:
---

# **Spatial Partition**

---

- 객체를 효과적으로 찾기 위해 객체 위치에 따라 구성되는 자료구조에 저장한다.

## **Motivation**

---

- 현실감을 제공하는 요소 중 하나: **위치**(location)
  - **공간(space)** 개념: 객체는 공간 어딘가의 위치에 존재하게 된다.
  - 위치(location) 개념: 여러 형태로 확인 가능
    - 물리 충돌 or 오디오(거리에 따른 소리조절)
- 이를 위해 '주변에 어떤 객체들이 있는지' 알아야한다.
  - 매 프레임마다 이를 확인 == 성능 병목

### **전장 위의 유닛들**

- RTS 게임을 만든다고 해보자.
  - 전장에는 수백이 넘는 유닛들이 싸운다.
  - 근접 유닛은 공격하기 전에 적이 어디에 있는지를 알아야 한다.
- 이를 단순하게 구현해보면 다음과 같다.(이중 포문)

```cpp
void handleMelee(Unit* units[], int numUnits)
{
  for (int a = 0; a < numUnits - 1; a++)
  {
    for (int b = a + 1; b < numUnits; b++)
    {
      if (units[a]->position() == units[b]->position())
      {
        handleAttack(units[a], units[b]);
      }
    }
  }
}
```

- 이러면 유닛 수가 많아질 때 검사 횟수가 엄청아네 많아진다.
  - 매 프레임마다 유닛 개수의 제곱만큼 검사하게됨.

### **1차원 전장**

- 문제는 배열에 들어 있는 유닛이 따로 정렬되어 있지 않다는 것.
  - 유닛을 찾으려면 전체 배열 다 순회해야함.
  - 문제를 단순화하기 위해 1차원으로 생각해보자

![](https://gameprogrammingpatterns.com/images/spatial-partition-battle-line.png)

- 위와 같으면, 위치를 기준으로 `정렬`하고 전체 배열을 다 조회하지 않고도 이진 검색 같은 걸로 주변 유닛을 쉽게 찾을 수 있다.

- 이렇게 위치에 따라 구성되는 자료구조에 객체를 저장 => 빠르게 검색 가능
  - 이걸 2차원 이상의 공간에 적용한 것이 `공간 분할 패턴`이다.

## **The pattern**

---

- `객체들은 공간 위에서 위치 값`을 갖는다.
  - `공간 자료구조`: 객체 위치에 따라 구성됨
  - **같은 위치 혹은 주변 객체를 빠르게 찾을 수 있다.**
  - 위치 변경 => 공간 자료구조도 업데이트

## **언제 사용**

---

- 공간 분할 패턴은 움직이는 게임 객체뿐만이 아니라 정적인 프랍이나 지형을 저장할 때

  - 복잡한 게임에는 콘텐츠별로 공간 분할 자료구조를 따로 두기도 한다.

- 위치 값이 있는 객체가 많고, 위치에 따라 객체를 찾는 쿼리가 성능에 영향을 줄만큼 잦을 경우

## **주의사항**

---

- 객체가 많을 때만 의미가 있다.

  > 이진검색 O(log n), 전체 검색 O(nlogn), 비둘기집 정렬 같은 기법을 사용하면 O(n)

- 공간 분할 패턴 == 객체를 위치에 따라 정리 == 위치 변경 복잡함.
  - CPU도 더 소모
  - 추가 메모리가 더 필요.

## **예제 코드**

---

## **디자인 결정**

---

## **관련자료**

---

## **출처**

---

[spatial-partition](https://gameprogrammingpatterns.com/spatial-partition.html)
