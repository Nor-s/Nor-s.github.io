---
title: "[게임 프로그래밍 패턴] Squencing Patterns: Double Buffer"
date: 2022-02-22T21:52:46Z
category: pattern
tags:
---

# **순서 패턴(Squencing Patterns)**

- 게임 월드에서 중요한 축: "시간"
- 게임 월드 시간을 위한 패턴들
- 게임 루프 패턴: 게임 월드 시간이 돌아가는 중심축
- 업데이트 메서드 패턴: 객체의 시간을 다루는 패턴
- 더블 버퍼 패턴: 순간적인 스냅샷들의 정면(facade)을 뒤로 숨김

# **Double Buffer**

- 의도: 여러 순차 작업의 결과 한번에 보여줌.

## **Motivation**

### **How computer graphics work (briefly)**

- 모니터: 왼->오 픽셀 그림.
- 프레임버퍼: 픽셀을 가져오는 곳
- 비디오 디스플레이는 프레임 버퍼를 반복해서 읽는다.
  - 문제: 화면 찢김(tearing), 코드에서 픽셀을 입력하는 속도보다 비디오 드라이버가 앞지름.

![](https://gameprogrammingpatterns.com/images/double-buffer-tearing.png)

- 문제 해결: 비디오 드라이버는 한번에 전체 픽셀을 다 읽어야함
  - 프레임 버퍼 두개 => 하나는 프레임에 보이는 것으로 GPU가 언제든지 읽을 수 있는 것.
  - 화면 깜빡임에 맞춰 버퍼 변경 => 테어링 문제 해결 -결

## **The Pattern**

- 버퍼 클래스: 변경이 가능한 상태인 버퍼를 캡슐화
- 정보를 읽을 때: 항상 **current**버퍼에 접근.
- 정보를 쓸 때 **next**버퍼에 접근

## **When to Use It**

- 순차적으로 변경해야하는 상태
- 변경 도중에 접근 가능해야함.
- 바깥에서는 작업 중인 상태에 접근하지 못하도록
- 상태에 값을 쓰는 도중에도 기다리지 않고 바로 접근 가능해야할 때

## **Keep in Mind**

- 코드 전체에 미치는 영향이 적음.

### **교체 연산 자체에 시간이 많이 걸림**

- 교체: 원자적(atomic)이어야함.
  - 교체 중에는 두 버퍼 모두에 접근 불가능
  - 대부분 포인터만 변경, 하지만 혹시 모른다.

### **버퍼가 두개 필요**

- 메모리 부담

## **예제**

- 단순한 그래픽 시스템

```cpp
class Framebuffer
{
public:
  Framebuffer() { clear(); }

  void clear()
  {
    for (int i = 0; i < WIDTH * HEIGHT; i++)
    {
      pixels_[i] = WHITE;
    }
  }

  void draw(int x, int y)
  {
    pixels_[(WIDTH * y) + x] = BLACK;
  }

  const char* getPixels()
  {
    return pixels_;
  }

private:
  static const int WIDTH = 160;
  static const int HEIGHT = 120;

  char pixels_[WIDTH * HEIGHT];
};
```

-
