<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[UE4] 언리얼 엔진에 오신 것을 환영합니다" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="언리얼 엔진에 오신 것을 환영합니다." /><meta property="og:description" content="언리얼 엔진에 오신 것을 환영합니다." /><link rel="canonical" href="https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/" /><meta property="og:url" content="https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/" /><meta property="og:site_name" content="RohRoh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-18T05:36:17+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[UE4] 언리얼 엔진에 오신 것을 환영합니다" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"dateModified":"2022-03-11T16:10:28+09:00","datePublished":"2022-02-18T05:36:17+09:00","description":"언리얼 엔진에 오신 것을 환영합니다.","mainEntityOfPage":{"@type":"WebPage","@id":"https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/"},"url":"https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/","@type":"BlogPosting","headline":"[UE4] 언리얼 엔진에 오신 것을 환영합니다","@context":"https://schema.org"}</script><title>[UE4] 언리얼 엔진에 오신 것을 환영합니다 | RohRoh</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RohRoh"><meta name="application-name" content="RohRoh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/commons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">RohRoh</a></div><div class="site-subtitle font-italic">my blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Nor-s" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[UE4] 언리얼 엔진에 오신 것을 환영합니다 </span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[UE4] 언리얼 엔진에 오신 것을 환영합니다</h1><div class="post-meta text-muted"><div> <em> <a href="https://github.com/Nor-s">roh</a> </em></div><div class="d-flex"><div> <span> <em class="timeago" date="2022-02-18 05:36:17 +0900" data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 18, 2022, 5:36 AM +0900" >Feb 18</em> </span> <span> Updated <em class="timeago" date="2022-03-11 16:10:28 +0900 " data-toggle="tooltip" data-placement="bottom" title="Fri, Mar 11, 2022, 4:10 PM +0900" >Mar 11</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="17939 words"> <em>99 min</em> read</span></div></div></div><div class="post-content"><ul><li><p><a href="https://learn.unrealengine.com/home/learningPath/119025">언리얼 엔진에 오신 것을 환영합니다.</a></p><li><p>언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서.</p></ul><h1 id="언리얼-엔진4와의-첫시간">언리얼 엔진4와의 첫시간</h1><h2 id="머티리얼">머티리얼<a href="#머티리얼"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>메시의 외관에 영향을 주는것.</p><li><p>머티리얼은 라이팅에 반응항다.</p><li><p>뭔가를 보려면 라이트가 있어야한다.</p></ul><h2 id="directional-light">Directional Light<a href="#directional-light"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>태양을 시뮬레이션하는 아이템</ul><h2 id="디폴트-캐릭터">디폴트 캐릭터<a href="#디폴트-캐릭터"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>어딘가에 스폰된다.</p><li><p>플레이어 스타트나 카메라 위치(뷰포트의)에 스폰된다.</p><li><p>액터배치-&gt; 기본 -&gt; 플레이어 스타트</p><li><p>플레이어 스타트의 파란색 화살표가 정면을 뜻함.</p><li><p>플레이어 스타트의 위치를 조정할 때 플레이어가 바닥과 겹치면 BAD SIZE가 표시됨.</p></ul><h2 id="스카이-애트머스피어">스카이 애트머스피어<a href="#스카이-애트머스피어"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>월드의 가장 윗부분이나 대기를 나타냄</p><li><p>디렉셔널 라이트에서 애트머스피어의 작동방식을 결정해야함.</p><ul><li>sun light 설정: 디렉셔널 라이트가 애트머스피어와 상호작용할 수 있게 해줌<li>태양이 디렉셔널 라이트에 따라 회전한다.</ul></ul><h2 id="light">light<a href="#light"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>디렉셔널 라이트 -&gt; intensity 조절하여 밝기 설정<li>이미시브 라이팅 사용 =&gt; self-lit : lighting 영향 받지 않음, 전체적인 광원이 없어도 보임.<li>sky light =&gt; 앰비언트 라이트: 어두운곳의 밝기, 그림자 속 라이트, 어떤 것 뒤의 라이트<li>그림자 속 라이팅 : 앰비언트, 바운스 라이팅처럼 어디든 있는 라이팅<ul><li>이 밝기는 장소에 따라 밝기가 달라짐, 자동노출(auto exposure)이나 시각 순응(eye adaptation)<li>어두운곳에 가면 이 라이트는 밝아짐, 밝은 곳으로 가면 어두워짐</ul><li>PostProcessVolume: Lens의 Exposure 에서 최소 최대 밝기. -&gt; 범위== 이펙트의 차이<ul><li>1로 최대최소 설정해주면 어두운부분이 약간 어두워지고, 밝은곳은 더 어두워지지않음</ul><li>라이트 블룸, 오클루전 라이트 새프트<ul><li>라이트 새프트: 디렉셔널 라이트에서 shaft occlusion, shaft bloom 설정하면 빛줄기가 생김. tint를 설정하여 푸른 안개 효과 낼 수 있음</ul></ul><h3 id="모빌리티-세팅">모빌리티 세팅<a href="#모빌리티-세팅"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>씬에서 라이팅이 어떻게 쓰이는지를 결정한다.<li>movable: 완전히 동적이라는 뜻, 모든것에 새도우, 실시간으로 라이팅이 적용됨, 퍼포먼스 가장 많이 소비<ul><li>모든 프레임이 정보를 하나하나 계산한다.</ul><li>static: 프로젝트가 돌아가기 전부터 모든게 미리 결정, 프레임마다 계산할 필요가 없음. 퍼포머스 가장 적음.<ul><li>라이트 맵을 사용한다거나, 굽는다고 함.<li>이 세팅을 키면 화면 위에 라이팅을 다시 빌드해야 뜸.</ul><li><p>stationary: 두 옵션을 섞은것</p><li>프리뷰가 그림자에 나타나면 -&gt; 빌드 -&gt; 라이팅 빌드</ul><h2 id="블루프린트">블루프린트<a href="#블루프린트"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>블루프틴트는 요소의 모음, mesh일 수 도 있다.(Viewport)</p><li><p>뷰포트에서 구체는 콜리전, 플레이어가 밟으면 이벤트 발생</p><li><p>뭔가를 재사용하기 좋다.</p><li>에딧 -&gt; 프로젝트 세팅<ul><li>맵&amp;모드와 입력이 중요<li>맵모드: 일부 게임 프레임워크나 언리얼 엔진의 유용한 기능을 설정한다.<ul><li>디폴트 폰 또는 디폴트 플레이어, 화면 뒤의 사람을 나타내는 디폴트 대상이 뭔지 등에 대해, HUD가 있는지, 컨트롤러 클래스가 뭔지(캐릭터에 대한 입력을 모방)</ul><li>입력: 입력세팅=&gt; 커스텀 캐릭의 세팅과 기본 세팅과 일치하게 해야한다.<ul><li>동일한 키와 입력에 여러 입력을 매핑할 수 있다.</ul></ul><li>캐릭터 컴포넌트 -&gt; 여러 변수 설정 가능(점프 최대 높이 등)</ul><h2 id="월드-아웃라이너">월드 아웃라이너<a href="#월드-아웃라이너"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>월드를 구성하는 모든 액터가 포함되어있는 패널<li>폴더생성가능 (폴더 삭제시 계층 구조의 루트로 다시 돌아감.)<li>부모-자손관계를 사용할 수 있음<ul><li>라이트를 블루프린트로 드래그하여 자손으로 종속시키면, 함께이동</ul><li>한번에 여러 항목 영향: 전부 선택 -&gt; 우클릭, 그룹선택 or 컨트롤 G</ul><h2 id="디테일-패널">디테일 패널<a href="#디테일-패널"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>현재 선택된 항목과 컴포넌트, 그리고 그 프로퍼티를 표시<li>프로퍼티 값을 변경하고, 컴포넌트를 추가하고, 선택된 항목을 블루프린트로 변환<li><p>다수의 디테일 패널을 사용하여 항목간의 프로퍼티를 서로 맞춤.</p><li>Show hidden properties while playing: 플레이 도중 숨겨진 프로퍼티 표시<li>한 아이템의 프로퍼티를 다른 프로퍼티로 복사<ul><li>에디터에는 프로퍼티 매트릭스가 있음. (눈동자 모양 옆에 있는 프로퍼티 매트릭스-&gt; 선택 열기)<li>선택한 아이템과 공통 프로퍼티가 표시 -&gt; 한번에 모두 같이 변경 가능</ul><li>두 개의 다른 아이템 옵션 비교<ul><li>window-&gt;details 에서 디테일 패널을 4개 까지 열 수 있음.<li>디데일창의 락버튼을 사용하여 비교</ul><li>오브젝트 프로퍼티와 옵션이 표시, 런타임이나 에디터에서 확인하거나 변경 가능.</ul><h2 id="문제1">문제1<a href="#문제1"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>씬에 게임 안에서 볼 때만 실행되는 파티클 이펙트가 있습니다. 파티클 이펙트 실행을 확인하는 가장 빠른 방법은 무엇일까요?<ul><li>G키 게임뷰</ul></ol><h1 id="언리얼-엔진-소개">언리얼 엔진 소개</h1><h2 id="모드-패널">모드 패널<a href="#모드-패널"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>왼상단<li>윈도우 -&gt; 모드<li>모드 설정 -&gt; 랜드스케이프, 폴리지 시 아웃라이너, 뷰포트 설정 못함<ul><li>적절한 모드 사용, 실수할 가능성 높음</ul></ul><h2 id="콘텐츠-브라우저">콘텐츠 브라우저<a href="#콘텐츠-브라우저"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>저장장치, 파일구조<li>프로젝트에 포함된 파일들<li>윈도우 -&gt; 콘텐츠 브라우저: 창을 4개까지 추가 가능<li>폴더에 우클릭, 색변경가능.<li>view type-show<ul><li>developer content: 나만의 전용 콘텐츠로 임시 영역과 같다.<ul><li>프로젝트에 문제가 발생하길 원하지 않을 경우</ul><li>엔진 콘텐츠: 엔진에서 제공되는 콘텐츠.<ul><li>간편하게 바로 쓸 수 있는 콘텐츠가 많음.</ul></ul><li>컬렉션<ul><li>정적: 구성 가능한 항목에 대한 바로가기 옵션<li>동적: 검색</ul></ul><h2 id="메인툴바">메인툴바<a href="#메인툴바"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>프로젝트 작업시 사용함<li>아이템생성, 월드 생성<li>소스콘트롤: git<li>세팅: 프로젝트, 에디터, 플러그인<ul><li>기본적으로 반투명 아이템은 선택 불가능 (마티리얼이 반투명), 세팅에서 허용 설정(allow translucent selection), T키<li>엔진 퀄리티 세팅: 변경내용은 에디터에만 영향, 최종 제품에 영향 x(머티리얼 퀄리티 또한 마찬가지)<li>사운드 조절(게임 플레이시 제외한 사운드 크기)</ul><li>레벨 블루포인트: 레벨에서 직접 액터와 같은 오브젝트를 참조, 연속된 블루프린트를 트리거링 또는 시네마틱 기능에 사용.<li>play-&gt;시뮬레이션: 씬에서 시뮬레이션 설정을 킨다.<ul><li>뷰포트에서 시뮬레이션 보기 가능(실행중인 피직스나 파티클 )</ul></ul><h2 id="세팅">세팅<a href="#세팅"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="에디터-개인설정-창">에디터 개인설정 창<a href="#에디터-개인설정-창"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>에디터가 작업을 수행하고 작동하는 방식에 대한 개인 설정, 세팅, 옵션을 변경할 때<li>편집-&gt; 개인설정-&gt; 에디터 개인설정</ul><h3 id="프로젝트-세팅">프로젝트 세팅<a href="#프로젝트-세팅"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>게임 모드를 오버라이드하여 전체 프로젝트에 적용가능<li>편집-&gt; 프로젝트 세팅 or 툴바 -&gt; 세팅-&gt;프로젝트 세팅<li>게임<ul><li>게임전용프레임워크 세팅</ul><li>엔진<ul><li>프로젝트에 대해 엔진이 어떻게 설정되었는지<li>입력이나 렌더링 설정방식</ul><li>에디터<ul><li>프로젝트에서 에디터 각 부분을 처리하는 방식</ul><li>플랫폼<ul><li>모든 플랫폼마다 고유의 아이템이 있음.</ul><li>플러그인<ul><li>플러그인별로 프로젝트 고유의 세팅을 조정</ul></ul><h4 id="프로젝트">프로젝트<a href="#프로젝트"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>프로젝트 이름, 퍼블리셔, 관련 정보들<li><strong>맵모드</strong><ul><li>멀티플레이어가 분할화면을 사용하는지 등.<li>Game Instance class</ul><li>패키징<li>플랫폼 지원 설정</ul><h4 id="엔진"><strong>엔진</strong><a href="#엔진"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>콜리전<ul><li>피직스를 사용할 때 아이템이 서로 상호작용할 때 사용됨.<li>특정 아이템만 충돌하게 할 경우, 기본 콜리전은 제대로 작동하지 않을 수 있다.</ul><li>인풋<ul><li>점프 이동 마우스 등 세팅<li>마우스로 터치 시뮬, 기본 가상 조이스틱(모바일)</ul><li>렌더링<ul><li><strong>default</strong> <strong>setting</strong> : 기본적으로 Bloom 활성화, Ambient Occlusion 활성화, Auto Exposure, Motion Blur 세팅<li>포스트 프로세서 이펙트를 사용하거나, 카메라나 다른 세팅을 직접 조정하는것 대신 가능</ul></ul><h4 id="에디터">에디터<a href="#에디터"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>레벨 시퀀스 세팅</ul><h4 id="플랫폼">플랫폼<a href="#플랫폼"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>플랫폼별 세팅 가능<ul><li>direct, opengl, vulkan 설정</ul></ul><h3 id="월드-세팅">월드 세팅<a href="#월드-세팅"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>현재 작업중인 레벨 고유의 세팅을 조정하거나, 오버라이드할 수 있다.<li>윈도우-&gt; 월드 세팅, 툴바 -&gt; 세팅 -&gt; 월드 세팅</ul><h4 id="월드">월드<a href="#월드"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Kill Z 조정<ul><li>세로축, 액터가 이 기준 이하면 사라짐</ul></ul><h4 id="게임모드">게임모드<a href="#게임모드"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>기본 게임 모드를 오버라이드<li>메인 메뉴가 있지만 일반게임모드에서 모든 기능이 다 필요하지는 않을 경우<ul><li>새로운 게임 모드를 만들고, GameMode Override를 해당 레벨에만 설정하는 것.</ul></ul><h4 id="lightmass">Lightmass<a href="#lightmass"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>라이트매스 시스템은 양질의 결과를 제공할 수 있도록 설정되어있음.<li>라이트매스 시스템은 정적인 빌드된 라이팅.<li>라이팅을 빌드하고 굽는데 이 시스템이 사용된다.<li><p>이 세팅을 오버라이드하여 라이팅 퀄리티 개선,</p><li>구워진 라이팅을 사용하고 있지 않으면, 이 섹션은 걱정하지 않아도 된다.<li>대안은 Lightmaps =&gt; Force No Precomputed Light =&gt; 리빌드<li>이렇게하면 공간에 약간의 여유가 생긴다.(빌드된 라이트맵이 삭제되기 때문.)</ul><h4 id="physics">Physics<a href="#physics"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>기본 중력값 설정(오버라이드) 가능<ul><li>water world를 설정할 경우 이 레벨의 중력값을 변경하려면, 이 설정을 변경하면됨.</ul></ul><h4 id="vr시스템옵션">VR시스템옵션<a href="#vr시스템옵션"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>World to Meters 월드 스케일 같은 기본설정을 변경할 수 있다.</ul><h4 id="tick">Tick<a href="#tick"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>레벨기준으로 설정<li>이 레벨에서는 틱속도를 조정할 수 있다.<li>Mini/Max Global Time Dilation을 설정, Allow Tick Before Begin을 설정하면 시작전 틱을 허용할 수 있음.<li><p>이 설정은 월드 세팅에서 오버라이드할 수 있다.</p><ul><li>월드세팅은 작업중인 레벨 고유의 세팅창으로 여기에서 레벨 전용 세팅을 오버라이드하고 조정할 수 있다.</ul></ul><h2 id="문제2">문제2<a href="#문제2"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li><p>프로젝트에 독립 게임 모드가 필요한 메뉴에 쓸 레벨이 있습니다. 에디터 어디서 이 게임 모드를 설정할까요?</p><ul><li>월드 세팅</ul><li><p>에디터 실행 -&gt; 기본으로 어떤 맵파일을 로드하도록 : 맵 모드 세팅</p></ol><h1 id="프로젝트-및-파일-구조-이해">프로젝트 및 파일 구조 이해</h1><h2 id="uproject">.uproject<a href="#uproject"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>이 프로젝트가 엔진과 상호작용하는 방식에 대한 기본 설정을 포함<ul><li>버전, 플러그인, c++용 모듈, 플랫폼 등</ul><li>게임을 실행할 수 있음.<ul><li>명령줄에 의해 실행되는 것으로 에디터에서 실행되는것과 동일</ul><li>엔진 버전 변경가능<ul><li>에셋은 이전 버전과 호환되지 않음(주의)</ul><li>소스cpp =&gt; vs 프로젝트 생성 가능<ul><li>.uproject에 모듈이 생겨남. =&gt; 이 프로젝트와 연관시킬 코드<li>모든 모듈 및 타깃, 프로젝트와 연관된 모든 소스코드를 찾아냄<li>무언가를 활성화 하거나 비활성화 할 경우에만 편집<li>플러그인 활성화 여부 확인 가능</ul></ul><h2 id="프로젝트-폴더-구조">프로젝트 폴더 구조<a href="#프로젝트-폴더-구조"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="기본-구조">기본 구조<a href="#기본-구조"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>CONFIG: 프로젝트별로 제어할 수 있는 설정<li>CONTENT: 프로젝트의 모든 콘텐츠가 들어있다.<ul><li>collections, developers (콘텐츠 브라우저의 컬렉션 표시등): 바로가기나 스크래치 파일</ul><li>SAVED: Intermediate폴더와 비슷, 확실한 경우가 아니면 제거x, 일단 삭제하면 그 안에 있던 내용물 재생성 불가, 게임의 실행 로그등,<ul><li>장애가 발생할 경우 엔진은 이 폴더를 살펴봄, 파일 및 폴더 복구를 시도.</ul><li>SOURCE: C++소스, 이 폴더가 없다면 프로젝트가 제대로 컴파일 x<ul><li>일부 코드가 제대로 작동 x, 뭔가 변경, 프로젝트 리셋 =&gt; 이 폴더를 삭제하는 방법(.uproject에서 모듈제거 ) =&gt; 블루프린트만 있는 프로젝트로 리셋 (비권장)</ul></ul><h4 id="삭제-가능한-파일-및-폴더">삭제 가능한 파일 및 폴더<a href="#삭제-가능한-파일-및-폴더"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>INTERMEDIATE: 프로젝트를 작성하고 엔진을 사용하는 중간단계에 사용하는 임시파일과 폴더를 보관 (삭제하면 프로젝트를 다시열 때 시간이 더 걸림, 매번 재생성, 교체 )<li>vs 솔루션 파일(모듈감지, 다시 생성됨)<li>.vs 폴더 (자동완성을 위한 임시 데이터, 기타 VS기능들)<li>Binaries는 임시폴더.<ul><li>컴파일된 바이너리 코드, C++ 소스 모듈과 dll 파일<li>프로젝트를 컴파일할 때 생성.<li>프로젝트가 제대로 패키징되지 않는 문제 -&gt; 이 폴더를 삭제하면 해결될 수 있음.(프로젝트 리셋)</ul></ul><h3 id="캐시에-저장된-다운로드">캐시에 저장된 다운로드<a href="#캐시에-저장된-다운로드"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>프로젝트를 만들거나, 엔진에 아이템을 설치해야 아이템이 다운로드됨<li>런처 설정-&gt; edit vault cache location : 기본 캐시 폴더</ul><h3 id="ddc-폴더">DDC 폴더<a href="#ddc-폴더"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>파생 데이터 캐시: 타깃 플랫폼에 대해 UE가 사용하는 특정 포맷, 에셋의 버전을 저장하는 캐시.<li>프로젝트 시작시간을 단축시켜줌<li>Appdata&gt;local&gt;unrealengine<li><p>프로젝트 재실행시 셰이더를 다시 컴파일할 필요가 없음</p><li>각 버전에 대한 디렉터리, common 디렉터리<li>DDC는 자체적으로 재생성, 필요에 따라 최신상태를 유지<li>필수는 아님, 재생성됨<li>폴더로 구성할 수 있으므로 공유할 수 있음(프로젝트 작업에 참여하는 사람들 모두가 같은 ddc사용 ) =&gt; 필요한 시간 단축</ul><h1 id="더-나은-파이프라인-구축"><strong>더</strong> <strong>나은</strong> <strong>파이프라인</strong> <strong>구축</strong></h1><hr /><ul><li>총 4가지 주제<ul><li>Working with Others<li>Building Better 3D Meshes &amp; Textures<li>Creating Materials &amp; Material Instances<li>Performance &amp; Optimization</ul></ul><h2 id="소스컨트롤"><strong>소스컨트롤</strong><a href="#소스컨트롤"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>대부분 Perforce 와 Subversion을 사용한다.<ul><li>데이터 동기화, push, pull, revert, add, remove data</ul><li>반드시 최종 애셋만을 임포트해야함<ul><li>같은 메시의 다른 버전을 임포트하지말아야함.</ul></ul><h2 id="더-나은-3d-메시와-텍스처1"><strong>더 나은 3D 메시와 텍스처1</strong><a href="#더-나은-3d-메시와-텍스처1"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>명명 규칙, 알파 정보와 RGB 마스크 패킹, 처리하는 방법 등.<li>UE4로 임포트할 수 있는 다양한 텍스처 자장 포맷에 대해<li>밉맵, 임포트, 텍스처 그룹의 용도<li>텍스처 압축</ul><h3 id="naming-conventions"><strong>Naming</strong> <strong>Conventions</strong><a href="#naming-conventions"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><code class="language-plaintext highlighter-rouge">SM_Rock_00</code> : 스태틱 메시, 00 버전<ul><li>좋은 명명 규칙=&gt; 파싱 가능, 어떤 파이프라인에 연결하여 정보 추출가능</ul><li><p><code class="language-plaintext highlighter-rouge">T_Rock_00_BC</code>: Base Color Texture</p><li><code class="language-plaintext highlighter-rouge">SKM_RockBunch_00</code>: Skeletal Mesh</ul><h3 id="텍스쳐-제작"><strong>텍스쳐 제작</strong><a href="#텍스쳐-제작"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>텍스처는 항상 2의 제곱이어야함(x와 y축이)<ul><li>16x256 등<li>이 텍스처가 마지막에 메모리로 패킹되는 방식과 밉맵이나 텍스처 스트리밍 같은 언리얼의 내장 최적화에서 활용되는 방식이기 때문<li>언리얼의 스트리밍 시스템에 사용되기 위해, 밉햅을 사용하기 위해 =&gt; 퍼포먼스 좋음.(거리에 따라 적절한 크기의 텍스처 생성 가능)</ul></ul><h3 id="알파-정보-처리방법"><strong>알파 정보 처리방법</strong><a href="#알파-정보-처리방법"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>두 가지 방법</p><ul><li>삽입된 알파(Embed Alpha) : 독립된 알파보다 비용이 두배<ul><li>해당 텍스처에 저장된 정보인 알파 채널이 압축되지 않은 채 언리얼로 들어오기 때문.<li>임포트될싶대 전체 해상도를 얻게됨: 해당 텍스처의 비용이 두 배라는 것.</ul><li>독립된 알파(Separate Alpha):<ul><li>베이스 컬러 사이즈로부터 알파 채널 사이즈를 독립적으로 제어할 수 있다는 점.</ul></ul><li>프로젝트 실행을 좀 빠르게 하고 싶을 경우<ul><li>모든 알파맵의 사이즈를 줄임<ul><li>삽입된 알파 =&gt; LOD 바이어스 5 =&gt; 알파의 크기가 작아짐 =&gt; 원하는대로 리소스 사이즈가 줄어든다. =&gt; 하지만 외형은 박살(베이스 컬러 역시 픽셀화됨)<li>독립된 알파 =&gt; 조금 픽셀화 =&gt; 베이스 컬러는 거의 유지 =&gt; 알파 채널 정보를 정말 저렴하게 만들면서, 베이스 컬러 정보는 정확히 동일하게 유지</ul></ul><li>두 방법을 선택하는 것은 프로젝트와 워크플로에 달려있음.<ul><li>처음부터 독립된 알파를 사용하면 기존의 것 수정할 필요 없이, 퍼포먼스 문제를 확실하게 해결</ul></ul><h3 id="rgb-마스크-패킹"><strong>RGB 마스크 패킹</strong><a href="#rgb-마스크-패킹"><i class="fas fa-hashtag"></i></a></h3></h3><p>프로젝트 전체에 사용되는 텍스처의 양과 메모리를 줄이는 방법.</p><ul><li>다양한 텍스처들 =&gt; RGB와 가끔은 텍스처의 알파 채널로 저장<ul><li>Texture Sample 채널의 핀에서 이런 다양한 정보를 얻을 수 있음.</ul><li>주로 VFX나 정말 높은 수준의 표면 디테일이 필요할 때, 그리고 일부 캐릭터 모델에 사용함<li>주의: 현재 사용하고 있는 채널의 흑백 정보만을 얻는다는점<ul><li>컬러정보를 얻으려면 이 결과에 특정 유형의 컬러 파라미터를 곱해 주어야하나.</ul><li>참고: 텍스처 프로퍼티 자체에서 sRGB를 반드시 비활성화 해야한다.<ul><li>이걸 머티리얼에서 사용할 때는 sampler type이 masks로 설정되어야한다.<li>이유: sRGB를 비활성화하면, 해당 텍스처의 감마 보정도 비활성화 되기 때문<ul><li>마스크 텍스처는 픽셀의 표시 여부를 정의하고 있기 때문에 감마보정이 되어서는 안됨.(이 정보가 단순히 렌더러에게 뭔가 표시될지의 여부만을 알려주기 때문.)</ul></ul></ul><h3 id="saving-textures"><strong>Saving Textures</strong><a href="#saving-textures"><i class="fas fa-hashtag"></i></a></h3></h3><p>UE4에서 지원하는 다양한 텍스처 포맷</p><ul><li>BMP<li>FLOAT<li>PCX<li>IPG<li>EXR<li>DDS - cubemap Texture(32 bits/channel 8.8.8 ARGB32bpp, unsigned)<li>HDR - Cubemap Texture(longlat unwrap) =&gt; 2의 제곱 규칙을 따를 필요가 없음.<li><strong>embed</strong> <strong>alpha</strong> 지원<ul><li><strong>PNG</strong><li><strong>PSD</strong><li><strong>TGA</strong></ul></ul><h3 id="mip-mapping"><strong>Mip Mapping</strong><a href="#mip-mapping"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>프로젝트가 작동되는 데 중대한 역할.</p><li><p>텍스처의 레벨 오브 디테일</p><li><p>밉맵생성 == 텍스처를 UE4로 임포트할 때 발생</p><ul><li>특별한 경우가 아니라면 신경 쓸 필요 없다.</ul><li>밉체인: 언리얼로 텍스처를 임포트할 때 자동생성<ul><li>프로젝트를 볼 때 대부분 이 체인에서 2단계나 3단계 쯤의 밉맵을 보게됨</ul><li><p>텍스처가 화면에서 이 텍스처를 전체 해상도로 보여줄 필요가 없음</p><ul><li>거리가 먼 경우, 메모리는 여전히 텍스처를 크게 보여줄 때와 똑같은 비용이 들게됨.</ul><li>밉맵 필터링 == Level of Detail 의 Mip Gen Setting에서, 밉맵이 생성될 때 날카롭게 보이거나, 흐리게 보이도록 할 수 있음.<ul><li>밉맵이 일종의 일렁거림을 일으킬 수 있음.<ul><li>쇠사슬로 연결된 울타리나 전선 메시처럼 작은 선을 가진 애셋에서 보이는 현상<li>멀리 있는 텍스처 =&gt; 계단 현상 or 일렁임 형상 =&gt; Mip Gen Setting을 Sharpen 이나 Blur로 바꿔야함.<li>프로젝트마다 해결할 수도 없을 수도 있다. (계속 세팅을 바꿔보면서 확인해야함)</ul></ul></ul><h3 id="importing-textures"><strong>Importing Textures</strong><a href="#importing-textures"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>윈도우 탐색기 =&gt; 콘텐츠 브라우저에 드래그 드랍<li><p>import 버튼 =&gt; 탐색기 =&gt; 선택 =&gt; 열기</p><li>언리얼엔진은 파일의 특정 값을 보고 노말맵인지 뭔지 알아서 처리<ul><li>어떤 유형의 텍스처를 임포트하든 언리얼은 특정한 텍스처에 특정한 프로퍼티가 적용되어 있어야 한다는 걸 잘안다.<li>임포트되는 노멀맵 : 노멀맵으로 자동 구성</ul></ul><h3 id="texture-groups"><strong>Texture Groups</strong><a href="#texture-groups"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>텍스처가 프로젝트에서 사용되고 표시되는 방식을 관리하는데 도움.</p><li>어떤 유형의 텍스처를 사용하든 그 텍스처의 텍스처 그룹이 있음<ul><li>항상 프로젝트의 텍스처들이 올바른 텍스처 그룹에 있는지 확실하게 확인해야 할 것이다.<li>실제로 그룹 안의 텍스처가 프로젝트에서 그려질 크기를 제어하기 때문.</ul><li>텍스처를 축소하고 확대하는 정도 제어<li><p>GPU를 통해서 텍스처에 적용할 필터링 종류도 제어</p><li><p>Level of Detail에서 결정됨</p><li><p>최소 사이즈와 최대 사이즈를 제어할 수 있다.</p><li>프로젝트에서 텍스처 메모리가 바닥이 나면<ul><li>텍스처 메모리를 좀 되돌릴 수 있을지 실험을 해 봐야한다고 가정<li>텍스처 그룹은 이처럼 리소스와 관련된 대규모의 실험을 비파괴적으로 할 수 있는 좋은 수단.<li>이 system settings 로 모든 TEXTUREGROUP _World 노멀맵에 접근할 수 있으며, LOD 바이어스를 변경하여 이걸 2나 3으로 설정해 밉맵 체인의 2나 3번째의 LOD를 취하게, 그 LOD가 주로 사용되도록 만들 수 있다.<li>대략 2048쯤 되는 텍스처를 취해서 1024나 512 정도로 줄임 =&gt; 줄어든 텍스처로 프로젝트 실행가능 =&gt; 자신이 원했던 퍼포먼스 상 효과를 얻음 =&gt; 원하는거 얻지 못했으면 다시 되돌리기<ul><li>텍스처를 빼고 사이즈를 줄인 후 리임포트하는것보단 싸다</ul></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="n">SystemSettings</span><span class="p">]</span>
<span class="n">TEXTUREGROUP</span> <span class="n">_World</span> <span class="o">=</span> <span class="p">(</span><span class="n">MinLOdSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MaxLOdSize</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">,</span> <span class="n">LODBias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MinMagFilter</span> <span class="o">=</span> <span class="n">aniso</span><span class="p">,</span> <span class="n">MipFilter</span> <span class="o">=</span> <span class="n">point</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="텍스처-압축"><strong>텍스처 압축</strong><a href="#텍스처-압축"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>텍스처 더블클릭 =&gt; 압축 세팅 =&gt; 설정</p><li>UI, 최대 해상도 필요할 경우 =&gt; UI or Vector Displacement<ul><li>전혀 압축되지 않은 텍스처</ul><li>srgb: 활성화된 텍스처에 감마보정<ul><li>하지만 노멀맵, 마스크 텍스처 같은 애셋은 텍스처 정보가 아니라 활용할 렌더러 정보를 포함하기에 이 텍스처에 포함된 정보는 어떤 방법, 형태, 형식으로든 절대 조정되지 않고, 지정된 방식을 정확히 그대로 고수해야함.</ul></ul><h2 id="더-나은-3d-메시와-텍스처2-스태틱-메시"><strong>더 나은 3D 메시와 텍스처2: 스태틱 메시</strong><a href="#더-나은-3d-메시와-텍스처2-스태틱-메시"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>System Units<li>Lightmap UV’s<li>Triangle Counts<li>Collision Meshes<li>Material ID’s<li>What Are LOD’s<li>Pivot Points<li>Creating LOD’s<li>What Are Lightmaps<li>Limiting Overdraw</ul><h3 id="시스템-단위system-units"><strong>시스템 단위(system units)</strong><a href="#시스템-단위system-units"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>어떤 DDC앱을 사용하든 아이템 제작을 시작하기 전에 우선 시스템 단위를 확실하게 구성해야함.<ul><li>(이 강의에선 3d studio max를 사용하지만 모두 적용되는것)<li>우선 시스템단위가 센티미터로 설정됐는지 확인.<li>UE4의 기본 측정단위가 센티미터임.(1 언리얼 유닛 == 1 센티미터)<li>몰입감때문에 이를 언리얼엔진과 DDC앱의 유닛 단위를 맞춰줘야함.</ul></ul><h3 id="triangle-counts"><strong>Triangle Counts</strong><a href="#triangle-counts"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>트라이앵글 수: 퍼포먼스와 연관<li>DDC에서 삼각형 수를 확인하며 작업해야함.<li>너트볼트와 같은 수준까지 디테일을 신경쓰지 않아도 됨.<ul><li>작은 디테일 =&gt; 플레이어도 모름 지나친 폴리곤 낭비</ul></ul><h3 id="material-ids"><strong>Material ID’s</strong><a href="#material-ids"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>모든 머티리얼은 하나 이상의 ID를 가진다.<li>어떤 폴리곤 면에 어떤 머티리얼이 적용되는지를 결정<ul><li>ID가 5개면 렌더링이 5번되어야만 최종적으로 한번 더 렌더링 된 후 표시됨</ul><li>머티리얼 유형: MultiSub-Object Material == 오브젝트에 다수의 머티리얼을 할당할 때<li>ID가 많으면, 렌더링 비용도 증가</ul><h3 id="피벗-포인트"><strong>피벗 포인트</strong><a href="#피벗-포인트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>올바른 피벗포인트를 설정해야함<ul><li>오브젝트의 피벗 포인트 위치 잡아야 원하는 곳에 배치 가능<li>DDC에서 잘 설정하고 작업해야함<li>스케일을 조정할 때 거리또한 스케일됨, 틀어지면 모든 작업이 힘들어짐.</ul></ul><h3 id="what-are-lightmap"><strong>What Are Lightmap</strong><a href="#what-are-lightmap"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>라이트맵: 텍스처의 복잡한 빛과 그림자의 정보를 저장하는 데 사용</p><ul><li>텍스처가 이러한 유형의 데이터를 저장하는 데 저렴하고 좋음<li>복잡한 라이팅 계산을 텍스처에 저장하면, 런타임에 이 정보를 거의 비용없이 얻을 수 있다.</ul><li><p>좋게보이도록, 퍼포먼스 높게 유지하도록, 균형을 맞추게해줌</p><li><p>라이트맵/ 섀도맵</p><ul><li>라이트맵: 일반적인 텍스처와 다르게 생김. 라이트맵의 RGB채널에 다양한 값들이 저장되었기 때문<ul><li>다양한 영역의 라이팅 정보가 모두 서로 다른 R,G,B 채널로 패킹된것</ul><li>섀도맵: 섀도 데이터를 R, G, B채널에 저장한 것</ul></ul><h3 id="lightmap-uvs"><strong>Lightmap UV’s</strong><a href="#lightmap-uvs"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>라이트맵 제작과 주의할 점</p><li>라이트맵은 오브젝트의 모든 면이 0-1 공간에 고유하게 배치되어야함<ul><li>각 면은 고유하게 배치되어야함. UV 아틀라스에서 각자 고유한 공간을 차지해야함.<li>0-1 space: UV 정보 주변에 위치한 정사각형. 모든 UV가 스페이스에 있음.<li>라이트맵을 렌더링할 때 라이트매스가 실제로 신경쓰는 데이터: 0-1 공간안에 있는것뿐, 그 외부 공간의 데이터는 잘라냄<li>0-1공간에서 UV내 각 오브젝트에 각자의 공간을 확보해야함.<li>UV채널 = 2: 라이트맵 UV가 메시의 두 번째 채널에 저장되어야함을 의미 (3DMAX의 채널2는 UE4의 채널1, 언리얼은 0부터 채널 수를 셈)<li>라이트맵이 언리얼로 임포트 될 때 자동으로 언팩됨</ul><li>스태틱 메시 설정 아래에 라이트맵 해상도, 라이트맵 좌표 인덱스가 있음<ul><li>해상도: 메시 선택 =&gt; 디테일 패널 =&gt; Lighting =&gt; Overridden Light Map Res 에서 오버라이드 가능</ul></ul><h3 id="collision-meshes"><strong>Collision Meshes</strong><a href="#collision-meshes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>두 가지 방법으로 만들 수 있음.</p><li><p>자신이 사용하는 DCC에서 콜리전을 만든 다음 지오메트리와 함께 임포트</p><ul><li>콜리전 메시의 구체적인 식별자가 있는 이름을 지어줘야함.<ul><li><code class="language-plaintext highlighter-rouge">UCX_(메시 이름)_(콜리전 번호)</code></ul></ul><li><p>언리얼엔진에서 콜리전을 만들 수 있음</p><ul><li>상단 메뉴바 =&gt; 콜리전 =&gt; 콜리전 메시<li>컨벡스 분해(convex decompos): 콜리전을 만들기 어려운 유기적인 메시에 쓸 복잡한 콜리전을 만들 수 있는 기능<ul><li>윈도우 =&gt; 컨벡스 분해 선택 =&gt; 적용<li>이 기능의 역할: 메시를 복셀화, 그 복셀을 기반으로 콜리전 파라미터를 생성하는 것</ul></ul></ul><h3 id="limiting-overdraw"><strong>Limiting Overdraw</strong><a href="#limiting-overdraw"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>오버드로는 투명 혹은 오파시티를 다룰 때 나타남<ul><li>이 현상은 GPU가 텍스처 곳곳에 다수의 투명을만들거나 여기저기가 뚫려 보이게 해서 유용한 정보를 표시하지 않게한다.<li>오버드로는 다수의 평면을 겹쳐서 실제 나무, 덤불, 잔디 등과 같은 모습을 보여야 하는 폴리지 메시에서 자주 나타남</ul><li>버텍스를 약간 더 사용하거나 평면의 실제 형태를 조정하여 오버드로의 발생량을 줄일 수 있다.<ul><li>버텍스를 몇 개 더 렌더링하는게 엄청난 수의 픽셀을 렌더링 한 다음 버리는 것보다는 싸다.(매프레임마다 하는 작업이므로)</ul><li>오버드로 확인 : UE4의 툴 ‘셰이더 복잡도’라는 모드<ul><li>뷰포트의 Lit =&gt; Optimization Viewmodes =&gt; shader complexity<ul><li>하얀색을 최대한 많이 없애야함.</ul></ul></ul><h3 id="what-are-lods"><strong>What are LOD’s</strong><a href="#what-are-lods"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Level of Detail<li>메시와 같지만 트라이 앵글 수가 더 적고 가끔 머티리얼 인스트럭션 수도 더 적은 사본<li>윤곽선이 같지만 해상도는 낮게<li>일정한 유형의 LOD가 있어야함.<li>LOD 메시는 많이 있어도 되지만. 너무 많아서 프로젝트가 해가되는 시점이 올 수 있음<li>보통 75%, 35%, 12% 까지 메시를 줄임<ul><li>이런 수치는 정해진것은 아니지만, 차이가 나도록 설정해야함.<ul><li>메모리를 아낀다는 목적달성하기 위해</ul></ul></ul><h3 id="creating-lods"><strong>Creating LODS</strong><a href="#creating-lods"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>(3DMax에서)<li>기존 메시 복붙, Modifier 목록에서 Pro-Optimizer를 추가, Caculate 클릭<ul><li>폴리 수 줄이기: Optimization level 에서 vertex% 50%로 설정</ul><li><p>모든 작업 후에 서로 겹침. =&gt; 모두 선택한 후 =&gt; 메뉴바에서 Group =&gt; Group =&gt; 이름 LOD =&gt; Utilities Panel 탭에서 more.. =&gt; LOD 선택 =&gt; Create new set 클릭 =&gt; File 에서 Export</p><li>(언리얼에서)<li>임포트 =&gt; 고급옵션 보기 =&gt; 임포트 옵션 =&gt; 메시 LOD 임포트의 박스 =&gt; 라이트맵 UV 생성은 끔 =&gt; DDC에서 만든 라이트맵 UV 사용<ul><li>메시 LOD임포트를 켜지 않은 상태 =&gt; LOD가 없는 기본 메시만 얻음</ul><li>생성 =&gt; LOD 세팅 =&gt; LOD 그룹 =&gt; LargeProp =&gt; LOD 다수를 자동생성</ul><h2 id="애샛-임포트-익스포트"><strong>애샛 임포트 익스포트</strong><a href="#애샛-임포트-익스포트"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>스태틱 매시 익스포트<li>스켈레탈 메시 익스포트 + 옵션<li>애셋 리임포트<li>자동 리임포트: 폴더를 수신대기 설정 =&gt; 애셋이 변경되면 자동 리임포트<li>FBX 를 통한 씬 전체의 임포트<li>수정할 애셋을 UE4에서 임포트</ul><h3 id="스태틱-매시-익스포트"><strong>스태틱 매시 익스포트</strong><a href="#스태틱-매시-익스포트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>UE4는 스태틱과 스케레탈 메시 모두에 FBX 포맷 사용 (애니메이션 포함)<li><p>FBX: 기본 머티리얼 데이터, 스태틱 메시 데이터 , 기본 머티리얼 데이터와 함께 스킨을 입힌 메시 데이터, LOD, 본 기반 애니메이션 데이터</p><li>스태틱 메시에 선택해야할 FBX 익스포터<ul><li>지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation<li>애니메이션이 있거나 Skeletal mesh에는 animation에 클릭해야함<li>실수로 다른것도 익스포트하지 않도록 주의</ul></ul><h3 id="스케레탈-메시-익스포트"><strong>스케레탈 메시 익스포트</strong><a href="#스케레탈-메시-익스포트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>지오메트리: Smoothing Groups, Triangulate, Preserve Edge Orientation<li><p>애니메이션: animation</p><li>Deformation (Morph 타겟을 익스포트한다면): Deformations, Skins</ul><h3 id="3d-mesh-임포트"><strong>3D Mesh 임포트</strong><a href="#3d-mesh-임포트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>드래그 드랍, 임포트 버튼</ul><h4 id="3d-mesh-임포트-옵션"><strong>3D Mesh 임포트 옵션</strong><a href="#3d-mesh-임포트-옵션"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>대부분은 기본설정으로 충분.<li>콜리전 자동생성: 해당 메시의 콜리전 자동생성<li>라이트맵 UV 생성: 라이트맵 UV 생성, 최고가 아닌 경우가 많음. (강의하는 사람은 비활성화하는 편 ==&gt; DDC에서 모든걸 직접 구성할 경우)<li>버텍스 절대치로 변환: 이 옵션이 꺼지면 콜리전 메시의 피벗 포인트가 전부 0이되어 스태틱 메시 중앙에 놓이게됨<li>머티리얼 임포트, 텍스처 임포트: 보통 비활성화 == 메시 작업 완료와 동시에 임포트와 구성이 될것이기 대문. 테스트 애셋 이 임포트될 수 있음.<li>스켈레톤 메시 에니메이션 임포트: 메시 옵션<li>스켈레톤 메시 활성화, 기존의 스켈레톤을 찾아서 그 애니메이션을 임포트할지 말지 선택<li>나중에 머티리얼과 텍스처를 직접세팅하고 싶기 때문에 머티리얼, 텍스처 임포트 옵션 끔</ul><h3 id="애셋-리임포트"><strong>애셋 리임포트</strong><a href="#애셋-리임포트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>가장 간단하고 빠른 방법: 드래그 드랍 =&gt; 자동으로 업데이트<li>우클릭 =&gt; 리임포트<li>소스파일 경로 =&gt; 리임포트할 때 자동으로 이 경로 팡일로부터 리임포트<li>텍스처 더블클릭 =&gt; 리임포트 =&gt; 파일 탐색기(경로에 해당파일이 없을 경우) =&gt; 설정</ul><h3 id="자동-리임포트-구성"><strong>자동 리임포트 구성</strong><a href="#자동-리임포트-구성"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>에디터 설정 =&gt; General =&gt; Loading &amp; Saving =&gt; Auto reImport =&gt; 폴더 모니터</p><li><p>업데이트가 저장될 폴더 수신대기 =&gt; 자동으로 업데이트 가능.</p><li>이 방법은 소스 컨트롤 없이 작업할 때 사용하기 좋음.<li>협업할 경우 프로젝트에 최신 변경사항을 확실하게 반영시키고 싶을 때 사용하기 좋음.</ul><h3 id="full-scene-import"><strong>Full Scene Import</strong><a href="#full-scene-import"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>FBX 파일의 전체 씬 임포트<li>건축 시각화와 같은 프로젝트 =&gt; 모든 애셋을 가져와서 일일이 정확한 위치에 배치하는 것은 불필요 작업<li>스태틱메시 + 스켈레탈 메시 + 애니메이션 + 머티리얼 + 텍스처 + 리지드 바디 + 모프타깃 + 카메라 + 라이팅 모두 지원<li>머티리얼과 카메라는 일정한 제한이 있음.<ul><li>머티리얼: 디퓨즈와 노멀맵만 가져옴<li>카메라: 애니메이션은 가질 수 없음, UE4에서 구성해야함.</ul><li>3dmax에서 전체 선택 =&gt; 익스포트<li>임포트하면, 전체 씬을 재구성해 블루프린트에 배치해 주어서 씬의 모든 메시를 쉽고 빠르게 업데이트 할 수 있게 해 줌.</ul><h3 id="ue4로부터의-애셋-익스포트"><strong>UE4로부터의 애셋 익스포트</strong><a href="#ue4로부터의-애셋-익스포트"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>애셋이주: UE4 외부에서 콘텐츠를 가져오는 또 다른 방법, 모든 내부 연결을 유지해줌.<ul><li>구 버전의 UE4를 사용했을 때 아주 좋은 방법<li>새 프로젝트에서 열면 텍스처, 머티리얼, 메시 모두의 내부 연결이 유지.<li>Content 폴더에 배치해야함.(안그러면 모든 연결이 망가질 가능성이 큼)</ul><li>애셋 익스포트: 소스 콘텐츠에 접근할 수 없을 경우, 애셋에 아주 미세한 조정만 하고 싶을 경우</ul><h2 id="머티리얼과-머티리얼-인스턴스"><strong>머티리얼과 머티리얼 인스턴스</strong><a href="#머티리얼과-머티리얼-인스턴스"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="what-is-pbr"><strong>What is PBR</strong><a href="#what-is-pbr"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Physically Based Rendering: 빛의 실제 작용을 추정하는 것.<ul><li>더 정확, 더 자연스러운 라이팅<li>모든 라이팅 시나리오에서 똑같이 잘 작동함.<li>시나리오별로 다양한 버전의 라이팅을 만들 필요 없음</ul><li>머티리얼도 평소처럼 복잡해질 필요가 없음.<ul><li>원래 필요했던 머티리얼 인스트럭션 수를 많이 간소화할 수 있다.</ul><li><p>머티리얼 값 훨씬 덜 복잡, 덜 상호의존적/ 더 직관적으로 조정가능</p><li><p>단순히 극 사실적인 렌더링을 돕거나 사실적인 이미지에만 사용할 수 있는 것이 아님.</p><ul><li>만화 기반의 이미지에도 적용 가능</ul><li>아트 프록덕션 파이프라인의 통일에 도움이됨.<ul><li>PBR은 애셋 하나만 있어도 어떤 유형의 라이팅을 받든 정확히 똑같은 방식으로 라이팅에 반응함<li>라이팅 유형 별로 다수의 머티리얼이나 텍스처를 만들필요가 없게됨</ul></ul><h3 id="머티리얼-도메인"><strong>머티리얼 도메인</strong><a href="#머티리얼-도메인"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>각 머티리얼은 도메인과 블렌드 모드 또는 셰이딩 모델만 바꿔서 다양한 필요를 충족시킬 수 있다.<ul><li>이에 따라 일부 기능을 활성화하거나 비활성화해야함.<ul><li>주요 셰이더 노드의 각각 다른 출력에 영향이감.</ul></ul><li>머티리얼 도메인: 머티리얼 어트리뷰트가 평가되는 방식<li>블렌드 모드: 머티리얼 색과 배경과 블렌딩되는 방식을 결정<li><p>셰이딩 모델: 입력이 합쳐져 머티리얼의 최종 색을 만드는 방식을 결정</p><li>ex. 유리: 블랜드= Transparent, 셰이딩= Unlit or Default Lit =&gt; 유리의 빛에 대한 반응 방식을 바꿀 수 있음.<li><p>여러 조합으로 필요를 만족시켜야함.</p><li>이들은 런타임에 변경할 수 없다.</ul><h3 id="머티리얼-1"><strong>머티리얼</strong><a href="#머티리얼-1"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>머티리얼은 UE4가 오브젝트 상 텍스처의 표시 방식을 돕거나 조작하는 수단.<li>머티리얼은 HLSL코드의 작은 블록들로 구성됨.<li>작은 블록들은 온갖 다양한 역할을 수행함.<ul><li>그 중에는 텍스처의 색상대로 색조를 더하거나 두 텍스처의 블렌딩을 돕는다.<li>사실상 HLSL 함수를다루는것.</ul><li>머티리얼은 먼저 컴파일되어야함.<ul><li>컴파일: 미리보기 뷰포트 위의 적용 클릭<li>컴파일 == 스태틱 == 프로젝트 실행 중에는 변경불가</ul><li>머티리얼로 프로젝트 전체의 온갖 다양한 머티리얼에 적용할 수 있는 기능이 있음.</ul><h3 id="머티리얼-인스턴스"><strong>머티리얼 인스턴스</strong><a href="#머티리얼-인스턴스"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>머티리얼은 런타임에 변경 불가</p><ul><li>색상, 텍스처 등</ul><li>머티리얼 인스턴스는 머티리얼의 특별한 버전<ul><li>머티리얼을 리컴파일 할 필요 없이 머티리얼에 포함된 값과 텍스처를 런타임에도 바꿀 수 있게 해준다.<li>덕분에 머티리얼 인스턴스는 반복처리를 정말 빠르게 해줌.<li>변화가 거의 실시간.<li>타임라인과 블루프린트로부터 머티리얼 인스턴스와 상호작용해 다양하고 멋진 애니메이션 효과 얻음.</ul><li>퍼포먼스 이점<ul><li>유연성: 다양하고 수많은 파라미터 사용 =&gt; 마스터 머티리얼을 구성 =&gt; 복잡한 셰이더 코드를 다수 개발할 필요 없음. 미세 조정 가능</ul></ul><h3 id="마스터-머티리얼"><strong>마스터 머티리얼</strong><a href="#마스터-머티리얼"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>많은 구성을 할 수 있는 머티리얼<ul><li>수 많은 파라미터 노드 사용</ul><li>Base Color라는 백터 파라미터 =&gt; 색선택<li>텍스처 파라미터=&gt; 무엇이든 보충할 수 있게, 외형을 완전히 변경 가능<li>스칼라 파라미터 =&gt; 스칼라 변수 제어 = 특정 이펙트를 늘리거나 줄일 수 있음.</ul><h3 id="마스터-머티리얼-주의점"><strong>마스터 머티리얼 주의점</strong><a href="#마스터-머티리얼-주의점"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>가능한것</p><ul><li>다수의 마스터 머티리얼 사용</ul><li><p>해서는 안됨</p><ul><li><p>모든 오브젝트에 작용하는 단 하나의 마스터 머티리얼을 만드는것은 하면안됨 =&gt; 성능에 문제 생김</p><ul><li>캐릭용 , 아이템용, 불투명한것, 투명한것.. 등등 따로 따로</ul><li><p>지레짐작하지말아야함(불필요한 파라미터 삽입금지)</p></ul></ul><h3 id="마스터-머티리얼-개념"><strong>마스터 머티리얼 개념</strong><a href="#마스터-머티리얼-개념"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>머티리얼 =&gt; 좋은 퍼포먼스 + 자신이 목표로한 모든 플랫폼에서의 작동을 보장해야함<li>머티리얼 함수: 머티리얼 그래프 일부를 공유하고 재활용할 수 있게 해줌<ul><li>수많은 내장 함수들: 오브젝트의 월드 위치 결정, 화면상 마우스의 좌표 위치 파악까지 모든 것을 해냄<li>머티리얼 라이브러리로 코드 공유 가능<li>유지보수 간소화</ul><li>RGB 마스크 패킹<ul><li>텍스처의 사용 방식을 지정할 수 있다.<li>R, G, B, A 채널에 다른 텍스처를 저장하게 두는 것 =&gt; 메모리에서 텍스처 양을 줄일 수 있는 방법</ul><li>스태틱 스위치(static switches)<ul><li>머티리얼의 전체 경로를 활성화 또는 비활성화<li>ex. 패럴랙스 오클루전 노멀 매핑을 켜고 끄는 스위치를 만들면 노멀 맵에 굉장히 비용이 높고 사실적으로 보이는 디테일을 구현할 수 있다.<ul><li>비용이 높아 씬의 머티리얼 다수에 사용할 수 없음 =&gt; 스위치로 필요한 메시에만 활성화</ul></ul><li>피처 레벨 스위치<ul><li>어떤 목표 기기에서든 머티리얼이 실행될 수 있게 해줌.<li>다양한 플랫폼에 사용할 서로 다른 복잡도 수준에 따라 서로 다른 버전의 머티리얼을 연결<ul><li>ex. 셰이더 모델 5(SM5)을 사용해 거의 무한한 디테일과 아름다움을 얻고 싶으면 =&gt; 높은 디테일의 셰이더가 됨.<li>ex. ES2에서 실행되는 것 =&gt; 안드로이드 모바일 프리뷰어, 그냥 실행만될 뿐, 부가기능많이 없음</ul></ul></ul><h2 id="마스터-머티리얼-제작"><strong>마스터 머티리얼 제작</strong><a href="#마스터-머티리얼-제작"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>배경 오브젝트에 사용할 마스터 오브젝트 구성 방법<li>배경 오브젝트용 마스터 머티리얼을 유리가 있는 오브젝트용 마스터 머티리얼로 변환<li>머티리얼 함수 만들고 사용</ul><h3 id="마스터-머티리얼-생성"><strong>마스터 머티리얼 생성</strong><a href="#마스터-머티리얼-생성"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>파일 -&gt; 새 레벨 =&gt; 새 default 레벨 =&gt; 마스터 머티리얼 폴더 =&gt; 콘텐츠 브라우저 우클릭 =&gt; 새 마티리얼 =&gt;더블클릭</p><li>색추가<ul><li>머티리얼 인스턴스 =&gt; 벡처 파라미터 노드 추가(BaseColor로 그룹)<li>머티리얼 에디터 우클릭 =&gt; Vector 검색 =&gt; 베이스컬러와 연결 (키보드에서 v누르고 에디터 클릭)</ul><li><p>텍스처 추가</p><ul><li>T Key를 사용해 머티리얼 내에 배치 (콘텐츠 브라우저에서 우클릭후 텍스처 선택 =&gt; 머티리얼 에디터에서 t 누르고 에디터 클릭 or 드래그 드랍)<li>텍스처를 텍스처 오브젝트로 변환해 설정할 것임.<li>노드를 바로 BaseColor에 연결하면, 머티리얼을 컴파일하고 머티리얼 인스턴스에서 사용하려고하면 텍스처 샘플을 조정할 수 없게됨<li>Texture Sample 노드에 우클릭 후, 파라미터로 변환해야함. (Base_Color_Texture로 이름 설정, 그룹을 BaseColor)</ul><li>스태틱 스위치 추가(텍스처나 더 저렴한 비용의 벡터 컬러 파라미터의 사용여부를 결정)<ul><li>머티리얼 에디터 =&gt; 우클릭 =&gt; ‘Switch Parameter’ =&gt; ‘Default Value’를 true로 (bUseBaseColorTexture로 이름 설정, 그룹을 BaseColor)</ul><li><p>상수 값 추가</p><ul><li>키보드 1 키 + 좌클릭 =&gt; 노드 우클릭 파라미터 변환 (Metallic으로 설정, 그룹도 Metallic)</ul><li>러프니스 구성<ul><li>약간의 제어를 위해 Lerp Parameter 를 사용하여 러프니스 값을 높이거나 낮출것임.<li>텍스처를 하나 더 추가 =&gt; 텍스처의 RGB 채널에 패킹된 러프니스 맵을 사용할 수 있도록 러프니스를 구성할것임<ul><li>이 텍스처에서 샘플 타입을 <code class="language-plaintext highlighter-rouge">Masks</code>로 설정해야함 =&gt; 마스크 파라미터 구해야함(RGB -&gt; static mask param) =&gt; 머티리얼 인스턴스에서 텍스처의 다양한 R, G, V 채널을 선택 가능 (RoughnessMasks라고 이름 지음. Roughness 그룹에 넣음)<li>Texture Sample 우클릭 =&gt; 파라미터로 변환 =&gt; Roughness_Texture 라고 이름지음 =&gt; 그룹을 Roughness</ul><li>키보드 L 을 누르면서 클릭 =&gt; Lerp 노드를 생성 =&gt; Lerp의 Alpha와 마스크 연결 =&gt; A, B에는 스칼라(상수) 값 추가<li>러프를 Roughness(러프니스)와 연결<blockquote><p>컨트롤 쉬프트 왼클릭 =&gt; 노드 다중 선택</p></blockquote></ul><li><p>노멀맵 추가</p><ul><li>텍스처 샘플러 추가 =&gt; 우클릭 =&gt; 노멀맵과 연결 =&gt; 샘플 타입 노멀로 설정 =&gt; 파라미터로 변환 (Normal_Map으로 이름 변경)</ul><li>적용과 저장 버튼 =&gt; 마스터 배경(environment) 머티리얼 제작 끝</ul><h3 id="유리-머티리얼-제작"><strong>유리 머티리얼 제작</strong><a href="#유리-머티리얼-제작"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>위에서 만든 머티리얼 복붙, 이름 변경, =&gt; 오파시티나 오파시티 마스크 사용 (디테일 패널 =&gt; Materials 섹션 =&gt; Blend Mode)<ul><li>BlendMode: Masked(렌더러에게 이 픽셀을 통과해서 볼 수 있는지 없는지 알려줌)or <code class="language-plaintext highlighter-rouge">Translucent</code>(통과해 볼 수 있는 정도를 어느정도 조절)<ul><li>Translucency가 0.1 =&gt; 거의 다 통과 =&gt; 표면이 살짝 더럽거나 하는 경우를 만들 수 있음.<li>오파시티 or Translucency : 오파시티 마스크보다 비용이 더 많이 든다.(속도를 원한다면 마스크 사용, 퀄리티 =&gt; 오파시티)</ul><li>Opacity 상수 만들어 연결(opacity에)</ul><li>Shading Model을 Glass로 변경하여 씬의 라이팅과 더 나은 상호작용하도록 해야함<ul><li>Transluncy 섹션 =&gt; Lighting Mode =&gt; <code class="language-plaintext highlighter-rouge">Surface Forward Shading</code> : 최고의 라이팅과 반투명 상호작용을 보여줌 + 비용이 가장 비싸기도함.<ul><li>컴파일 오래걺림</ul></ul></ul><h3 id="머티리얼-함수-제작"><strong>머티리얼 함수 제작</strong><a href="#머티리얼-함수-제작"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>서로 다른 머티리얼 간에 셰이더 코드를 공유할 수 있게 해주는 머티리얼 함수 제작</p><li><p>머티리얼 함수: 머티리얼 간의 셰이더 코드 공유하는 수단</p><li><p>ex.</p><ul><li>‘MF_Tile’이름의 머티리얼 펑션 생성<li>간단한 텍스처 타일링: 타일링을 동일하게 유지시켜야하기 때문에 만든다. 각각 다른 셰이더에 사용하는 타일링 방식이 다를 필요가 없기 때문(일원화 작업)<li>텍스처 좌표 추가(Texture Coordinate)<li>FunctionInput 추가 =&gt; Texture_Scale로 이름 변경 =&gt; Input Type을 인풋 스칼라로 (텍스처 좌표에 값을 곱할 것임) =&gt; preview Value의 x를 1로 설정<li>=&gt; M키 랑 왼클 =&gt; Multiply 노드 생성 =&gt; 좌표를 A, Scale 스칼라를 B, 그리고 Multiply 노드를 타일 아웃풋에 연결 =&gt; 적용<li>아웃풋에 우클릭 =&gt; 미리보기 중지 =&gt; 다시 미리보기 시작</ul><li><p>머티리얼 함수를 머티리얼 에디터에 드래그 드랍하여 배치 가능</p><li><p>머티리얼간에 일관성이 있어야함 =&gt; 변수명 등</p></ul><h2 id="머티리얼-인스턴스-사용"><strong>머티리얼 인스턴스 사용</strong><a href="#머티리얼-인스턴스-사용"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="부모-자손-관계"><strong>부모 자손 관계</strong><a href="#부모-자손-관계"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>부모 인스턴스 머티리얼 관계<li>부모들이 그 색깔에 대한 액세스할 수 없기에 자손도 액세스할 수 없다.<li>부모가 할 수 있으면, 자손 역시 부모가 할 수 있는 모든 것에 액세스할 수 있다.<li><p>부모가 할 수 없으면, 자손 역시 할 수 없다.</p><li>ex.<ul><li>MAT_ENV_Master 와 MAT_Glass_Master가 있다.<li>MAT_ENV_Master =&gt; 세가지 외형의 머티리얼 인스턴스를 만들 수 있다.(타일링 변경, 색변경, 텍스처 변경)<ul><li>인스턴스에서 완전히 다른 외형의 머티리얼을 구성할 수 있다.(하지만 통과해서 볼 수 없음.)</ul><li>MAT<em>Glass_Master는 통과해서 볼 수있는 머티리얼.(이 마스터의 자손인 인스턴스들은 ENV</em>처럼 변경할 수 없다 =&gt; 부모가 접근을허용하지 않음)</ul></ul><h3 id="머티리얼-인스턴스-생성"><strong>머티리얼 인스턴스 생성</strong><a href="#머티리얼-인스턴스-생성"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>머티리얼 선택 =&gt; 인스턴스 생성<li><p>or 콘텐츠 브라우저에서 우클릭 후 머티리얼 &amp; 텍스처에서 만들 수 있음.</p><li><p>머티리얼 인스턴스 클릭 =&gt; 인스턴스 에디터</p><ul><li>BaseColor에서 텍스처 변경 가능 =&gt; 빠르게 변경됨(컴파일 시간 없이)<li>Metallic 등 을 오버라이드 가능 =&gt; Slider min ~ max 설정가능<li>이러한 설정들은 인스턴스 생성시 만든 그룹으로 묶임<li>부모 머티리얼 또한 변경 가능.</ul><li>머티리얼 더블클릭 =&gt; 디테일<ul><li>Material Property Override: 부모 머티리얼의 함수 기능을 오버라이드<ul><li>TwoSided: 안쪽도 렌더링하는지<li>블렌딩 모드 변경, 디더링된 LOD 전환의 변경 등<li>이는 부모 머티리얼 시스템의 목적을 무산시킴(보통 머티리얼을 새로 만듬)<li>검증용도로 사용하면 좋다.</ul></ul></ul><h3 id="vertex-animation"><strong>Vertex Animation</strong><a href="#vertex-animation"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>미묘한 움직임을 저렴한 비용으로 전달<li>물, 풀, 천 또는 역동적으로 움직여야하는 물건들<li>GPU에서 진행되기에 매 프레임의 렌더링 비용이 저렴함.<li>주어진 메시에서의 기존 버텍스 위치를 오프셋하기만 하면 되기 때문<li>저렴함 + 쉬운 활용 =&gt; 약간의 비용(상호작용성)<ul><li>모든 콜리전과 비슷한 것을 전부 처리하는 CPU는 GPU의 메시와 버텍스에 적용된 오프셋에 대해 알지 못함.<li>그저 <code class="language-plaintext highlighter-rouge">부가적인 장식</code>이나 씬과 경험에 재미나 실감을 더해주는 용도<li>게임플레이에 영향을 주지못함. (상호작용하는데 사용못함)</ul></ul><h2 id="퍼포먼스와-최적화-texture-streaming"><strong>퍼포먼스와 최적화: Texture Streaming</strong><a href="#퍼포먼스와-최적화-texture-streaming"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="texture-streaming"><strong>Texture Streaming</strong><a href="#texture-streaming"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>많은 양의 텍스처를 다룰 때 =&gt; 텍스처가 흐려질 수 있음.<ul><li>디테일이 제대로 표시되지 않을 수 있음.(스트리밍이 제대로 이루어지지 않음.)<li>스트리밍: 기본적으로 텍스처가 얼마나 크거나 작게 보일지 처리한다</ul><li>Lod or 밉맵: 텍스처와 정확히 똑같은 버전이지만 크기만 다른걸 보여줌(리소스 비용이 적음)<li>스트리밍: 레벨의 오브젝트와 카메라의 거리에 따라 서로 다른 LOD를 스트리밍하는것을 도와줌.</ul><blockquote><p>건축 시각화나 엄청나게 높은 텍스처 디테일이 필요한 경우 종종 경고를 받음(풀의크기가 부족하다는)</p></blockquote><ul><li><p>텍스처 스트리밍에 <code class="language-plaintext highlighter-rouge">PoolSize</code>라는 것이 있음.</p><ul><li>텍스처 밉맵으로 채울 수 있는 특정 메모리 셋을 말함.<li>텍스처가 카메라에서 멀 수록. 점점 작아지다 메모리 풀에서 차지하는 크기 또한 작아짐, 결국 메모리에 없어짐.<li>오브젝트에 가까이 가면 갈 수록, 텍스처는 이 스트리밍 풀을 점점 더 많이 차지하게됨.</ul><li><p>풀크기 키우기 : ‘`’ or ‘~’ 키를 눌러서 UE4 콘솔창 =&gt; <code class="language-plaintext highlighter-rouge">r.Streaming.PoolSize = 5000</code> 이런식으로 설정하면 됨.(메가바이트 단위)</p><ul><li>아니면 DefaultEngine.ini에서 설정</ul></ul><h3 id="forcing-textures-to-never-stream"><strong>Forcing Textures to never stream</strong><a href="#forcing-textures-to-never-stream"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>텍스처 스트리밍 안함 옵션: 언제나 가장 높은 해상도 버전의 텍스처가 표시되도록 만드는 것.<ul><li>프로젝트의 모든 텍스처를 가장 높은 해상도로 설정하면 안됨.<li>보통 UI옵션, 텍스트 등 유저에 가깝게 뭔가 표시하는 텍스처에 스트리밍 안함.<li>Texture =&gt; Never Stream<li>퀄리티는 높지만 비용이 비쌈.</ul></ul><h2 id="lod--스태틱-메시-병합"><strong>LOD &amp; 스태틱 메시 병합</strong><a href="#lod--스태틱-메시-병합"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>LOD: 거리가 멀리 떨어졌을 때 사용하려고 더 적은 버텍스로 렌더링한 다양한 버전의 메시</ul><h3 id="ue4-automatic-lod-creation-tools--manual-lod-setup"><strong>UE4 Automatic LOD Creation Tools &amp; Manual LOD Setup</strong><a href="#ue4-automatic-lod-creation-tools--manual-lod-setup"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>DCC에서 생성할 수 없거나 시간이 없을 경우</p><li><p>자동: 스태틱 메시 에디터의 LOD 세팅</p><ul><li>LOD 그룹 =&gt; 그룹 선택 =&gt; 자동 LOD 생성 툴이 BaseEngine.ini를 확인해 얼마나 많은 LOD 레벨이 적용되어야 하는지 알아낸다. (또한 메시 디테일 패널에 있는 다양한 세팅들도 확인, LOD0 세팅)<li>메시의 LOD 세팅 =&gt; LOD 그룹 LevelArchitecture =&gt; LOD를 거쳐서 Reduction setting을 각각 설정<li>LOD 그룹에서 설정</ul><li><p>수동</p><ul><li>LOD 세팅에서 LOD의 개수를 설정할 수 있고 각각의 LOD에서 Reduction setting에 있는 percent triangles 로 폴리곤 개수를 설정 가능.<li>보통 삼각형 개수를 75%, 25%, 12%로 맞춤 (사람의 눈은 윤곽선에서 얻는 정보가 더 큼)</ul></ul><h3 id="adjusting-tweaking-lods"><strong>Adjusting/ Tweaking LODs</strong><a href="#adjusting-tweaking-lods"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>LOD 변경사항에서 거리를 조정하거나 미세 조정해야한다면 =&gt; 현재 화면 크기 사용<li>LOD 세팅에서 Auto Compute LOD Distances 세팅 해제<li>스태틱 메시 에디터 =&gt; 트랜지션화면 크기를 설정 =&gt; Current Screen Size 를 보고 설정<li>LOD 강제 렌더링 가능 =&gt; Forced Lod Model<ul><li>액터 =&gt; 디테일 패널 =&gt; LOD =&gt; Forced Lod Model<li>배경 오브젝트가 많은 경우 메시가 항상 LOD4가 되게 설정 가능.<li>Min LOD: 마지막 LOD가 나올 때까지 계속 그 LOD 시스템을 쓰는것</ul></ul><h3 id="merge-actor-tool"><strong>Merge Actor Tool</strong><a href="#merge-actor-tool"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>드로콜과 머티리얼 수를 줄여주는 배경 오브젝트 그룹 작업 가능<li>스태틱 매시나 머티리얼 수가 많은 것. =&gt; 하나의 머티리얼, 스태틱 매시(삼각형의 개수는 같음)<ul><li>전체 렌더링 크기를 줄임.</ul><li><strong>하나의 머티리얼, 하나의 메시, 하나의 텍스처</strong><li>Window =&gt; DeveloperTools =&gt; Merge Actors<ul><li>Pivot Point at Zero: 단점이 있긴하지만 새 메시의 배치를 쉽게한다.<li>Merge Physics Data: 모든 피직스 데이터를 한데 병합.<li>LODSelection Type<ul><li>Use all LOD Levels: 새 머티리얼의 생성 방식을 선택이나 조정할 수 없게 하기 때문. (현재 상황 전부 취해 거대한 메시를 만든 후 그 LOD 를 모두 사용한다.)<li>Use specific LOD Levels: LOD 0으로 설정(2나 3 등의 레벨이 없는 것이 있을 수 있음), 새로 병합된 메시가 그 LOD 레벨을 신뢰할 수 없음. (LOD == 0일시 LOD Maker와 같은 내장 최적화 툴도 사용하여 메시를 더욱 최적화 가능 )</ul><li>Material Setting<ul><li>Merge Materials<li>all LOD Levels =&gt; 다양한 머티리얼 세팅 불가능<li>Use Specific LOD =&gt; Material Settings를 수정할 수 있다.(Normal map이나 Metallic Map을 수정할 수 있음)<li>Texture Sizing Type: 선택한 옵션이 자신의 콘텐츠에 최적하지 않을 수 있음. (모듈화 중점 =&gt; Input Texture의 Texture Size에 따라 자동 편향된 텍스처 크기를 사용할 수 있음.</ul><li>Landscape Culling: 랜드스케이프와 교차하는 모든 메시에 교차 부위를 마치 잘린것처럼 만들어줌. 랜드스케이프 액터에 배치된 매시를 크게 최적화함.</ul></ul><h3 id="계층형-lod"><strong>계층형 LOD</strong><a href="#계층형-lod"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>액터병합: 성능은 좋지만 파괴적<li>계층형 시스템: 레벨에서 다수의 액터를 생성하거나 병합할 수 있게 해주며, 프로그래밍적으로 수행한다.<ul><li>HLOD 툴을 삭제하거나 재실행하여, 레벨에 완전히 새로운 메시를 만들 수 있음.<li>비파괴적</ul><li><p>HLOD: 메시들을 모두 취해 하나의 텍스처와 하나의 머티리얼을 가진 단일 메시로 변환함</p><ul><li>window =&gt; world settings =&gt; LODSystem =&gt; HLOD 활성화<li>window =&gt; HLOD Outliner =&gt; Generate Clusters =&gt; Cluster generation setting<ul><li>기본적으로 HLOD 시스템 전반을 거쳐 볼륨을 상당히 낮춰줌.<li>그 볼륨에 포함된 모든 액터는 새로 생성된 메시, 새 LOD 메시를 얻어서 멀리서 사용할 수 있게해줌.<li>일정 거리만큼 떨어지면 HLOD 가 메시를 그룹으로 묶어 2~3개의 메시로 바꾸면서도 완전히 동일한 디테일한 레벨을 보여줌(메시도 2~3개, 머티리얼도 2~3개, 텍스처도 2~3개)<li>카메라에서 멀리 있을 경우, 정확히 똑같은 오브젝트를 훨씬 절감된 비용으로 렌더링 가능</ul><li>모든것을 구성하거나 알맞은 클러스터에 두었다면, Generate Proxy Meshes 누름.</ul><li><p><strong>레벨을 렌더링하는데 드는 메모리와 GPU 비용을 줄임.</strong></p><li>주의: 레벨이 크면 클수록, 혹은 오브젝트 밀도가 높으면 높을수록, 프록시 메시 생성에 드는 시간은 더 길어진다.</ul><h2 id="라이팅-섀도잉-포스트-프로세스"><strong>라이팅, 섀도잉, 포스트 프로세스</strong><a href="#라이팅-섀도잉-포스트-프로세스"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>모두 서로 비슷, 모두 서로 상호작용<li>여기에서 대부분의 퍼포먼스 문제가 발생함</ul><h3 id="라이팅"><strong>라이팅</strong><a href="#라이팅"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-proofer-ignore data-src="/img/ue4_lighting.png" alt="" /></p><ul><li><p>다양한 라이팅 Mobility 타입</p><ul><li>라이팅의 퍼포먼스 비용 면에서 서로 다른 기능이 있다.<li><code class="language-plaintext highlighter-rouge">Static</code>: 가장 저렴, 씬에서 아무것도 하지 못하는 라이팅을 의미, 완전히 구워져서 상호작용할 수 없음.<li><code class="language-plaintext highlighter-rouge">Stationary</code>: 씬과 상호작용을 할 수 있어, 스테이셔너리 라이트로 인해 생기는 섀도는 다이나믹 오브젝트가 해당 섀도와 어우러지게 해줌. (비용이 살짝 비쌈)<ul><li>런타임에서 스테이셔너리 라이트의 라이팅 색상과 강도를 실제로 바꿀 수 있기 때문.<li>라이팅을 움직이지는 못함.</ul><li><code class="language-plaintext highlighter-rouge">Movable</code>: 완전히 동적이기 때문에 비용이 비쌈. 모든 라이팅, 섀도인이 다 동적<li>사람눈으로 차이를 거의 구분할 수 없음.</ul><li><p>라이팅 빌딩</p><ul><li>BuildOptions =&gt; Lighting Quality =&gt; Production/High/Medium/Preview<ul><li><code class="language-plaintext highlighter-rouge">preview</code>: 에디터가 매우 낮은 세팅을 사용해 프리뷰를 보여주거나 라이팅과 섀도잉이 어떻게 보일지 기본적인 개념만 제시<li><code class="language-plaintext highlighter-rouge">Medium</code>: preview보다 약간 더 느리고, 약간 더 나은 결과를 보여줌.<li><code class="language-plaintext highlighter-rouge">High</code>: 비교적 높은 라이팅 제공하지만, 얼룩, 띠현상 때문에 라이트맵 해상도를 올려서 조정해야할 수도 있음.<li><code class="language-plaintext highlighter-rouge">Production</code>: 기본적으로 완성할 수 있는 최고의 퀄리티의 라이팅을 보여줌.(오래걸림)</ul><li>production 과 preview 사이의 퀄리티 차이는 꽤 큼.<li>개발진행상태에 따라 옵션을 변경(초기 == preview, 모든 작업끝 == Production)</ul></ul><h3 id="섀도잉"><strong>섀도잉</strong><a href="#섀도잉"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>섀도잉하는 방법은 다양함.</p><li><p>언리얼에서는 두 가지의 주요 섀도잉 타입이 있음.</p><ul><li><code class="language-plaintext highlighter-rouge">Static</code>: 스태틱 라이트 유형에서 나오는것. 비용이 작음, 씬 상호작용 할 수 없음<li><code class="language-plaintext highlighter-rouge">Dynamic</code>: 스테이셔너리와 무버블 라이트에서 나옴. 비용이 비쌈, 씬 상호작용 할 수 있음.</ul><li><p>static 라이트</p><ul><li>다이나믹 오브젝트 즉, 모든 움직이는 오브젝트는 그림자를 드리우지 못함.</ul><li><p>스테이셔너리 라이트 사용 =&gt; 그림자가 서로 합쳐짐(구워진 섀도우에서도)</p><ul><li>다이나믹 섀도를 드리우되, 스태틱 섀도잉 시스템의 효과도 많이 가져옴<li>스태틱과 다이내믹 사이에 위치.</ul><li><p>Dynamic</p><ul><li>좀 더 선명하고 가장자리의 부드러움이 전혀 없음.<li>구워진 섀도우가 없음.</ul></ul><h3 id="특이한-섀도우"><strong>특이한 섀도우</strong><a href="#특이한-섀도우"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><code class="language-plaintext highlighter-rouge">CSM(Cascaded Shadows)</code><ul><li>스태틱 섀도와 다이내믹 섀도의 최고 장점들을 합칠 수 있기 때문.<li>가까이 있을 때 =&gt; 완전한 다이내믹 섀도<li>멀리 =&gt; 스태틱 섀도로 전환<li>Direction Light =&gt; cas =&gt; Num Dytnamic Shadow Cascade, Dynamic Shadow Distance =&gt; 전환되는 거리와 다이내믹 섀도 케스케이드의 수 변경 가능<li>이 섀도는 Directional Light에서만 사용가능.</ul><li><code class="language-plaintext highlighter-rouge">Distance Field Shadows</code><ul><li>메시 디스턴스 필드를 사용하여 실제로 라이팅과 섀도의 상호작용을 생성해서 멋진 섀도 감쇠를 만들어냄<li>비용이 굉장히 높음<li>포인트 라이트에서 활성화 할 수 있지만, 디스턴스 필드를 활성화 해야함.<li>프로젝트 세팅 =&gt; Distance =&gt; 엔진 라이팅 =&gt; Generate Mesh Distance Fields =&gt; 활성화</ul><li><code class="language-plaintext highlighter-rouge">Contact Shadows</code><ul><li>컨택트 섀도가 멋진 이유: 실제 스크린 스페이스에 구성되는 섀도.<li>기본적으로 스크린 스페이스의 섀도<li>굉장히 작은 디테일 (디렉셔널 라이트의 섀도잉은 섀도 버퍼가 이런 디테일 유형을 나타내기에 충분히 크지 않음)<li>포인트 라이트 =&gt; 디테일 패널 =&gt; Contact =&gt; Contact Shadow Length<li><code class="language-plaintext highlighter-rouge">Contact Shadow</code> 값을 증가시키면 그림자는 깊어짐(적절히 설정해야함. 1을 넘어가면 별로)<li>패럴랙스 오클루전 매핑(Parallax Occlusion mapping) =&gt; 특정 컨택트 섀도 메서드의 작동 방식을 바르게 볼 수 있는 방법<li>정말 높은 비용의 기능</ul></ul><h3 id="post-process"><strong>Post Process</strong><a href="#post-process"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>볼륨으로 처리되는 포스트 프로세싱 =&gt; 렌더링을 제어하기 때문.</p><ul><li>퍼포먼스 다수를 순식간에 잡아먹을 수 있는 구간 중 하나.</ul><li>포스트 프로세스 섀도를 구하는 방법<ul><li>Volumes =&gt; Post 검색 =&gt; 포스트 프로세스 볼륨 =&gt; 디테일 패널<li>디테일 패널 =&gt; Unbound 프로퍼티 체크(언바운드의 역할: 이 포스트 프로세스가 레벨 어디에 배치되든 모든 포스트 프로세스 세팅에 이 포스트 프로세스를 사용하라)<ul><li>언바운드가 활성화되지 않으면: 볼륨의 스케일과 회전을 조정 =&gt; 플레이어가 이 볼륨에 들어오면 포스트 프로세스가 변함. 언바운드는 이를 방지함. =&gt; 이 세팅을 월드 모든 곳에 적용.</ul><li>모바일 톤 매퍼: 모바일 프로젝트 제작에만 유용<li>안티 에일리어싱: 프로젝트 설정 =&gt; 디폴트 세팅에서 설정 가능<li>포스트 프로세싱 =&gt; 블루프린트를 통해 조작된 값도 가질 수 있음. (온도 등 변경)</ul><li>포스트 프로세스의 세팅을 많이 켜고 조정할수록 렌더링에 드는 비용이 커짐.</ul><h2 id="볼륨"><strong>볼륨</strong><a href="#볼륨"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>많은 볼륨 중 다음과 같은 볼륨만 다룰 것임<ul><li>Lightmass Volumes: 라이팅 계산이 이루어지는 Min 과 Max 영역을 정의, 인터렉티브나 무버블 오브젝트가 월드와의 확실한 상호작용을 통해 여기저기 움직이고 상호작용을 하면서도 월드로부터 라이팅을 받을 수 있게 돕기도 함.<li>Cull Distance Volumes: 레벨에서 확실하게 컬링을 만들어주는 안전 그물역할</ul></ul><h3 id="using-volumes"><strong>Using Volumes</strong><a href="#using-volumes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>UE4의 여러곳에 배치해 다양한 일을 수행할 수 있는 액터<li>갈수 있는 곳과 갈 수 없는 곳을 결정.<li>사운드 리버브방식 등 결정<li>상호작용할 수 있는 많은 방식 =&gt; 볼륨으로 제어됨.</ul><h4 id="라이트매스-볼륨"><strong>라이트매스 볼륨</strong><a href="#라이트매스-볼륨"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p>두가지 목적</p><li><p><strong>1. 라이트매스 시뮬레이션의 경계를 정해 라이트매스가 계산할 가장 큰 영역과 가장 작은 영역을 결정</strong></p><ul><li>라이트매스 볼륨을 레벨에 두지 않으면, 결국 라이트를 전혀 받지 않는 영역이나 레벨에서 플레이가 가능하지 않은 영역에 상당량의 연산 시간을 낭비하게 될 수도 있다.<li>라이트매스 볼륨 =&gt; 플레이어가 보거나 상호작용하는 영역만 라이팅 계산 =&gt; 계산 양 줄어든다. =&gt; 실제 레벨 라이트 계산 빨라짐</ul><li><p>ex</p><ul><li>Lightmass importance volume<li>이 볼륨들을 여러개 레벨의 모든 영역에 배치할 수 있지만, 결국 라이트매스란 MIN 과 MAx 위치를 보고 하나의 큰 볼륨을 만든다.<li>그러니 레벨에 볼륨을 확실히 두고 레벨의 플레이 가능 영역을 모두 포함하는지 확인해야 한다.</ul><li><p><strong>2. 캐릭터와 같은 동적 오브젝트에게 정적으로 라이팅되는 환경에 대해 알려주는 것.</strong></p><ul><li>완전한 다이내믹 라이팅을 만들 수 없다(라이트와 섀도 맵 안에 라이팅을 구움)<li>즉, 상호작용 못함 =&gt; 문제 해결: “Lightmass Importance Samples” 혹은 소형 라이팅 프로브들을 곳곳에 배치<ul><li>viewport=&gt; show =&gt; visualize =&gt; light sample 에서 확인 가능.<li>이 샘플들은 각각 캐릭터들에게 배치된 라이팅에 대해 알려준다.(메시 선택, alt + shift를 누른채 옮겨서 확인 가능)</ul><li>다이내믹 메시가 정보를 받도록, 또는 작은 라이팅 볼륨 샘플과 배치된 샘플들로부터 어떤 색상을 띠어야 하는지 알려주는것인데 다 이 볼륨덕분</ul><li><p><strong>Lightmass Character Indirect Detail Volume</strong></p><ul><li>특정 볼륨에 배치된 샘플 숫자를 증가시킴<li>작은 샘플들 각각이 지오메트리가 있는 곳 위로 배치됨 (샘플이 없으면, 캐릭터 안보임)<li>캐릭터 볼륨안에 샘플 다수가 있는지 확인<li>엘레베이터 내부처럼 플레이어가 긴 영역을 따라 이동해야하지만 샘플이 많이 있지는 않은 특정한 장소에서 사용하고 싶을 것<li><p>특정 프로젝트에 있는 샘플의 전체적인 양을 증가시키기 위함</p><li>world Setting =&gt; lightmass =&gt; Static Lighting Level Scale =&gt; 샘플들의 밀도 조절 (높은 밀도 =&gt; 디테일 증가 =&gt; 0.1로 설정 =&gt; 메모리 많이 필요)</ul></ul><h3 id="cull-distance-volume"><strong>Cull Distance Volume</strong><a href="#cull-distance-volume"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>특정 크기나 카메라 거리를 초과한 오브젝트의 렌더링을 멈추는 최적화 툴</p><ul><li>이를 사용할 때 오브젝트의 모든 것을 컬링할 수단보다는 그냥 기본값처럼 사용(안전 그물역할)</ul><li><p>cull distance volume</p><ul><li>디테일 =&gt; Cull distances =&gt; 배열 =&gt; 여러 종류의 입력이 있음(ex, 3개)<li>오브젝트가 렌더링될자 아니면 멈출지의 기준이 될 크기와 거리를 결정.<li>이 배열에 카메라의 거리와 크기의 임계점을 담음.<li>메시에서 <code class="language-plaintext highlighter-rouge">Allow Cull Distance</code> 를 활성화 해야함</ul><li><p>수동적인 방법: 메시 =&gt; 렌더링 =&gt; 고급 프로퍼티 =&gt; Min Draw Distance. Desired MaxDrawDistance, Current Draw Distance : 하드 코딩 설정/ 오브젝트가 카메라로부터 컬링되는 기준 거리 강제 설정 가능</p><li><p>볼륨을 사용하여 컬링을 하면, 프로젝트에서 컬링을 구성할 때 원래 필요했을 작업량을 상당히 줄여줌.</p><ul><li>일일이 수동으로 최적화하지 않아도 됨.</ul></ul><h2 id="리플렉션"><strong>리플렉션</strong><a href="#리플렉션"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="reflaections"><strong>Reflaections</strong><a href="#reflaections"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>3가지 방법으로 얻을 수 있음<ul><li>이 방법들은 특정 액터에 의해 제어됨<li>sphere: 비용이 저렴<li>box: 비용이 저렴<li>planar: 비용이 비쌈</ul><li><p>sphere</p><ul><li>구체 영역안에 리플렉션을 만든다.<li>저렴<li>레벨 전체 커버할 캡처 액터와 , 작은 캡처 몇개를 만들어 여기저기 배치<li>과용하면 좋지않음<li>리플렉션 뷰모드 사용하여 세세하게 잘 설정할 수 있다.</ul><li><p>BOX</p><ul><li>일반적으로 복도 내부, 네모난 레벨에서 사용<li>구석에서 약간 오류가 발생</ul><li>Planar<ul><li>프로젝트 세팅 =&gt; 렌더링 =&gt; support global clip plane for planar reflections활성화<li>레벨과 모든 메세와 텍스처의 사본을 취해서 위 아래로 뒤집은걸 리플렉션으로 사용<li>정확한 리플렉션이 나오지만 비용은 메시와 머티리얼의 비용에 직접적인 연관.<li>몇몇 에러 발생가능 =&gt; 작고 파란 하이라이트들이 생김 =&gt; 리플렉션이 씬을 One-Sided로 렌더링하기 때문.=&gt; Render Scene Two Sided를 True로 설정해야함</ul><li>포스트 프로세싱 볼륨의 스크린 스페이스 리플렉션(SSR)<ul><li>포스트 프로세싱 볼륨 =&gt; 디테일 패널 =&gt; Rendering Features =&gt; Screen Space Reflection 활성화<li>Sphere, BOX는 레벨의 모든 다이내믹이 리플렉션 캡처로 고려되지 않는다.<li>역동적인 리플렉션 =&gt; SSR or Planar<li>스크린 밖에 오브젝트가 있으면 리플렉션 망가짐<ul><li>화면의 정보를 사용하기 때문(보이지 않으면 반사 x )</ul></ul></ul><h3 id="getting-higher-quality-reflections"><strong>Getting Higher Quality Reflections</strong><a href="#getting-higher-quality-reflections"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>언리얼 == 실시간 엔진</p><ul><li>전반적인 리플렉션 캡처 해상도를 최소한으로 낮춤</ul><li><p>해상도를 실제로 변경 가능.</p><ul><li>에디터 =&gt; 편집 =&gt; 프로젝트 세팅 =&gt; 렌더링 세팅 =&gt; Capture Resolution<li>스카이라이트 =&gt; 디테일 패널 =&gt; Cubemap Resolution<li>해상도 높 =&gt; 메모리 사용량이 많이 늘어남</ul><li><p>메시에게 High Precision Static Mesh Normal 과 Tangent Encoding 사용</p><ul><li>높은 테셀레이트 스피어 사용<li>편집 =&gt; 프로젝트 세팅 =&gt; 렌더링=&gt; GBuffer Format =&gt; High Precision Normals<li>메시 =&gt; 디테일 패널 =&gt; 빌드 세팅 =&gt; Use High Precision Tangent Basis =&gt; TRUE<li>메시 전체에 더 나은 보간을 줌.<li>메시가 높게 테셀레이트 =&gt; 버텍스 많이 사용 =&gt; 부드러운 트랜지션</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/game/'>game</a>, <a href='/categories/game-unreal4/'>game-unreal4</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/unreal4/" class="post-tag no-text-decoration" >unreal4</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[UE4] 언리얼 엔진에 오신 것을 환영합니다 - RohRoh&url=https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[UE4] 언리얼 엔진에 오신 것을 환영합니다 - RohRoh&u=https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[UE4] 언리얼 엔진에 오신 것을 환영합니다 - RohRoh&url=https://nor-s.github.io/posts/2022/02/18/05/36/unreal2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2022/03/24/03/46/skeleton1/">[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 1</a><li><a href="/posts/2022/03/23/21/58/unreal-animation/">[UE4] 애니메이션 시작하기</a><li><a href="/posts/2022/03/22/04/45/bellman-ford/">[그래프] 벨만-포드 최단 경로 알고리즘</a><li><a href="/posts/2022/03/18/08/26/opengl22/">[learn-opengl] Advanced OpenGL: Framebuffers</a><li><a href="/posts/2022/03/18/09/28/opengl23/">[learn-opengl] Advanced OpenGL: Cubemaps</a></ul></div><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2022/02/16/20/34/unreal1/"><div class="card-body"> <em class="timeago small" date="2022-02-16 20:34:51 +0900" >Feb 16</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] 개발자를 위한 언리얼 엔진 시작하기_1</h3><div class="text-muted small"><p> 개발자를 위한 언리얼 엔진 시작하기 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서. 인트로 8개의 주제 엔진구조 렌더링 월드 빌딩 마테리얼 블루프린트 프로그래밍 캐릭터 애니메이션 월드 빌딩 철학 언리얼: 시각적...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/23/21/58/unreal-animation/"><div class="card-body"> <em class="timeago small" date="2022-03-23 21:58:52 +0900" >Mar 23</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] 애니메이션 시작하기</h3><div class="text-muted small"><p> 애니메이션 시작하기 철학 다용도성 확보(versatile tools) 레이어화된 애니메이션 플로우 다양한 애니메이션 레이어에서 벌어지는 일들을 쉽게 분리해서 레이어별로 반복 처리하고 폴리시할 수 있음. 재사용성 애니메이션 속의 다양한 요소를 다른 캐릭과 애니메이션 등을 공...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/24/01/36/UE4_Skeleton_Assets_Overview/"><div class="card-body"> <em class="timeago small" date="2022-03-24 01:36:00 +0900" >Mar 24</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] Skeleton Assets: Overview</h3><div class="text-muted small"><p> Skeleton Assets: Overview를 보고 정리한 문서 Skeleton Assets 캐릭터 생성 스켈레탈 메시로 외형부터 만든다. 스켈레탈 메시 == 3D모델 스켈레톤 구성 즉, 캐릭터의 리깅 작업 본이나 관절 계층 구조의 추가 및 정의 등이 진행된다. 캐릭터...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2022/02/16/20/34/unreal1/" class="btn btn-outline-primary" prompt="Older"><p>[UE4] 개발자를 위한 언리얼 엔진 시작하기_1</p></a> <a href="/posts/2022/02/19/05/15/1541/" class="btn btn-outline-primary" prompt="Newer"><p>[백준][C++] 1541: 잃어버린 괄호 (greedy)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/Nor-s">roh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
