<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[learn-opengl] Triangle" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Shader" /><meta property="og:description" content="Shader" /><link rel="canonical" href="https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/" /><meta property="og:url" content="https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/" /><meta property="og:site_name" content="RohRoh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-12T19:16:36+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[learn-opengl] Triangle" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"dateModified":"2022-02-14T16:15:42+09:00","datePublished":"2022-02-12T19:16:36+09:00","description":"Shader","mainEntityOfPage":{"@type":"WebPage","@id":"https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/"},"url":"https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/","@type":"BlogPosting","headline":"[learn-opengl] Triangle","@context":"https://schema.org"}</script><title>[learn-opengl] Triangle | RohRoh</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RohRoh"><meta name="application-name" content="RohRoh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/commons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">RohRoh</a></div><div class="site-subtitle font-italic">my blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Nor-s" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[learn-opengl] Triangle</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[learn-opengl] Triangle</h1><div class="post-meta text-muted"><div> <em> <a href="https://github.com/Nor-s">roh</a> </em></div><div class="d-flex"><div> <span> <em class="timeago" date="2022-02-12 19:16:36 +0900" data-toggle="tooltip" data-placement="bottom" title="Sat, Feb 12, 2022, 7:16 PM +0900" >Feb 12</em> </span> <span> Updated <em class="timeago" date="2022-02-14 16:15:42 +0900 " data-toggle="tooltip" data-placement="bottom" title="Mon, Feb 14, 2022, 4:15 PM +0900" >Feb 14</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5477 words"> <em>30 min</em> read</span></div></div></div><div class="post-content"><h1 id="shader"><strong>Shader</strong></h1><p>그래픽스 파이프라인의 두가지 부분</p><ul><li><p>3D -&gt; 2D</p><li><p>2D -&gt; 화소픽셀</p><li><p>대부분 vertex shader, fagment shader만 사용.</p><li><p>Geometry shader는 선택적으로 사용</p><li><p>GPU에 기본 vertex/fragment shader 가 없음 =&gt; 스스로 작성해야함</p></ul><h2 id="그래픽-파이프라인의-입력--3d-좌표"><strong>그래픽 파이프라인의 입력 : 3D 좌표</strong><a href="#그래픽-파이프라인의-입력--3d-좌표"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>여러단계를 거침<li>각 단계는 전 단계의 결과를 입력으로.<li>모든 단계는 특성화됨<li>병렬로 실행됨<li>각 단계에서 GPU 위에 작은 프로그램들을 실행시킴<li><p>데이터를 빠르게 처리 (GPU의 수많은 작은 프로세싱 코어들)</p><li>이런 작은 프로그램들이 바로 shader</ul><h2 id="쉐이더"><strong>쉐이더</strong><a href="#쉐이더"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>존재하는 기본 쉐이더를 대체할 수 있음<li>설정가능한 쉐이더 : 파이프라인의 특정한 부분을 좀 더 세밀한 조작을 가능하게함.<li>GPU 위에 실행 =&gt; CPU 시간을 절약 =&gt; OpenGL Shading Language (GLSL) <img data-proofer-ignore data-src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGSrak%2FbtraiFTBWxM%2FWIvHK73EckPcugX4FfTcYK%2Fimg.png" alt="파란배경 == 작성한 쉐이더 사용 가능" /></ul><h2 id="그래픽-파이프라인"><strong>그래픽 파이프라인</strong><a href="#그래픽-파이프라인"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>많은 일을 하는것을 위 그림에서 볼 수 있음.</p><li><p>각 부분들은 정점 데이터를 완전히 렌더링된 픽셀로 변환하는 데, 각자 하나의 특정 부분을 관리.</p><li><p>삼각형 렌더링 그래픽 파이프라인의 입력 : 삼각형을 구성할 수 있는 정점 데이터 : 3개의 3D좌표리스트</p></ul><h3 id="정점vertex"><strong>정점(vertex)</strong><a href="#정점vertex"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>3D 좌표에 대한 데이터의 집합</p><li><p>정점 속성(vertex attributes)를 사용하여 정점의 데이터 표현</p><li><p>이 속성은 모든 데이터를 포함할 수 있지만 대표적으로 3D 위치, 컬러값</p><li><p>OpenGL이 이런 집합을 만들기 위해, 어떤 종류의 렌더링 유형인 것인지 알려줘야함</p><li><p>이러한 힌트들을 primitives 라고함: GL_POINTS, GL_TRIANGLES, GL_LINE_STRIP</p></ul><h3 id="vertex-shader"><strong>vertex shader</strong><a href="#vertex-shader"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>파이프 라인의 첫번째 부분</p><li><p>하나의 정점을 입력으로 받는 정점 쉐이더(vertex shader)</p><li><p>vertex 쉐이더의 주 목적 1 : 3D 좌표를 다른 3D 좌표로 변환하는것</p><li><p>vertex 쉐이더의 주 목적 2 : vertex 속성에 대한 기본적인 처리</p></ul><h3 id="primitive-assembly-단계"><strong>primitive assembly 단계</strong><a href="#primitive-assembly-단계"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>primitive 를 구성 (primitive 도형의 모든 점들을 조립하는 vertex 쉐이더로부터)</p><li><p>입력 값 : 모든 정점들을 받는다. (GL_POINTS 같은 경우 하나의 정점)</p><li><p>결과 값 : geometry shader로 전달</p></ul><h3 id="geometry-shader"><strong>geometry shader</strong><a href="#geometry-shader"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>입력값 : 정점들의 집합</p><li><p>이 정점들의 집합은 primitive를 구성하고,</p><li><p>새로운 정점을 생성하여 새로운 primitive를 형성, 다른 도형으로 변환</p><li><p>위 그림에선 삼각형한개를 두개로 생성</p><li><p>결과 값 : rasterization stage로 전달</p></ul><h3 id="rasterization-stage"><strong>rasterization stage</strong><a href="#rasterization-stage"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>결과 primitive 를 최종 화면의 적절한 픽셀과 매핑</p><li><p>그 결과 fragment shader에서 사용할 fragment(조각)이 도출</p><li><p>fragment shader를 실행하기 전 clipping을 수행</p></ul><h3 id="clipping"><strong>clipping</strong><a href="#clipping"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>성능을 증가시키기 위해 뷰 밖에 있는 모든 fragment들을 제거</p><li><p>OpenGL 에서 fragment는 하나의 픽셀을 렌더링 하기 위해 필요한 모든 데이터</p></ul><h3 id="fragment-shader"><strong>fragment shader</strong><a href="#fragment-shader"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>목적: 픽셀의 최종 컬러를 계산하는것</p><li><p>advanced OpenGL effects 가 발생하는 단계</p><li><p>일반적으로 fragment shader는 3D scene에 대한 데이터를 가지고 있음</p><li><p>이 데이터를 가지고 최종 픽셀 컬러(광원, 그림자, 빛의 색 등)를 계산</p></ul><h3 id="alpha-test-and-blending-stage"><strong>alpha test and blending stage</strong><a href="#alpha-test-and-blending-stage"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>최종 결과물의 마지막 단계</p><li><p>fragment의 해당 깊이(deepth and stencill) 값을 체크</p><li><p>최종 fragment가 다른 오브젝트보다 앞에 있는지 뒤에 있는지 체크</p><li><p>다른 오브젝트보다 뒤에 있는 fragment는 즉시 폐기.</p><li><p>이 단계에서 alpha값(오브젝트의 투명도)를 확인</p><li><p>그에 맞춰 다른 오브젝트와 blend</p><li><p>fragment shader에서의 출력 색 과 최종 픽셀 컬러는 여러개의 삼각형을 렌더링할 때 완전히 다른 색이 될 수 있음</p></ul><h1 id="투상-파이프라인"><strong>투상 파이프라인</strong></h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>모델좌표

| ---- 모델행렬

전역좌표

| ---- 뷰 행렬

시점좌표

| ---- 투상 행렬 =&gt; 후면 제거

절단좌표 (동차좌표계에서 절단)

| ---- 원근분할

정규화장치좌표(NDC)

| ---- 뷰포트 변환 -&gt; 정수화 glViewport

화면좌표(뷰포트좌표)

| ---- 래스터 변환 -&gt; 은면제거 (깊이테이스) -&gt; z값제거

디스플레이
</pre></table></code></div></div><h1 id="vertex-입력"><strong>Vertex 입력</strong></h1><h2 id="opengl--3d-라이브러리"><strong>OpenGL : 3D 라이브러리</strong><a href="#opengl--3d-라이브러리"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>명시한 좌표는 3D 공간의 좌표</p><li><p>모든 3D 좌표가 (x, y, z) 에서 값이 -1.0 와 1.0 사이에 있어야 처리(normalized device coordinates 범위)</p></ul><h2 id="삼각형"><strong>삼각형</strong><a href="#삼각형"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>3개의 정점 명시</p><li><p>normalized device coordinates 범위, float 배열 로</p><li><p>z = 0.0 으로 설정, 2D처럼 보이도록 depth를 같게</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>
     <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="ndcnormalized-device-corrdinates"><strong>NDC(Normalized Device Corrdinates)</strong><a href="#ndcnormalized-device-corrdinates"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>vertex coordinates 가 vertex shader에서 처리되고나면</p><li><p>정점들이 NDC 공간으로 변환</p><li><p>각 범위는 모두 -1.0 ~ 1.0</p><li><p>이 범위 밖의 점은 버려짐</p></ul><p><a href="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbzD0Ik%2FbtrajpXDIEW%2FXsbN1GpH9NYGvRNFHA5zP1%2Fimg.png"></a></p><ul><li>뷰포트 변환을 통해 screen-space coordinates 로 변환<li>screen-space coordinates 는 fragment로 변환되어 fragment shader의 입력값으로 전달</ul><h2 id="vertex-shader-1"><strong>vertex shader</strong><a href="#vertex-shader-1"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>GPU에 정점 데이터를 저장할 공간의 메모리를 할당.</p><li><p>OpenGL이 어떻게 메모리를 해석할 것인지 구성</p><li><p>데이터를 어떻게 그래픽 카드에 전달할 것인지에 대해 명시</p><li><p>작업 완료한 다음 정점들을 전달한 만큼 메모리에서 처리</p></ul><h2 id="vbovertex-buffer-objects"><strong>VBO(vertex buffer objects)</strong><a href="#vbovertex-buffer-objects"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>정점들을 처리하는 메모리를 관리</p><li><p>많은 양의 정점들을 GPU 메모리상에 저장할 수 있음</p><li><p>대량의 데이터를 한꺼번에 GPU로 전송</p><li><p>CPU &lt;-&gt; GPU : 느리기 때문에 가능한 많이 보내야함</p><li><p>데이터가 그래픽 카드 메모리에 할당되면 vertex shader는 빠르게 정점들에 접근 가능</p><li><p>OpenGL의 객체로, 이 버퍼도 고유한 ID를 가짐, 버퍼 ID를 생성할 수 있다.</p></ul><p><code class="language-plaintext highlighter-rouge">glGenBuffer(GLsizei size, GLuint* buffers)</code></p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>

<span class="n">GLuint</span> <span class="n">vbos</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">vbos</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="opengl에는-많은-타입의-버퍼-객체가-있음"><strong>OpenGL에는 많은 타입의 버퍼 객체가 있음</strong><a href="#opengl에는-많은-타입의-버퍼-객체가-있음"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>VBO 의 버퍼 타입은 GL_ARRAY_BUFFER</p><li><p>다른 버퍼 타입 또한 bind 할 수 있다.</p><li><p>새롭게 생성된 버퍼를 glBindBuffer 함수를 사용하여 GL_ARRAY_BUFFER로 바인딩 할 수 있음</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>이후부터 호출되는 GL_ARRAY_BUFFER를 타겟으로하는 모든 버퍼는 현재 바인딩 된 버퍼(VBO)를 사용하게됨</ul><h2 id="glbufferdata-함수"><strong>glBufferData 함수</strong><a href="#glbufferdata-함수"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>미리 정의된 정점 데이터를 버퍼의 메모리에 복사</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>사용자가 정의한 데이터를 현재 바인딩된 버퍼에 복사.</p><li><p>첫번째 파라미터 : 데이터를 집어넣을 버퍼의 유형(현재 바인딩된 vbo)</p><li><p>두번째 파라미터 : 버퍼에 저장할 데이터의 크기 (바이트 단위. size of)</p><li><p>세번째 파라미터 : 보낼 실제 데이터</p><li><p>네번째 파라미터 : 그래픽 카드가 주어진 데이터를 관리하는 방법</p><ol><li><p>GL_STATIC_DRAW: 데이터가 거의 변하지 않음 (현재 예제에선 적절)</p><li><p>GL_DYNAMIC_DRAW: 데이터가 자주 변경됩니다.</p><li><p>GL_STREAM_DRAW: 데이터가 그려질때마다 변경됩니다.</p></ol><p>2, 3 번일 경우, 그래픽 카드가 빠르게 쓸 수 있는 메모리에 데이터를 저장</p><li><p>정점데이터를 메모리에 저장 완료 : 이 메모리는 VBO가 관리, vertex/fragment shader가 처리</p></ul><h1 id="vertex-shader-2"><strong>Vertex shader</strong></h1><ul><li><p>프로그래밍 할 수 있는 shader 중 하나</p><li><p>GLSL 를 통해 vertex shader를 작성, 컴파일, 응용프로그램에서 사용</p><li><p>아래는 기초적인 vertex shader 코드이다.</p></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#version 330 core
</span><span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">aPos</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">aPos</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>glsl는 c 와 유사함.</ul><h2 id="version-330-core"><strong>#version 330 core</strong><a href="#version-330-core"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>처음으로 버전 선언, OpenGL3.3 이상 부터, glsl 버전과 OpenGL과 맞아야함.</p><p>(ex, 4.2 == 420)</p><li><p>core profile 기능 사용 명시</p></ul><h2 id="in-vec3-apos"><strong>in vec3 aPos;</strong><a href="#in-vec3-apos"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>in 키워드 : 모든 입력 정점 속성을 선언</p><li><p>현재는 위치 데이터만 사용, 오직 하나의 정점 속성만 필요</p><li><p>vector 타입 은 1~4개의 실수, 각 정점은 3차원이기 때문에 vec3 타입 생성</p></ul><h2 id="layout-location--0"><strong>layout (location = 0)</strong><a href="#layout-location--0"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>입력 변수의 location을 설정</ul><h2 id="vector"><strong>vector</strong><a href="#vector"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>glsl의 벡터는 최대 크기가 4</p><li><p>vec.x, vec.y, vec.z , vec.w 로 접근</p><li><p>w : perspective division : 원근 분할 : 동차 좌표계에서 사용</p></ul><h2 id="gl_position"><strong>gl_Position</strong><a href="#gl_position"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>출력값 설정하기위해 미리 선언된(predefined) gl_Position 변수에 위치 데이터를 할당</p><li><p>vec4 타입이므로 형변환, w 값을 1.0으로 설정</p></ul><blockquote><p>현재 shader는 가장 간단한것: 입력데이터에 대해 처리 x, 간단히 출력값으로 전달, 먼저 입력데이터를 OpenGL의 표시할 수 있는 영역 내에 있는 좌표로 변환해야함</p></blockquote><h1 id="compiling-a-shader"><strong>Compiling a shader</strong></h1><ul><li>세이더 소스코드를 const char 로 저장.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vertexShaderSource</span> <span class="o">=</span> <span class="s">"#version 330 core</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"layout (location = 0) in vec3 aPos;</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"void main()</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"{</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><span class="se">\n</span><span class="s">"</span>
    <span class="s">"}</span><span class="se">\0</span><span class="s">"</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="glcreateshader"><strong>glCreateShader</strong><a href="#glcreateshader"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>OpenGL이 shader를 사용하려면, 런타임시에 소스코드를 동적으로 컴파일해야함</p><li><p>ID를 참조하여 shader 객체를 생성해야함.</p><li><p>그러기 위해선 unsigned int 타입으로 세이더를 저장해야하고,</p><li><p>glCreateShader함수로 생성해야함. (에러시 0리턴)</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">vertexShader</span><span class="p">;</span>
<span class="n">vertexShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>glCreateShader함수의 파라미터로 shader의 유형 입력 : <code class="language-plaintext highlighter-rouge">GL_VERTEX_SHADER</code></ul><h2 id="glshadersource"><strong>glShaderSource</strong><a href="#glshadersource"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glShaderSource</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vertexShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>그리고 소스코드를 객체에 첨부, shader를 컴파일<li><p>glShaderSource 함수는 shader 소스를 객체에 바인딩함.</p><ul><li><p>첫번째 파라미터(shader): shader 객체</p><li><p>두번째 파라미터(count): 소스코드가 몇개의 문자열인지 (string array의 크기)</p><li><p>세번째 파라미터(string): vertex shader의 실제 코드</p><li><p>네번째 파라미터(length): an array of string lengths</p></ul></ul><h2 id="glcompileshader-함수"><strong>glCompileShader 함수</strong><a href="#glcompileshader-함수"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>컴파일이 성공적으로 완료됬는지, 어떤 오류가 발생했는지 아래 함수들을 사용하면 알 수 있음</p><li><p>getShaderiv : 컴파일의 성공 유무</p><li><p>getGetShaderInfoLog : 에러메시지 확인,</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span>  <span class="n">success</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">infoLog</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="n">GL_COMPILE_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ERROR::SHADER::VERTEX::COMPILATION_FAILED</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">infoLog</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="fragment-shader-1"><strong>Fragment shader</strong></h1><ul><li><p>삼각형을 렌더링하기위해 생성해야할 쉐이더</p><li><p>픽셀의 출력 컬러값을 계산하는 것에 관한 쉐이더.</p><li><p>컬러값 = RGBA 의 리스트</p><li><p>각 값들의 범위 0.0 ~ 1.0</p><li><p>주어진 3개의 색으로 1600만개 이상의 색을 만들 수 있음.</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#version 330 core
</span><span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.2</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>오직 하나의 출력 변수</p><li><p>크기가 4인 벡터</p><li><p>최종 컬러를 정의</p></ul><h2 id="out-키워드"><strong>out 키워드</strong><a href="#out-키워드"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>출력값 선언</ul><h2 id="compile"><strong>compile</strong><a href="#compile"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>컴파일은 vertex와 비슷. GL_FRAGMENT_SHADER로 설정하면됨</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fragmentShader</span><span class="p">;</span>
<span class="n">fragmentShader</span> <span class="o">=</span> <span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span>
<span class="n">glShaderSource</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fragmentShaderSource</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="shader-program"><strong>Shader Program</strong></h1><ul><li><p>여러 shader를 결합한 마지막 연결된 버전</p><li><p>컴파일된 shader들을 shader program 객체로 연결(link)</p><li><p>객체를 렌더링할때 이 shader program을 활성화 하면됨.</p><li><p>활성화된 shader program 안의 shader 들은 렌더링 명령이 호출될 때 사용됨</p><li><p>입력정점 데이터을 GPU한테 보내고, 어떻게 처리해야하는지 vertex 와 fragment 를 통해 명령해야함.</p></ul><h2 id="연결"><strong>연결</strong><a href="#연결"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>한 세이더의 출력값을 다음 세이더의 입력값으로 연결</p><li><p>출력과 입력이 일치하지 않으면 linking error 발생</p></ul><h2 id="program-객체-생성"><strong>Program 객체 생성</strong><a href="#program-객체-생성"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shaderProgram</span><span class="p">;</span>
<span class="n">shaderProgram</span> <span class="o">=</span> <span class="n">glCreateProgram</span><span class="p">();</span>
</pre></table></code></div></div><ul><li><p>glCreateProgram 함수 : program을 생성, 생성된 객체의 ID를 리턴</p><li><p>glAttachShader 함수 : shader를 program 객체에 붙임.</p><li><p>glLinkProgram 사용하여 연결</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">vertexShader</span><span class="p">);</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">fragmentShader</span><span class="p">);</span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="연결여부확인"><strong>연결여부확인</strong><a href="#연결여부확인"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">glGetProgramiv</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="n">GL_LINK_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">glGetProgramInfoLog</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">infoLog</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="link-결과"><strong>link 결과</strong><a href="#link-결과"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>결과는 glUseProgram 함수를 호출하여 활성화할 수 있는 program 객체이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
</pre></table></code></div></div><p>glUseProgram 함수를 호출한 이후의 모든 shader와 렌더링 명령은</p><p>이 객체를 통해 내부의 세이더들을 사용하게됨</p><p>shader들을 program객체로 연결하고나면, shader 객체들을 제거해야함</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glDeleteShader</span><span class="p">(</span><span class="n">vertexShader</span><span class="p">);</span>
<span class="n">glDeleteShader</span><span class="p">(</span><span class="n">fragmentShader</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="linking-vertex-attributes"><strong>Linking Vertex Attributes</strong></h1><ul><li><p>OpenGL은 메모리 상의 정점 데이터를 어떻게 해석해야하는지 아직 모름</p><li><p>정점데이터를 vertex shader의 속성들과 어떻게 연결해야하는지 모름</p><li><p>OpenGL한테 알려줘야함</p></ul><h2 id="vertex"><strong>vertex</strong><a href="#vertex"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-proofer-ignore data-src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd0yxIx%2FbtraivR413v%2F1hP3GqxkOVtmhggP1TFIY0%2Fimg.png" alt="" /></p><ul><li><p>vertex shader 는 원하는 모든 입력들을 정점 속성의 형식으로 지정할 수 있도록해줌.</p><li><p>유연성이 좋은 반면, 입력 데이터의 어느 부분이 vertex shader의 어떠한 정점 속성과 맞는지 직접 지정해야함</p><li><p>삼각형의 3점 : float vertices[3]</p><ol><li><p>position data 는 32-비트(4 바이트)의 floating point values.</p><li><p>각 position 은 3가지값으로 구성됨</p><li><p>각 3개 값의 집합들은 tightly packed array임.(연속적, 공백이 없음)</p><li><p>데이터의 첫 번재 값은 버퍼의 시작지점에 있음.</p></ol></ul><h2 id="glvertexattribpointer함수"><strong>glVertexAttribPointer함수</strong><a href="#glvertexattribpointer함수"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>위의 정보들과 함께 OpenGL에게 vertex 데이터(vertex 속성)를 어떻게 해석해야하는지를 알려줄 수 있다.</p><li><p>파라미터 1 : vertex attribute, vertex shader code 에서 layout (location = 0) 코드를 사용하여 속성위치 지정, vertex 속성의 위치(location)을 0으로 설정하고, 데이터를 vertex 속성에 전달</p><li><p>파라미터 2 : vertex 속성의 크기를 지정, 이 vertex 속성은 vec3 타입, 따라서 3개의 값</p><li><p>파라미터 3 : 데이터의 타입, (glsl에서 vec* 은 실수형)</p><li><p>파라미터 4 : 데이터를 정규화할 것인지?, TRUE일 때 int, byte type 이면 =&gt; 값을 0(signed : -1) ~ 1 범위의 float 값으로 변환.</p><li><p>파라미터 5 : stride, 연속적인 vertex 속성의 크기를 알려줘야함. xyz 로 3개의 float 뒤에 다음 속성이 있음을 알려줌. 만약 값들이 빽빽하게 저장되어있으면 0으로 지정.</p><li><p>파라미터 6 : void* 타입, 형변환이 필요. 이는 버퍼에서 데이터가 시작하는 위치의 offset, 시작부분에 있으면 0으로지정</p></ul><blockquote><p>각 vertex 속성은 VBO에 의해 관리되는 메모리로부터 데이터를 받는다. 데이터를 받을 VBO (여러 VBO를 가질 수 있음)는 glVertexAttribPointer 함수를 호출할때 GL_ARRAY_BUFFER에 현재 바인딩된 VBO로 결정됨, glVertexAttribPointer 함수가 호출하기전에 미리 정의된 VBO가 바인딩되어있으므로 vertex 속성 0 이 해당하는 vertex 데이터와 연결된다.</p></blockquote><h2 id="glenablevertexattribarray-함수"><strong>glEnableVertexAttribArray</strong> <strong>함수</strong><a href="#glenablevertexattribarray-함수"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>vertex 속성 location을 전달하고 호출, vertex 속성을 사용할 수 있도록함</p><li><p>vertex 속성의 default : disabled</p></ul><h2 id="draw"><strong>draw</strong><a href="#draw"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>vertex buffer 객체를 사용하여 vertex 데이터를 초기화, vertex shader 와 fragment shader 설정</p><li><p>OpenGL에게 vertex 데이터가 vertex shader의 vertex 속성에 연결하면 모든 설정이 끝난다.</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// 0. copy our vertices array in a buffer for OpenGL to use</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// 1. then set the vertex attributes pointers</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// 2. use our shader program when we want to render an object</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>

<span class="c1">// 3. now draw the object</span>
<span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>
</pre></table></code></div></div><ul><li><p>객체를 그려야할 때마다 이 과정을 반복해야함</p><li><p>굉장히 번거로운 과정이기 때문에 이 객체를 바인딩하여 상태를 저장하는게 VAO</p></ul><h1 id="vertex-array-object"><strong>Vertex</strong> <strong>Array</strong> <strong>Object</strong></h1><h2 id="vao-vertex-array-object"><strong>VAO</strong> <strong>(Vertex Array Object)</strong><a href="#vao-vertex-array-object"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>vbo와 같이 바인딩될 수 있으며, vertex 속성 호출은 VAO에 저장됨.</p><li><p>vertex 속성 포인터를 구성할 때 오직 한 번 호출하기만 하면 되고 오브젝트를 그려야 할 때마다 해당 VAO를 바인딩하면 된다는 장점을 가짐.</p><li><p>서로 다른 vertex 데이터와 속성들을 다른 VAO를 바인딩함으로써 손쉽게 교체할 수 있음</p><li><p>설정한 모든 상태가 VAO 내부에 저장됨.</p></ul><h2 id="core-opengl"><strong>Core</strong> <strong>OpenGL</strong><a href="#core-opengl"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>정점 입력과 관련하여 VAO를 사용하도록 요구.</p><li><p>VAO를 바인딩하는데에 실패한다면 OpenGL은 어떤것이든 그리기를 거부할 수 도있음.</p></ul><h2 id="vertex-array-object는-다음-항목을-저장함"><strong>Vertex array object는 다음 항목을 저장함</strong><a href="#vertex-array-object는-다음-항목을-저장함"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-proofer-ignore data-src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLEZOA%2Fbtrai8oYkPg%2FtMTX2jM8SNdDPYQvk7Dexk%2Fimg.png" alt="" /></p><ol><li><p>glEnableVertexAttribArray 함수나 glDisableVertexAttribArray 함수의 호출</p><li><p>glVertexAttribPointer 함수를 통한 Vertex 속성의 구성</p><li><p>glVertexAttribPointer 함수를 통해 vertex 속성과 연결된 Vertex buffer objects(VBOs)</p></ol><h2 id="생성"><strong>생성</strong><a href="#생성"><i class="fas fa-hashtag"></i></a></h2></h2><p>VAO를 생성하는 과정 == VBO와 비슷한 과정</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VAO</span><span class="p">;</span>
<span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="glbindvertexarray"><strong>glBindVertexArray</strong><a href="#glbindvertexarray"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>VAO를 바인딩</p><li><p>그 후 부터 해당 VBO와 속성 포인터를 바인딩하여 구성하고</p><li><p>VAO를 나중에 사용하기 위해 언바인딩해야함.</p><li><p>오브젝트를 그리려면 간단히 원하는 세팅과 함께 VAO를 바인딩하면됨.</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..</span>

<span class="c1">// 1. bind Vertex Array Object</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>

<span class="c1">// 2. copy our vertices array in a buffer for OpenGL to use</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// 3. then set our vertex attributes pointers</span>
<span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>


<span class="p">[...]</span>

<span class="c1">// ..:: Drawing code (in render loop) :: ..</span>
<span class="c1">// 4. draw the object</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">someOpenGLFunctionThatDrawsOurTriangle</span><span class="p">();</span>
</pre></table></code></div></div><h2 id="vao"><strong>VAO</strong><a href="#vao"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>vertex 속성 구성을 저장</p><li><p>처음에 VAO(and thus the required VBO, attribute pointers)를 생성하고 설정</p><li><p>그리고 그것들을 나중에 사용하기위해 저장</p><li><p>오브젝트들 중에 하나를 그리고싶으면, 해당 VAO를 가지고와 바인딩</p><li><p>오브젝트를 그린 후 VAO를 언바인딩해야한다. (VAO와 VBO를 언바인딩)</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">VBO</span><span class="p">,</span> <span class="n">VAO</span><span class="p">;</span>
    <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VAO</span><span class="p">);</span>
    <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">VBO</span><span class="p">);</span>
    <span class="c1">// bind the Vertex Array Object first, then bind and set vertex buffer(s), and then configure vertex attributes(s).</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>

    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">VBO</span><span class="p">);</span>
    <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

    <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute's bound vertex buffer object so afterwards we can safely unbind</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// You can unbind the VAO afterwards so other VAO calls won't accidentally modify this VAO, but this rarely happens. Modifying other</span>
    <span class="c1">// VAOs requires a call to glBindVertexArray anyways so we generally don't unbind VAOs (nor VBOs) when it's not directly necessary.</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="삼각형-그리기"><strong>삼각형</strong> <strong>그리기</strong></h1><ul><li><p>OpenGL은 glDrawArrays 함수를 제공해줌.</p><li><p>현재 활성화된 shader, 이전에 정의된 vertex 속성구성, VBO의 vertex 데이터(VAO를 통해 간접적으로 바인딩된)들을 사용하여 primitives 를 그린다.</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">glUseProgram</span><span class="p">(</span><span class="n">shaderProgram</span><span class="p">);</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">VAO</span><span class="p">);</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="gldrawarrays-함수"><strong>glDrawArrays</strong> <strong>함수</strong><a href="#gldrawarrays-함수"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>파라미터 1 : primitive 타입 : GL_TRIANGLES</p><li><p>파라미터 2 : vertex 배열의 시작 인덱스</p><li><p>파라미터 3 : 몇개의 vertex를 그리는지</p></ul><p><a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp">전체 코드</a></p><h1 id="element-buffer-objectsabbreviated-to-ebo"><strong>Element</strong> <strong>Buffer</strong> <strong>Objects(abbreviated to EBO)</strong></h1><ul><li>정점들을 렌더링할 때 생각해야하는 것</ul><h2 id="사각형"><strong>사각형</strong><a href="#사각형"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>2개의 삼각형을 사용하여 사각형을 그릴 수 있음 (OpenGL 면의 최소단위는 삼각형)</p><li><p>다음과 같은 정점들로 생성할 수 있음</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// first triangle</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// top right</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom right</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// top left</span>
    <span class="c1">// second triangle</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom right</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom left</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>   <span class="c1">// top left</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="ebo가-필요한-이유"><strong>EBO가</strong> <strong>필요한</strong> <strong>이유</strong><a href="#ebo가-필요한-이유"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>정점을 명시하는데 중복되는것이 생김 (bottom right and top Left)</p><li><p>오버헤드가 50% 발생</p><li><p>4개의 정점만 저장하는 대신, 그리는 순서를 지정해야함</p></ul><h2 id="ebo"><strong>EBO</strong><a href="#ebo"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>VBO 와 같은 버퍼</p><li><p>어떠한 정점들을 그려야할 지 결정할 수 있는 인덱스들을 저장</p><li><p>indexed drawing이라고 불리는 문제 해결방법임.</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">vertices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// top right</span>
     <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom right</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">,</span>  <span class="c1">// bottom left</span>
    <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span>  <span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span>   <span class="c1">// top left</span>
<span class="p">};</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// note that we start from 0!</span>
    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>   <span class="c1">// first triangle</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>    <span class="c1">// second triangle</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>EBO 버퍼를 생성해야함</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">EBO</span><span class="p">;</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">EBO</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>VBO와 유사하게 glBufferData 사용하여 데이터 복사 : bind 와 unbind 사이에 설정해줘야함.</p><li><p>버퍼 타입 주의 : GL_ELEMENT_ARRAY_BUFFER</p></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">indices</span><span class="p">,</span> <span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>GL_ELEMENT_ARRAY_BUFFER를 타겟으로 지정하고, 바인딩하여 glDrawElements 함수를 사용하여 그림을 그림.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">EBO</span><span class="p">);</span>
<span class="n">glDrawElements</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>파라미터 2 : 최종적으로 6개의 정점을 그려야하기때문에 6</p><li><p>파라미터 3 : 인덱스의 타입</p><li><p>파라마터 4 : offset</p></ul><h2 id="gldrawelements"><strong>glDrawElements</strong><a href="#gldrawelements"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>GL_ELEMENT_ARRAY_BUFFER 를 타겟으로 현재 바인딩 된 EBO로 부터 인덱스를 가져옴</p><li><p>해당 EBO를 렌더링 할 때마다 바인딩해야한다는것을 의미</p></ul><h2 id="vao-1"><strong>VAO</strong><a href="#vao-1"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-proofer-ignore data-src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkVOwD%2FbtraiE9isq4%2FAaTXfPBqujtCVasiSg4wa1%2Fimg.png" alt="ebo" /></p><ul><li><p>VAO 는 하지만 EBO 또한 저장함.</p><li><p>VAO가 바인딩 되어있는 동안 EBO가 바인딩되면 VAO버퍼객체로 저장됨</p><li><p>VAO가 바인딩하면 자동으로 내부에 있는 EBO도 바인딩</p><li><p>타겟이 GL_ELEMENT_ARRAY_BUFFER 일 때의 glBindBuffer 함수호출 또한 저장,</p></ul><blockquote><p>언바인드 호출 또한 저장하기때문에 EBO 보다 VAO를 먼저 언바인드해야한다</p></blockquote><h2 id="wireframe-mode"><strong>Wireframe</strong> <strong>mode</strong><a href="#wireframe-mode"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</p><li><p>primitive 를 어떻게 그릴것인지</p><li><p>파라미터 1 : 후면과 전면 중 적용할것 선택</p><li><p>파라미터 2 : GL_LINE = 선으로 그리기 , GL_FILL = 채워서 그리기</p></ul><h1 id="출처"><strong>출처</strong></h1><p><a href="https://learnopengl.com/Getting-started/Hello-Triangle">LearnOpenGL - Hello Triangle</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/graphics/'>graphics</a>, <a href='/categories/graphics-opengl/'>graphics-opengl</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/opengl/" class="post-tag no-text-decoration" >opengl</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[learn-opengl] Triangle - RohRoh&url=https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[learn-opengl] Triangle - RohRoh&u=https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[learn-opengl] Triangle - RohRoh&url=https://nor-s.github.io/posts/2022/02/12/19/16/learn_opengl3/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2022/03/24/03/46/skeleton1/">[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 1</a><li><a href="/posts/2022/03/23/21/58/unreal-animation/">[UE4] 애니메이션 시작하기</a><li><a href="/posts/2022/03/22/04/45/bellman-ford/">[그래프] 벨만-포드 최단 경로 알고리즘</a><li><a href="/posts/2022/03/18/08/26/opengl22/">[learn-opengl] Advanced OpenGL: Framebuffers</a><li><a href="/posts/2022/03/18/09/28/opengl23/">[learn-opengl] Advanced OpenGL: Cubemaps</a></ul></div><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2022/03/18/08/26/opengl22/"><div class="card-body"> <em class="timeago small" date="2022-03-18 08:26:47 +0900" >Mar 18</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Framebuffers</h3><div class="text-muted small"><p> Framebuffers 지금까지 여러 스크린 버퍼들을 사용해왔다. color buffer: 컬러 값 작성 depth buffer: 깊이 정보 작성 stencil buffer: 특정 조건에 의해 해당 fragment를 폐기함. 이러한 버퍼들을 결합한 것을 Framebuffer라고...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/18/09/28/opengl23/"><div class="card-body"> <em class="timeago small" date="2022-03-18 09:28:02 +0900" >Mar 18</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Cubemaps</h3><div class="text-muted small"><p> Cubemaps 지금까지 2D 텍스처들을 사용해왔다. 다른 유형도 존재 이번에 다룰 유형은 여러 텍스처들을 하나의 텍스처로 매핑한 텍스처이다. 이를 cubemaps라고 부른다. Cubemap은 각 면을 형성하는 2D 텍스처들을 포함하고 있는 텍스처이다...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/20/01/05/opengl24/"><div class="card-body"> <em class="timeago small" date="2022-03-20 01:05:12 +0900" >Mar 20</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Advanced Data</h3><div class="text-muted small"><p> Advanced Data 버퍼들을 좀 더 흥미로운 방법과 texture들을 통해 shader에 많은 양의 data를 전달하는 흥미로운 방법이 존재한다. 이런 버퍼함수들과, 많은 양의 데이터를 저장하기 위해 텍스처 객체를 사용하는 방법을 다룰 것이다. OpenGL에서의 buffer는 특정 메모리를 관리...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2022/02/12/15/09/learn_opengl2/" class="btn btn-outline-primary" prompt="Older"><p>[learn-opengl] Creating a window</p></a> <a href="/posts/2022/02/14/00/17/learn_opengl4/" class="btn btn-outline-primary" prompt="Newer"><p>[learn-opengl] Shaders</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/Nor-s">roh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
