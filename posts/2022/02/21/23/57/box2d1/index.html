<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[box2d] box2d 문서" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Box2d" /><meta property="og:description" content="Box2d" /><link rel="canonical" href="https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/" /><meta property="og:url" content="https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/" /><meta property="og:site_name" content="RohRoh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-21T23:57:09+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[box2d] box2d 문서" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"dateModified":"2022-02-21T15:03:06+09:00","datePublished":"2022-02-21T23:57:09+09:00","description":"Box2d","mainEntityOfPage":{"@type":"WebPage","@id":"https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/"},"url":"https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/","@type":"BlogPosting","headline":"[box2d] box2d 문서","@context":"https://schema.org"}</script><title>[box2d] box2d 문서 | RohRoh</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RohRoh"><meta name="application-name" content="RohRoh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/commons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">RohRoh</a></div><div class="site-subtitle font-italic">my blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Nor-s" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[box2d] box2d 문서</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[box2d] box2d 문서</h1><div class="post-meta text-muted"><div> <em> <a href="https://github.com/Nor-s">roh</a> </em></div><div class="d-flex"><div> <span> <em class="timeago" date="2022-02-21 23:57:09 +0900" data-toggle="tooltip" data-placement="bottom" title="Mon, Feb 21, 2022, 11:57 PM +0900" >Feb 21</em> </span> <span> Updated <em class="timeago" date="2022-02-21 15:03:06 +0900 " data-toggle="tooltip" data-placement="bottom" title="Mon, Feb 21, 2022, 3:03 PM +0900" >Feb 21</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="14434 words"> <em>80 min</em> read</span></div></div></div><div class="post-content"><h1 id="box2d-">Box2d</h1><ul><li><a href="#1-box2d-241">1. <strong>box2d 2.4.1</strong></a><ul><li><a href="#11-object">1.1. <strong>object</strong></a><li><a href="#12-module">1.2. <strong>module</strong></a><li><a href="#13-units">1.3. Units</a><li><a href="#14-factories-and-definitions">1.4. Factories and Definitions</a></ul><li><a href="#2-hello-box2d">2. <strong>Hello Box2D</strong></a><ul><li><a href="#21-creating-a-world">2.1. <strong>Creating a World</strong></a><li><a href="#22-creating-a-groundbox">2.2. <strong>Creating a GroundBox</strong></a><ul><li><a href="#221-step1">2.2.1. <strong>step1</strong></a><li><a href="#222-step2">2.2.2. <strong>step2</strong></a><li><a href="#223-step3">2.2.3. <strong>step3</strong></a><li><a href="#224-step4">2.2.4. <strong>step4</strong></a><li><a href="#225-about-fixture">2.2.5. <strong>about fixture</strong></a></ul><li><a href="#23-creating-a-dynamic-body">2.3. <strong>Creating a Dynamic Body</strong></a><li><a href="#24-simulating-the-world">2.4. <strong>Simulating the world</strong></a><ul><li><a href="#241-time-step">2.4.1. <strong>time step</strong></a><li><a href="#242-constraint-solver">2.4.2. <strong>constraint solver</strong></a><li><a href="#243-simulation-loop">2.4.3. <strong>simulation loop</strong></a></ul><li><a href="#25-cleanup">2.5. <strong>Cleanup</strong></a></ul><li><a href="#3-common-module">3. <strong>Common Module</strong></a><ul><li><a href="#31-settings">3.1. <strong>settings</strong></a><li><a href="#32-memory-management">3.2. <strong>Memory Management</strong></a><li><a href="#33-math">3.3. <strong>Math</strong></a></ul><li><a href="#4-collision-module">4. <strong>Collision Module</strong></a><ul><li><a href="#41-shape">4.1. <strong>shape</strong></a><ul><li><a href="#411-circle-shapes">4.1.1. <strong>Circle Shapes</strong></a><li><a href="#412-polygon-shapes">4.1.2. <strong>PolyGon Shapes</strong></a><li><a href="#413-edge-shapes">4.1.3. <strong>Edge Shapes</strong></a><li><a href="#414-chain-shapes">4.1.4. <strong>Chain Shapes</strong></a></ul><li><a href="#42-geometric-queries">4.2. <strong>Geometric queries</strong></a><ul><li><a href="#421-shape-point-test">4.2.1. <strong>Shape Point Test</strong></a><li><a href="#422-shape-ray-cast">4.2.2. <strong>Shape Ray Cast</strong></a></ul><li><a href="#43-pairwise-functions">4.3. <strong>Pairwise Functions</strong></a><ul><li><a href="#431-overlap">4.3.1. <strong>Overlap</strong></a><li><a href="#432-contact-manifolds">4.3.2. <strong>Contact manifolds</strong></a><li><a href="#433-distance">4.3.3. <strong>Distance</strong></a><li><a href="#434-time-of-impact">4.3.4. <strong>Time of impact</strong></a></ul><li><a href="#44-dynamic-tree">4.4. <strong>Dynamic Tree</strong></a><li><a href="#45-broad-phase">4.5. <strong>Broad-phase</strong></a></ul><li><a href="#5-dynamics-module">5. <strong>Dynamics Module</strong></a><ul><li><a href="#51-bodies">5.1. <strong>Bodies</strong></a><ul><li><a href="#511-b2_staticbody">5.1.1. <strong>b2_staticBody</strong></a><li><a href="#512-b2_kinematicbody">5.1.2. <strong>b2_kinematicBody</strong></a><li><a href="#513-b2_dynamicbody">5.1.3. <strong>b2_dynamicBody</strong></a><li><a href="#514-body-definition">5.1.4. <strong>Body Definition</strong></a><ul><li><a href="#5141-body-type">5.1.4.1. <strong>Body Type</strong></a><li><a href="#5142-position-and-angle">5.1.4.2. <strong>Position and Angle</strong></a><li><a href="#5143-damping">5.1.4.3. <strong>Damping</strong></a><li><a href="#5144-gravity-scale">5.1.4.4. <strong>Gravity Scale</strong></a><li><a href="#5145-sleep-parameters">5.1.4.5. <strong>Sleep Parameters</strong></a><li><a href="#5146-fixed-rotation">5.1.4.6. <strong>Fixed Rotation</strong></a><li><a href="#5147-bullets">5.1.4.7. <strong>Bullets</strong></a><li><a href="#5148-activation">5.1.4.8. <strong>Activation</strong></a><li><a href="#5149-user-data">5.1.4.9. <strong>User Data</strong></a></ul><li><a href="#515-body-factory">5.1.5. <strong>Body Factory</strong></a><li><a href="#516-using-a-body">5.1.6. <strong>Using a Body</strong></a><li><a href="#517-mass-data">5.1.7. <strong>Mass Data</strong></a><li><a href="#518-state-information">5.1.8. <strong>State Information</strong></a><li><a href="#519-position-and-velocity">5.1.9. <strong>Position and Velocity</strong></a><li><a href="#5110-fiorces-and-impulses">5.1.10. <strong>Fiorces and Impulses</strong></a><li><a href="#5111-coordinate-transformations">5.1.11. <strong>Coordinate Transformations</strong></a><li><a href="#5112-acessing-fixtures-joints-and-contacts">5.1.12. <strong>Acessing Fixtures, Joints, and Contacts</strong></a></ul><li><a href="#52-fixtures">5.2. <strong>Fixtures</strong></a><ul><li><a href="#521-fixture-creation">5.2.1. <strong>Fixture Creation</strong></a><li><a href="#522-density">5.2.2. <strong>Density</strong></a><li><a href="#523-friction">5.2.3. <strong>Friction</strong></a><li><a href="#524-restitution">5.2.4. <strong>Restitution</strong></a><li><a href="#525-filtering">5.2.5. <strong>Filtering</strong></a><li><a href="#526-sensors">5.2.6. <strong>Sensors</strong></a></ul><li><a href="#53-joints">5.3. <strong>Joints</strong></a><li><a href="#54-contacts">5.4. <strong>Contacts</strong></a><li><a href="#55-world">5.5. <strong>World</strong></a><ul><li><a href="#551-creating-and-destroying-a-world">5.5.1. <strong>Creating and Destroying a World</strong></a><li><a href="#552-using-a-world">5.5.2. <strong>Using a World</strong></a><ul><li><a href="#5521-simulation">5.5.2.1. <strong>Simulation</strong></a><li><a href="#5522-exploring-the-world">5.5.2.2. <strong>Exploring the World</strong></a><li><a href="#5523-aabb-queries">5.5.2.3. <strong>AABB Queries</strong></a><li><a href="#5524-ray-casts">5.5.2.4. <strong>?Ray Casts?</strong></a></ul></ul></ul><li><a href="#6-loose-ends">6. <strong>Loose Ends</strong></a><ul><li><a href="#61-user-data">6.1. <strong>User Data</strong></a><li><a href="#62-custom-user-data">6.2. <strong>Custom User Data</strong></a><li><a href="#63-implicit-destruction">6.3. <strong>Implicit Destruction</strong></a><li><a href="#64-pixels-and-coordinate-systems">6.4. <strong>Pixels and Coordinate Systems</strong></a><li><a href="#65-debug-drawing">6.5. <strong>Debug Drawing</strong></a><li><a href="#66-limitations">6.6. <strong>Limitations</strong></a></ul><li><a href="#7-links">7. links</a></ul><h1 id="1-box2d-241">1. <strong>box2d 2.4.1</strong></h1><ul><li>C++로 작성된 강체 시뮬레이션 라이브러리<li>b2라는 접두어의 타입을 가지고 있음.</ul><h2 id="11-object">1.1. <strong>object</strong><a href="#11-object"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ol><li>shape: 원이나 폴리곤 같은 2차원 기하객체<li>rigid body: 물체를 구성하는 두입자의 거리가 절대로 바뀌지 않는 물체, 단순화된, 가정된 형태<li>fixture: body에 shape를 연결, 밀도, 마찰, 반발력과 같은 물체 속성 추가<li><p>constraint: bodies에서 자유도를 제거하는 물리적 연결.</p><ul><li>2d body: 2개의 이동축과 1개의 회전축. 즉, 3개의 자유도를 가진다.<li>만약 body를 벽에 고정한다면 벽에 body를 constraint한것. 그 고정점을 기준으로 body를 회전만 시킬 수 있으므로 이는 2개의 자유도를 제거한것과 같다.</ul><li><p>constract constraint: 강체의 침투(강체가 부딪혔을 때 움푹파이는 정도)를 막기 위해, friction and restitution을 시뮬레이션 할 수 있게한다. (직접 만들 수 없고, Box2D가 알아서 생성)</p><li>joint: 2가지 이상의 body를 하나로 만들어주는 constraint. Box2D는 revolute, prismatic, distance와 같은 joint 타입을 제공한다. 몇몇 joint는 limits and motors를 가지고 있다.<ul><li>joint limit: 조인트의 움직이는 범위를 제한(사람의 팔꿈치 처럼)<li>joint motor: 조인트 모터는 조인트의 허용되는 각도에 따라 연결된 바디의 움직임을 유발한다. (모터를 팔꿈치를 회전시키기 위해 사용할 수 있다.)</ul><li><p>world: 프로그래밍상의 물리공간. 여러 물리공간을 만들 수 있지만 권장되지 않는다.</p><li>solver: 물리공간은 solver를 가진다. 좀 더 나은 타이머를 사용할 수 있게 해주며, 접촉과 joint constraints을 해결해준다. (Box2D에서는 N개의 제약을 하나씩 수행하는 iterative solver를 가짐)<li>continuous collision: solver는 물체를 점진적(discrete time steps)으로 이동시킴. 간섭(intervention)이 없으면 turnneling effect가 발생할 수 있음<ul><li>turnneling effect: 입자가 벽을 넘어 마치 공이동을 하는것처럼 보이는것(파동의 성질)<li>Box2D에서는 이를 처리하기위해 특별한 알고리즘을 포함하고 있음.<li>collision 알고리즘: 두 body의 움직임을 보간(iterpolate) 하여 첫번째 충돌시간(TOI)를 찾는다. body를 첫 충돌시점으로 이동시킨다음 충돌을 해결하는 하위 단계 solver를 사용하여 해결</ul></ol><h2 id="12-module">1.2. <strong>module</strong><a href="#12-module"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>common -&gt; collision -&gt; dynamics</p><p>common -&gt; dynamics</p><ul><li>3가지 모듈(Common, Collision, Dynamics)로 구성된다.<li>Common: allocation, mathm, settings와 관련된 코드를 가진다.<li>Collision: shapes, broad-phase, collision function/queries를 정의한다.<li>Dynamic: simulation world, bodies, fixture, joints를 제공.</ul><h2 id="13-units">1.3. Units<a href="#13-units"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>부동소수점, tolerances(허용오차) 사용,<li>허용오차는 미터, 킬로그램, 초(mks)단위에 잘 동작하도록 조정되어있다. - 그렇기 때문에 움직이는 물체의 크기는 대략 0.1~10미터 사이로 유지해야한다. - 환경(environment)과 actors를 렌더링할 때 스케일링 시스템을 사용해야한다. - Box2D테스트 베드는 OpenG 뷰포트 변환을 사용하여 이를 수행한다.<blockquote><p>주의! 픽셀을 한 단위로하면 잘못된 시뮬레이션과 이상한 동작으로 이어진다.</p></blockquote><li>특히 0.1~10 미터 사이에서 잘 동작한다.<li>static shapes은 50미터까지 잘 동작한다.<li><p>전체 world size가 2km 보다 커지면 정밀도를 잃게되어 불안정해진다.</p><ul><li><a href="https://box2d.org/documentation/classb2_world.html#afc33e20e64252c5be115216051408047">b2World::ShiftOrigin</a>을 통해 더 큰 world를 지원한다.</ul><li><p>Box2D는 degrees가 아니라 <strong>radians</strong>을 사용한다. 즉, 바디의 회전은 라디안으로 값을 저장하고 증가 또는 축소함으로써 이루어진다.</p><ul><li>각도의 크기가 커질경우 정규화해야한다. (<a href="b2Body::SetTransform">b2Body::SetTransform</a>)</ul><li>length units을 변경하기위해서는 b2_lengthUnitsPerMeter를 수정해야한다. b2_user_settings.h에 있는 <code class="language-plaintext highlighter-rouge">B2_USER_SETTING</code>를 통해 병합충돌을 피할 수 있다. (<a href="https://box2d.org/documentation/b2__settings_8h.html">b2_settings.h</a>)</ul><h2 id="14-factories-and-definitions">1.4. Factories and Definitions<a href="#14-factories-and-definitions"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>빠른 메모리관리는 Box2D 설계에서 핵심적인 역할을 한다.<li>그래서 <a href="https://box2d.org/documentation/classb2_body.html">b2Body</a> 또는 <a href="https://box2d.org/documentation/classb2_joint.html">b2Joint</a> 를 생성할 때, (b2World)[https://box2d.org/documentation/classb2_world.html]에서 factory functions을 호출할 필요가 있다.<ul><li>이러한 타입을 다른 방식으로 할당해서는 안된다.<li><a href="https://box2d.org/documentation/classb2_world.html#a9323d553e4c132b26d8741b457d7c034">CreateBody</a><li><a href="https://box2d.org/documentation/classb2_world.html#a8a408c367fe133530f3e577c667d1efd">CreateJoint</a></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">b2Body</span><span class="o">*</span> <span class="n">b2World</span><span class="o">::</span><span class="n">CreateBody</span><span class="p">(</span><span class="k">const</span> <span class="n">b2BodyDef</span><span class="o">*</span> <span class="n">def</span><span class="p">)</span>
<span class="n">b2Joint</span><span class="o">*</span> <span class="n">b2World</span><span class="o">::</span><span class="n">CreateJoint</span><span class="p">(</span><span class="k">const</span> <span class="n">b2JointDef</span><span class="o">*</span> <span class="n">def</span><span class="p">)</span>
<span class="c1">// &lt;-&gt;</span>
<span class="kt">void</span> <span class="n">b2World</span><span class="o">::</span><span class="n">DestroyBody</span><span class="p">(</span><span class="n">b2Body</span><span class="o">*</span> <span class="n">body</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">b2World</span><span class="o">::</span><span class="n">DestroyJoint</span><span class="p">(</span><span class="n">b2Joint</span><span class="o">*</span> <span class="n">joint</span><span class="p">)</span>
</pre></table></code></div></div><ul><li><p>body 또는 joint를 생성할 때, 구축하는데 필요한 모든 정보를 정의해서 제공해야한다.</p><ul><li>이를 통해 객체 생성에서의 오류를 방지할 수 있다.<li>함수의 파라미터수를 줄일 수 있다.<li>합리적인 기본값을 제공할 수 있다.<li>접근자(accessors)의 수를 줄일 수 있다.</ul><li><p>fixtures(shapes)는 body의 부모가 되어야하므로 b2Body에서 팩토리 매서드를 사용하여 생성 및 소며로딘다.</p><ul><li><a href="https://box2d.org/documentation/classb2_body.html#a40dda91b34418bb40e31e2db9b1b76a5">CreateFixture</a></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">CreateFixture</span><span class="p">(</span><span class="k">const</span> <span class="n">b2FixtureDef</span><span class="o">*</span> <span class="n">def</span><span class="p">)</span>
<span class="n">b2Fixture</span><span class="o">*</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">CreateFixture</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Shape</span><span class="o">*</span> <span class="n">shape</span><span class="p">,</span> <span class="kt">float</span> <span class="n">density</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">DestroyFixture</span><span class="p">(</span><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixture</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>Factories 는 정의에 대한 참조를 유지하지 않는다.<li>따라서 스택에 정의를 생성하고 임시 리소스에 보관할 수 있다.</ul><h1 id="2-hello-box2d">2. <strong>Hello Box2D</strong></h1><ul><li>커다란 large ground box와 small dynamic box에 대한 예제<li>이 코드에는 그래픽이 포함되어있지 않다.<li>시간에 따른 상자 위치의 콘솔에 텍스트 출력만 표시된다.</ul><h2 id="21-creating-a-world">2.1. <strong>Creating a World</strong><a href="#21-creating-a-world"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>모든 Box2D 프로그램은 <a href="https://box2d.org/documentation/classb2_world.html">b2World</a>객체 생성으로 시작한다.<ul><li>b2World: 메모리, 객체, 시뮬레이션을 관리하는 physics hub이다.<li>physics world를 스택, 힙, data section에 할당할 수 있다.</ul><li>Box2D world를 생성하는 것은 아래와 같이 gravity vector를 정의하기만 하면 된다.(중력의 방향과 중력값)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2Vec2</span> <span class="nf">gravity</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2World</span> <span class="nf">world</span><span class="p">(</span><span class="n">gravity</span><span class="p">);</span>
</pre></table></code></div></div><blockquote><p>주의! scope를 조심해야한다. (할당과 해제)</p></blockquote><h2 id="22-creating-a-groundbox">2.2. <strong>Creating a GroundBox</strong><a href="#22-creating-a-groundbox"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li><strong>Bodies</strong> 는 다음과 같은 단계를 거쳐 구축된다.<ol><li>body의 position, damiping, etc. 을 정의<li>world object를 사용하여 body 생성<li>fixtures 정의 (shape, friction, density, etc.)<li>fixtures을 body에 생성(붙임)</ol></ul><h3 id="221-step1">2.2.1. <strong>step1</strong><a href="#221-step1"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>ground body 생성해야한다.<li>이를 위해 body정의가 필요하다.<li>body 정의를 사용하여 ground body의 초기 position를 지정해야한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">groundBodyDef</span><span class="p">;</span>
<span class="n">groundBodyDef</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="n">f</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="222-step2">2.2.2. <strong>step2</strong><a href="#222-step2"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body 정의를 world object로 넘겨 ground body를 생성한다.<li>world object는 body정의에 대한 참조를 유지하지 않는다.<ul><li>body는 기본적으로 static이다.<li>static bodies는 다른 static bodies과 충돌하지 않으며 움직일 수 없다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">b2Body</span><span class="o">*</span> <span class="n">groundBody</span> <span class="o">=</span> <span class="n">world</span><span class="p">.</span><span class="n">CreateBody</span><span class="p">(</span><span class="o">&amp;</span><span class="n">groundBodyDef</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="223-step3">2.2.3. <strong>step3</strong><a href="#223-step3"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>ground polygon을 생성해야한다.<li><code class="language-plaintext highlighter-rouge">SetAsBox</code> shortcut을 사용하여 ground polygon을 box shape로 형성하고, box가 부모 몸체의 원점에 중심이 되도록해야한다.<ul><li><a href="https://box2d.org/documentation/classb2_polygon_shape.html#ae356d825f51f7b827edb0c71fec781f8">SetAsBox()</a><li><a href="https://box2d.org/documentation/classb2_polygon_shape.html">b2PolygonShape</a></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2PolygonShape</span> <span class="n">groundBox</span><span class="p">;</span>
<span class="n">groundBox</span><span class="p">.</span><span class="n">SetAsBox</span><span class="p">(</span><span class="mf">50.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">10.0</span><span class="n">f</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>setAsBox는 half width 그리고 half height (extents를 인자로 받는다.<li>즉, 위 코드는 100 units width(x-axis), 20units tall(y-axis)를 가지는 ground box인 것이다.<ul><li>box2D는 mks 단위로 조정됬으므로, extents를 meters로 고려할 수 있다.<li>Box2D는 일반적으로 객체가 일반적인 실제 객체 크기일 때 가장 잘 작동한다. (ex. box2d를 사용하여 glaciers, dust 파티클의 움직임을 모델링하는것은 좋은 생각이 아님)</ul></ul><h3 id="224-step4">2.2.4. <strong>step4</strong><a href="#224-step4"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>shape fixture를 생성하는것이 마지막 단계이다.<li>간단한 방법으로 fixture 기본값을 사용하는것이다.<li>두번째 파라미터는 shape의 입방미터당 킬로그램이며 밀도를 나타낸다.<li>static body는 기본값으로 0이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">groundBody</span><span class="o">-&gt;</span><span class="n">CreateFixture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">groundBox</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
</pre></table></code></div></div><blockquote><p><em>box2D는 shape에 대한 참조를 유지하지 않는다. data를 새로운 b2Shape 객체로 복사(clone)한다.</em></p></blockquote><h3 id="225-about-fixture">2.2.5. <strong>about fixture</strong><a href="#225-about-fixture"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>모든 fixture는 부모 body가 있어야한다. (static 이더라도) 하지만, 모든 static fixtures를 single static body에 붙일 수 있다.</p><li><p>fixture를 사용하여 body에 shape를 붙일 때, shape의 좌표는 body의 local이 된다. 그래서 body가 움직이면, shape 또한 움직인다. fixtures의 world transform은 부모 body에서 상속받는다.</p><li><p>fixture는 body 와 독립된 transform 을 가지고 있지 않다.</p><li><p>그래서 body에서 shape를 움직이지 않는다. body에 있는 모양을 이동하거나 수정하는 것은 지원되지 않는다.</p><ul><li>이유: 모양이 변형되는 body는 강체(rigid body) 가 아니지만, box2D는 rigidbody engine이다. Bodx2D에서 만들어진 많은 가정은 강체 모델을 기반이므로, 이를 위반하면 많은것들이 제대로 작동하지 않게된다.</ul></ul><h2 id="23-creating-a-dynamic-body">2.3. <strong>Creating a Dynamic Body</strong><a href="#23-creating-a-dynamic-body"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>ground body를 만든 것처럼 똑같이 dynamic body를 만들 수 있다.<li><p>치수를 제외한 차이점은 dynamic body의 mass 속성을 설정해야한다는 것이다.</p><li>첫번째로 <code class="language-plaintext highlighter-rouge">CreateBody</code> 를 사용하여 body를 생성해야한다.<li>기본적으로 bodies는 static이므로 b2BodyType을 설정해야한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">b2_dynamicBody</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">4.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Body</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">world</span><span class="p">.</span><span class="n">CreateBody</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bodyDef</span><span class="p">);</span>
</pre></table></code></div></div><blockquote><p>Caution: You must set the body type to b2_dynamicBody if you want the body to move in response to forces.</p></blockquote><ul><li>다음으로 fixture 정의를 통해 polygon shape를 생성하고 달아줘야한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">b2PolygonShape</span> <span class="n">dynamicBox</span><span class="p">;</span>
<span class="n">dynamicBox</span><span class="p">.</span><span class="n">SetAsBox</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>

<span class="n">b2FixtureDef</span> <span class="n">fixtureDef</span><span class="p">;</span>
<span class="n">fixtureDef</span><span class="p">.</span><span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dynamicBox</span><span class="p">;</span>
<span class="n">fixtureDef</span><span class="p">.</span><span class="n">density</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">fixtureDef</span><span class="p">.</span><span class="n">friction</span> <span class="o">=</span> <span class="mf">0.3</span><span class="n">f</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>여기서 주목할 점은 density가 1(default = 0) 그리고 friction을 0.3f로 설정한 점이다.</ul><blockquote><p>Caution: A dynamic body should have at least one fixture with a non-zero density. Otherwise you will get strange behavior.</p></blockquote><ul><li>이제 fixture 정의를 가지고 fixture를 생성할 수 있다.<li>이 때 자동적으로 body의 mass가 업데이트된다.<li>또한, 다수의 fixtures를 추가할 수 있다. 이 경우 각각은 전체 mass에 기여한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">body</span><span class="o">-&gt;</span><span class="n">CreateFixture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixtureDef</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="24-simulating-the-world">2.4. <strong>Simulating the world</strong><a href="#24-simulating-the-world"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>ground box 그리고 dynamic box를 초기화했으므로, 이제 시뮬레이션 할 준비만 몇가지 하면 된다.</ul><h3 id="241-time-step">2.4.1. <strong>time step</strong><a href="#241-time-step"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Box2D는 적분기(integrator) 라는 컴퓨팅 알고리즘을 이용한다.<ul><li>적분기: 물리 방정식을 이산시간에 대해서 시뮬레이션하는 알고리즘<ul><li>이산시간: 시간을 일정한 간격으로 잘라 사용하는 것을 의미</ul></ul><li>이산시간은 전통적인 게임루프(플립북에서 대상이 움직이는 하나의 scene)과 같이 진행된다. 그래서 Box2D를 위한 time step이 필요하다.<li>일반적으로 게임에서 물리엔진은 60프레임, 60Hz 또는 1/60초 만큼 빠른 time step을 사용한다.<li>더 큰 time steps를 설정할 수 있지만, 이 경우 생성한 world 객체에 대한 정의를 주의깊게 준비해야한다.<li>time steps는 고정된 것이 좋다. 가변 time step은 다양한 결과를 야기시킨다. 이것은 디버깅하기도 어려우므로, 진행하는 프레임에 time step을 엮는것은 권장되지 않는다.<li>아래와 같이 간단하게 time step을 설정할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">timeStep</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">60.0</span><span class="n">f</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="242-constraint-solver">2.4.2. <strong>constraint solver</strong><a href="#242-constraint-solver"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>추가적으로 적분기에 constraint solver를 이용할 수 있다.</p><ul><li>constraint solver: 시뮬레이션 constraint에 대해서 해결책을 제공. 하나의 constraint은 완전하게 해결 할 수 있다. 그러나 하나의 constraint을 해결할 때 또 다른 제한이 방해할 수 있다. 좋은 해결책은 모든 제한에 대해서 여러번 반복하는것.</ul><li><p>constraint solver의 2개의 단계</p><ul><li>속도 단계(velocity phase): solver는 body를 정확하게 움직이기 위해 충격(impulses)을 계산한다.<li>위치 단계(position phase): solver는 겹침(overlap) 과 조인트 분리의 오차를 줄이기 위해서 body의 position을 조정한다.<li>각각의 단계는 자기자신의 iteration count를 가지고 있으며, 위치 단계에서는 만약 오차가 작다면 반복을 일찍 종료한다.</ul><li>Box2D는 속도 단계의 iteration count는 8을 권장하며, 위치 단계의 iteration count는 3을 권장한다.<li>이를 조정하는 것은 성능과 정확성 사이의 trade-off 임을 알아야한다.<ul><li>적은 숫자: 속도를 증가, 정확도는 감소</ul><li>간단한 예제이므로 아래와 같이 설정하였다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">int32</span> <span class="n">velocityIterations</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">positionIterations</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>time step 과 iteration count는 완전히 상관이 없으며, 한 iteration은 sub-step이 아니다.<li>하나의 solver iteration은 time step내의 모든 constraint를 한번씩은 통과해야한다. (최소한 한번)</ul><h3 id="243-simulation-loop">2.4.3. <strong>simulation loop</strong><a href="#243-simulation-loop"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>시뮬레이션 루프는 게임루프에 통합된다.<li>게임 루프 전체의 각각의 단계에서 <a href="https://box2d.org/documentation/classb2_world.html#a82c081319af9a47e282dde807e4cd7b8">b2World::step</a>을 호출할 수 있다.<li><p>일반적으로 게임 루프 프레임과 물리 time step에 의존하기 때문에 상황마다 다르지만 일반적으로 한번만 호출하면 충분하다.</p><li>이 예제는 그래픽이 없고, 아래의 코드는 dynamic body의 위치와 회전을 출력한다. 아래는 총 1 초의 시뮬레이션 시간 동안 60 개의 시간 단계를 시뮬레이션하는 시뮬레이션 루프이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">int32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">world</span><span class="p">.</span><span class="n">Step</span><span class="p">(</span><span class="n">timeStep</span><span class="p">,</span> <span class="n">velocityIterations</span><span class="p">,</span> <span class="n">positionIterations</span><span class="p">);</span>
    <span class="n">b2Vec2</span> <span class="n">position</span> <span class="o">=</span> <span class="n">body</span><span class="o">-&gt;</span><span class="n">GetPosition</span><span class="p">();</span>
    <span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">body</span><span class="o">-&gt;</span><span class="n">GetAngle</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%4.2f %4.2f %4.2f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">angle</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>출력 결과는 상자가 떨어지고 ground box에 착륙하는 것을 보여준다</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>0.00 4.00 0.00
0.00 3.99 0.00
0.00 3.98 0.00
...
0.00 1.25 0.00
0.00 1.13 0.00
0.00 1.01 0.00
</pre></table></code></div></div><h2 id="25-cleanup">2.5. <strong>Cleanup</strong><a href="#25-cleanup"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>world 가 scope를 벗어나게되거나 포인터에서 delete가 호출되어 삭제될 때, 모든 bodies, fixtures, joint는 메모리에서 해제된다.<li>이처럼 무효화되기 때문에. world의 객체들을 가리키는 모든 포인터들을 잘 관리해야한다.<li>이를 통해 성능을 얻었고, 코드도 간결해졌다.</ul><h1 id="3-common-module">3. <strong>Common Module</strong></h1><ul><li>settings, memory management, vector math</ul><h2 id="31-settings">3.1. <strong>settings</strong><a href="#31-settings"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>box2D에 정의 된 타입들을 통해 구조의 크기를 쉽게 결정가능하다.<li>b2Settings.h 에 정의된 상수들, 일반적으로 조정할 필요가 없다.<li>부동소수점 연산을 하기 때문에 round-off 오류를 위한 수치 허용오차가 정의되어있음 (일부는 상대적, 절대적 허용오차는 MKS단위 사용)<li>b2Version 구조체로 box2d의 현재 버전을 알아낼 수 있다.</ul><h2 id="32-memory-management">3.2. <strong>Memory Management</strong><a href="#32-memory-management"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>많은 수의 작은 객체(50-300바이트)를 할당하는 경향이 있는 box2d.<li>작은 객체에 대해 malloc, new 를 통해 시스템 힙을 사용하는 것은 비효율적이며 단편화를 일으킬 수 있다.<li>이러한 객체에 대한 힙 메모리를 효율적으로 제공할 수 있는 할당자가 필요<li>small object allocator (SOA): <a href="https://box2d.org/documentation/classb2_block_allocator.html">b2BlockAllocator</a><ul><li>SOA는 다양한 크기의 확장 가능한 여러 풀을유지한다, 메모리에 대한 요청이 이루어지면 SOA는 요청된 크기에 가장 적합한 메모리 블록을 반환한다. 블록이 해제되면 풀로 반환된다. 이러한 작업은 모두 빠르며 힙 트래픽이 발생하지 않는다.</ul><li><p>Box2D는 SOA를 사용하기 때문에 절대로 body, fixture, joint를 new와 malloc을 하면 안된다.(하지만 b2World는 할당 가능)</p><ul><li>b2World: body, fixture, joint를 생성할 수 있는 factories 제공하는 클래스</ul><li>[참고] time step 실행도중 Box2D는 임시 작업 공간 메모리가 필요하다. 그러므로 b2StackAllocator 라는 스택할당자를 사용하여 단계별 힙 할당을 방지한다. (스택할당자와 상호작용할 필요 없다.)</ul><h2 id="33-math">3.3. <strong>Math</strong><a href="#33-math"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>간단한 벡터, 행렬 연산 모듈을 포함한다.<li>Box2D 내부 요구 사항에 맞게 설계되어있다.</ul><h1 id="4-collision-module">4. <strong>Collision Module</strong></h1><ul><li>shapes, dynamic tree, broad-phase(큰 시스템에서 충돌처리 가속을 위한)</ul><h2 id="41-shape">4.1. <strong>shape</strong><a href="#41-shape"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>충돌 기하학을 설명, 물리 시뮬레이션과 독립적으로 사용됨.<li>최소한 rigid bodies과 어떻게 연결되는지 방법을 이해애야한다.<li><a href="https://box2d.org/documentation/classb2_shape.html">b2Shape</a> 클래스로 구현되어있고, 아래와 같은 함수들이 정의되어있다.<ul><li>shape가 겹쳤는지 테스트.<li>shape에 대한 ray cast 수행<li>shape의 AABB 계산<li>shape의 mass 속성 계산</ul><li>게다가, 각각의 shape는 type member, radius가 있다.<ul><li>radius: 다각형(polygons)에도 적용가능.</ul><li>shape는 body에 대한 정보가 없으며, dynamics system과 별개이다.<li>shape는 크기와 성능에 최적화된 컴팩트한 형태로 저장된다.<li>따라서 shape는 쉽게 움직이지 않는다. - 수동적으로 정점 위치를 설정해야한다. - 하지만 fixture를 사용하여 형상을 body에 붙이면, shape는 host body와 함께 이동한다.</ul><blockquote><p>shape가 body에 연결되지 않은 경우, 그것의 정점이 world-space로 표현된다.</p></blockquote><blockquote><p>shape가 body에 연결되면, 해당 꼭짓점이 local-coordinates 표현된다.</p></blockquote><h3 id="411-circle-shapes">4.1.1. <strong>Circle Shapes</strong><a href="#411-circle-shapes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>circle 은 position 과 radius 를 가지고 있다.<li>circle 로 속이 빈 원을 만들 수 없다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">b2CircleShape</span> <span class="n">circle</span><span class="p">;</span>
<span class="n">circle</span><span class="p">.</span><span class="n">m_p</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">2.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">circle</span><span class="p">.</span><span class="n">m_radius</span> <span class="o">=</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="412-polygon-shapes">4.1.2. <strong>PolyGon Shapes</strong><a href="#412-polygon-shapes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Polygon 은 convex polygons이다. (볼록 다각형)<li>Polygon은 속이 비어있지 않는다.<li>다각형에는 3개 이상의 꼭짓점이 필요하다.<li>다각형의 정점은 CCW(반시계 당향)으로 저장된다.<ul><li>ccw: z축이 평면 바깥쪽을 가리키는 오른손 좌표계에 관한 것.<li>좌표계 규칙에 따라 화면에서 시계방향으로 나타날 수 있다.</ul><li>폴리곤 멤버는 public 이지만, 폴리곤을 생성하려면 초기화 함수를 사용해야한다.<ul><li>초기화 함수: 법선 벡터를 생성하고 유효성 검사를 수행</ul><li>꼭짓점 배열을 전달하여 다각형 모양을 만들 수 있다.<ul><li>배열의 최대 크기는 기본값이 8인 <code class="language-plaintext highlighter-rouge">b2_maxPolygonVertices</code>에 의해 제어된다.</ul><li><a href="https://box2d.org/documentation/classb2_polygon_shape.html#a4d7b35550509f570814b97325a68966b">b2PolygonShape::Set</a> 함수는 convex hull을 자동으로 계산하고 적절히 감는 순서를 설정한다(winding order).<li>convex hull 함수는 정점을 제거하거나 재정렬할 수 있다. (<code class="language-plaintext highlighter-rouge">b2_linearSlop</code> 보다 가까운 정점은 병합되어진다.)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// This defines a triangle in CCW order.</span>
<span class="n">b2Vec2</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">vertices</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>

<span class="n">int32</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">b2PolygonShape</span> <span class="n">polygon</span><span class="p">;</span>
<span class="n">polygon</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>polygon shape 는 box를 생성하는 몇가지 편의 기능이 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">SetAsBox</span><span class="p">(</span><span class="kt">float</span> <span class="n">hx</span><span class="p">,</span> <span class="kt">float</span> <span class="n">hy</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">SetAsBox</span><span class="p">(</span><span class="kt">float</span> <span class="n">hx</span><span class="p">,</span> <span class="kt">float</span> <span class="n">hy</span><span class="p">,</span> <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>Polygons은 <a href="https://box2d.org/documentation/classb2_shape.html">b2Shape</a>의 radius를 상속한다.<li>radius는 polygon 주위에 skin을 만든다.<li>skin은 stacking scenarios에서 다각형을 약간 분리하는데 사용된다.<ul><li>이렇게 하면 코어 폴리곤에 대해 연속 충돌을 처리할 수 있다.</ul><li>polygon skin은 polygon을 분리된 상태로 유지함으로써 tunneling을 방지한다.<li>그 결과 두 shape 사이에 작은 간격이 생기게된다.<ul><li>이러한 간격을 숨기기위해 다각형이 보다 더 크게 시각적으로 표현할 수 있다.</ul></ul><blockquote><p>Not that polygon skin is only provided to help with continuous collision. The purpose is not to simulate rounded polygons.</p></blockquote><h3 id="413-edge-shapes">4.1.3. <strong>Edge Shapes</strong><a href="#413-edge-shapes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>edge shape는 선분(line segments)이다.<li>이는 게임을 위한 자유형식의 static 환경을 만드는데 도움이 되도록 제공된다.<li>주요 제한은 원 및 다각형과 충돌할 수 있지만 edge와는 충돌할 수 없다는 것이다.<li>Box2D에서 사용하는 충돌 알고리즘은 충돌하는 두 모양 중 적어도 하나에 볼륨이 있어야한다.<ul><li>가장자리 모양에는 적어도 하나의 볼륨이 있어야한다.<ul><li>edge에는 volume이 없으므로 edge-edge 충돌이 불가</ul></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// This an edge shape.</span>
<span class="n">b2Vec2</span> <span class="nf">v1</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="nf">v2</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>

<span class="n">b2EdgeShape</span> <span class="n">edge</span><span class="p">;</span>
<span class="n">edge</span><span class="p">.</span><span class="n">SetTwoSided</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>많은 경우 게임 환경은 여러 edge shape의 끝을 연결하여 구성한다.<ul><li>이 경우 가장자리 체인을 따라 미끄러질 때 예기치 않은 artifact가 일어날 수 있다.<li>ghost collisions: polygon이 내부 충돌 법선(internal collision normal)을 생성하는 내부 정점과 충돌할 때 발생한다.<li>다행히 edge shape는 인접한 ghost vertices를 저장하여 ghost collisions을 제거하는 방법을 제공한다.</ul><li>고스트 충돌을 처리하기 위한 box2D알고리즘은 단측 충돌만 지원한다.<ul><li>?첫번째 정점에서 두번째 정점을 볼때 정면이 오른쪽이며 ccw감기 순서와 일치한다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// This is an edge shape with ghost vertices.</span>
<span class="n">b2Vec2</span> <span class="nf">v0</span><span class="p">(</span><span class="mf">1.7</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="nf">v1</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="nf">v2</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="nf">v3</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.4</span><span class="n">f</span><span class="p">);</span>

<span class="n">b2EdgeShape</span> <span class="n">edge</span><span class="p">;</span>
<span class="n">edge</span><span class="p">.</span><span class="n">SetOneSided</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>v3과 v0: 고스트<li>일반적으로 이 방법은 사용안한다. (wasteful and tedious)<li>chain shapes를 사용한다.</ul><h3 id="414-chain-shapes">4.1.4. <strong>Chain Shapes</strong><a href="#414-chain-shapes"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>사슬 모양은 많은 edge를 함께 연결하여 static game worlds를 구성하는 효율적인 방법을 제공한다.<li>사슬 모양은 자동적으로 ghost collisions를 제거하고 일방적인 충돌을 제공한다. (provide one-sided collision)<li>ghost collision을 신경쓰지 않는다면 그냥 edge 두개를 만들면 된다. (효율성은 비슷)<li>chain shape를 만들기 위한 가장 간단한 방법은 loops를 생성하는 것이다. 정점 배열을 제공하기만 하면된다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">b2Vec2</span> <span class="n">vs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">1.7</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">vs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.25</span><span class="n">f</span><span class="p">);</span>
<span class="n">vs</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">vs</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">Set</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.4</span><span class="n">f</span><span class="p">);</span>

<span class="n">b2ChainShape</span> <span class="n">chain</span><span class="p">;</span>
<span class="n">chain</span><span class="p">.</span><span class="n">CreateLoop</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>edge normal은 감는 순서(winding order)에 따라 다르다.<ul><li>시계 반대 방향 순서는 법선을 바깥쪽으로 향하게 하고, 시계반대 방향 순서는 법선을 안쪽으로 향하게 한다.</ul><li>scrolling game world에서 여러 체인을 함께 연결하고 싶은 경우<ul><li>b2EdgeShape에서처럼 고스트 정점을 사용하여 체인을 연결할 수 있다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2ChainShape</span><span class="o">::</span><span class="n">CreateChain</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">*</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">int32</span> <span class="n">count</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">prevVertex</span><span class="p">,</span> <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">nextVertex</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>체인 모양은 자체 교차(self-intersection)을 지원하지 않는다. (작동할 수도 않을 수도 있다.)<ul><li>또한 매우 가까운 정점은 문제를 일으킬 수 있다.(모든 edge가 b2_linearSlop(5mm)보다 긴지 확인해야한다.)</ul><li>체인의 각 edge는 child shape로 처리되며 인덱스로 접근할 수 있다.<ul><li>체인이 body와 연결되면, 각 edge 는 넓은 위상 충돌 트리(broad-phase collision tree)에서 고유한 경계 box 를 가진다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// Visit each child edge.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">int32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="err">\</span><span class="o">&lt;</span> <span class="n">chain</span><span class="p">.</span><span class="n">GetChildCount</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b2EdgeShape</span> <span class="n">edge</span><span class="p">;</span>
    <span class="n">chain</span><span class="p">.</span><span class="n">GetChildEdge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edge</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="42-geometric-queries">4.2. <strong>Geometric queries</strong><a href="#42-geometric-queries"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>단일 shape에 대해 여러 기하학적 쿼리(geometric queries)를 수행할 수 있다.</ul><h3 id="421-shape-point-test">4.2.1. <strong>Shape Point Test</strong><a href="#421-shape-point-test"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>shape transform과 world point을 인자로 받아 shape가 겹치는지 테스트할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">b2Transform</span> <span class="n">transform</span><span class="p">;</span>
<span class="n">transform</span><span class="p">.</span><span class="n">SetIdentity</span><span class="p">();</span>
<span class="n">b2Vec2</span> <span class="nf">point</span><span class="p">(</span><span class="mf">5.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">TestPoint</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>edge와 chain은 항상 false (chain이 loop여도)</ul><h3 id="422-shape-ray-cast">4.2.2. <strong>Shape Ray Cast</strong><a href="#422-shape-ray-cast"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>shape에 ray를 투사하여 첫 번째 교차점과 법선벡터를 얻을 수 있다. (first intersection and normal vector)<li>raycast가 한번에 하나의 edge만을 검사하기 때문에 chain shape에 child index가 포함된다.<blockquote><p>주의: ray가 convex shape 내부에서 시작할 경우, 아무것도 적중되지 않음. (solid 객체)</p></blockquote></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">b2Transfrom</span> <span class="n">transform</span><span class="p">;</span>
<span class="n">transform</span><span class="p">.</span><span class="n">SetIdentity</span><span class="p">();</span>

<span class="n">b2RayCastInput</span> <span class="n">input</span><span class="p">;</span>
<span class="n">input</span><span class="p">.</span><span class="n">p1</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">input</span><span class="p">.</span><span class="n">p2</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">input</span><span class="p">.</span><span class="n">maxFraction</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">childIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">b2RayCastOutput</span> <span class="n">output</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">shape</span><span class="o">-&gt;</span><span class="n">RayCast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">output</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="n">childIndex</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b2Vec2</span> <span class="n">hitPoint</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">p1</span> <span class="o">+</span> <span class="n">output</span><span class="p">.</span><span class="n">fraction</span> <span class="o">*</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">p2</span> <span class="o">-</span> <span class="n">input</span><span class="p">.</span><span class="n">p1</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="43-pairwise-functions">4.3. <strong>Pairwise Functions</strong><a href="#43-pairwise-functions"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Collision 모듈에는 한 쌍의 shape를 취하고 일부 결과를 계산하는 함수가 포함되어있다.</ul><h3 id="431-overlap">4.3.1. <strong>Overlap</strong><a href="#431-overlap"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><a href="https://box2d.org/documentation/b2__collision_8h.html#a769992d82855399cf20721cd6b411fe7">b2TestOberlap</a>: 두 shape가 겹치는지?</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2Transform</span> <span class="n">xfA</span> <span class="o">=</span> <span class="p">...,</span> <span class="n">xfB</span> <span class="o">=</span> <span class="p">...;</span>
<span class="kt">bool</span> <span class="n">overlap</span> <span class="o">=</span> <span class="n">b2TestOverlap</span><span class="p">(</span><span class="n">shapeA</span><span class="p">,</span> <span class="n">indexA</span><span class="p">,</span> <span class="n">shapeB</span><span class="p">,</span> <span class="n">indexB</span><span class="p">,</span> <span class="n">xfA</span><span class="p">,</span> <span class="n">xfB</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>체인 shape인 경우, child indices를 제공해야한다.</ul><h3 id="432-contact-manifolds">4.3.2. <strong>Contact manifolds</strong><a href="#432-contact-manifolds"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Box2D에는 overlapping shapes를 계산하는 기능이 있다.<li>원-원 or 원-다각형 : 하나의 접점과 법선만 얻을 수 있다.<li>다각형-다각형: 두점을 얻을 수 있다.<li>이러한 점은 동일한 법선 벡터를 공유하므로, Box2D는 이들을 manifold structure로 그룹화한다.<ul><li>일반적으로 manifold structure를 직접 계산할 필요 x, 하지만 시뮬레이션에서 생성된 결과를 사용할 가능성이 높다,</ul><li><p>contact solver는 이를 활용하여 stacking stability를 개선한다.</p><li><p><a href="https://box2d.org/documentation/structb2_manifold.html">b2Manifold</a> structure: 법선벡터와 최대 2개의 접점을 가진다.</p><ul><li>법선과 점은 local coordinates로 유지된다자<li>contact solver의 편의를 위해 각 point는 법선 및 접선(마찰) 충격을 저장한다 (the normal and tangential(friction) impulses)</ul><li>b2Manifold에 저장된 데이터는 내부 사용에 최적화되어있다.<ul><li>이 데이터가 필요한 경우 일반적으로 b2WorldManifold 를 사용하여 접촉 법선(contact normal) 과 points를 생성하는것이 가장 좋다.<li>b2Manifold와 shape transforms과 반경(radii)을 제공할 필요가 있다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">b2WorldManifold</span> <span class="n">worldManifold</span><span class="p">;</span>
<span class="n">worldManifold</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">manifold</span><span class="p">,</span> <span class="n">transformA</span><span class="p">,</span> <span class="n">shapeA</span><span class="p">.</span><span class="n">m_radius</span><span class="p">,</span>
<span class="n">transformB</span><span class="p">,</span> <span class="n">shapeB</span><span class="p">.</span><span class="n">m_radius</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">int32</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="err">\</span><span class="o">&lt;</span> <span class="n">manifold</span><span class="p">.</span><span class="n">pointCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b2Vec2</span> <span class="n">point</span> <span class="o">=</span> <span class="n">worldManifold</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>world manifold는 original manifold의 point count를 사용한다.<li>시뮬레이션 중에 shape가 이동하고 manifolds가 변경되어질 수 있다. (points이 추가되거나 제거)<li>b2GetPointStates를 사용하여 이를 감지할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">b2PointState</span> <span class="n">state1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">state2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">b2GetPointStates</span><span class="p">(</span><span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">manifold1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">manifold2</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">state1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b2_removeState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// process event</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="433-distance">4.3.3. <strong>Distance</strong><a href="#433-distance"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>b2Distance 함수는 두 shape 사이의 거리를 계산하는데 사용할 수 있다.<li>distance function은 <a href="https://box2d.org/documentation/structb2_distance_proxy.html">b2DistanceProxy</a>로 변환하려면 두 shape 모두 필요하다.<ul><li>반복호출에 대해 distance function을 warm start하는데 사용되는 일부 캐싱도 있다.</ul></ul><h3 id="434-time-of-impact">4.3.4. <strong>Time of impact</strong><a href="#434-time-of-impact"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>만일 두 shape가 빠르게 움직이는 경우 단일 time step에서 서로를 터널링할 수 있다.<li>b2TimeOfImpact 함수는 두 개의 움직이는 shape가 충돌하는 시간을 결정하는 데 사용된다.<ul><li>이를 TOI(time of impact)라고 한다.<li>이것의 목적은 터널 방지이다.<li>특히, 움직이는 물체가 static level geometry 외부로 터널링되는 것을 방지하도록 설계되었다.<li>이 함수는 두 shape의 회전 및 변환에 대해 처리하지만 회전이 충분히 크면 함수가 충돌을 놓칠 수 있다.<li>하지만, 이 함수는 여전히 non-overlapped time을 보고하고 모든 translational collisions을 잡아낸다.</ul><li>time of impact 함수는 초기 분리 축(initial separating axis)을 식별하고, shape가 해당 축에서 교차하지 않도록한다.<ul><li>이것은 최종 위치에서 명확한 충돌을 놓칠 수 있다.<li>이 접근 방식은 일부 충돌을 놓칠 수 있지만 매우 빠르고 터널 방지에 적합하다.</ul><li><p>회전 크기에 제한을 두는 것은 어려우며, 작은 회전에 대해 충돌이 누락되는 경우가 있다.</p><ul><li>일반적으로 이러한 놓친 충돌은 게임 플레이에 해를 끼치지 않아야한다.(충돌하는 경향이 있음.)</ul><li>이 함수는 두개의 shape(b2DistanceProxy로 변환된) 과 두 개의 b2Sweep 구조가 필요하다.<ul><li>sweep structure는 shape의 초기 및 최종 변환을 정의한다.</ul><li>만일 고정 회전(fixed rotations)을 사용하면, shape cast를 수행할 수 있다.<ul><li>이 경우, the time of impact function은 모든 충돌을 놓치지 않는다.</ul></ul><h2 id="44-dynamic-tree">4.4. <strong>Dynamic Tree</strong><a href="#44-dynamic-tree"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p><a href="https://box2d.org/documentation/classb2_dynamic_tree.html">b2DynamicTree</a>는 많은 shape를 효율적으로 구성하는데 사용된다.</p><li><p>이 클래서는 어떤 shape인지 모르지만, 사용자 데이터 포인터가 있는 AABBs(axis-aligned bounding boxes)에서 작동한다.</p><li><p>dynamic tree는 계층적 AABB 트리이다.</p><ul><li>트리의 각 내부 노드에는 두개의 자식을 가진다.<li>리프노드는 단일 사용자 AABB(single user AABB)이다.<li>트리는 퇴화 입력(degenerate input)의 경우에도 균형을 유지하기 위해 회전을 사용한다.</ul><li><p>트리 구조는 효율적인 ray casts 그리고 영역 쿼리를 허용한다.</p><ul><li>예를 들어, scene에 여러 shape가 있을 수 있다. 여기서 ray casst를 수행하려면, brute force 방법으로 각 shape에 대해 ray cast 하는 방법을 사용할 수 있다.<li>이런 방법은 비효율적이다. (shape가 서로 떨어져 있을 경우)<li>그러므로 dynamic tree를 유지하고, 이 tree에 대해 raycast를 수행하여 많은 개수의 shape를 스킵할 수 있다.</ul><li><p>region query: tree를 사용하여 쿼리 AABB와 겹치는 모든 리프 AABB를 찾음.</p><ul><li>많은 shape를 스킵할 수 있기 때문에 빠르다.</ul><li><p>일반적으로 이 트리를 직접 사용하지 않는다.</p><ul><li>b2World 클래스를 사용하여 레이 캐스트 및 지역 쿼리를 수행한다.</ul></ul><h2 id="45-broad-phase">4.5. <strong>Broad-phase</strong><a href="#45-broad-phase"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>물리 단계에서 충돌처리는 narrow-phase와 broad-phase로 나눌 수 있다.<li>narrow-phase: shape 쌍에서 접점을 계산<ul><li>N개의 shape: N*N/2 개의 쌍에 대해 narrow-phase를 수행해야한다.</ul><li>b2BroadPhase 클래스는 이러한 쌍을 관리하기 위해 dynamic tree를 사용하여 부하를 줄인다.<ul><li>이것은 narrow-phase 호출의 수를 크게 줄여준다.</ul><li>broad-phase: 일반적으로 직접 상호작용하지 않는다.(내부적으로 box2D가 생성하고 관리)<ul><li>b2BroadPhase는 Box2D의 시뮬레이션 루프에 맞게 설계되었다.</ul></ul><h1 id="5-dynamics-module">5. <strong>Dynamics Module</strong></h1><ul><li>다이나믹 모듈은 Box2D의 가장 복잡한 부분이다.<li>대부분 사용자가 상호작용하는 모듈.<li>Common과 Collision 모듈 위에 있는 모듈<li>아래와 같은 클래스를 가지고 있다.<ul><li>fixture<li>rigid body<li>contact<li>joint<li>world<li>listener</ul><li>클래스 사이에 많은 종속성이 있다. (다른 클래스를 참조)</ul><h2 id="51-bodies">5.1. <strong>Bodies</strong><a href="#51-bodies"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>position 과 velocity를 가지고 있다.<li>forces, torques, impulses (힘, 토크, 충격)을 bodies에 적용할 수 있다.<li>Body의 종류: static, kinematic, dynamic<li>body는 fixtures(shapes)의 척추<li>bodies는 fixture를 운반하면서 world에서 움직인다.<li>Body는 항상 강체이다.<ul><li>즉, 동일한 강체에 부착된 fixtures는 서로에 대해 상대적으로 움직이지 않고, 서로 충돌하지 않는다.</ul><li>fixtures에는 collision geometry 와 밀도(density)가 있다.<li>일반적으로 body는 fixtures에서 mass 속성을 얻는다.<ul><li>그러나 body를 만든 후 mass 속성을 override할 수 있다.</ul><li>일반적으로 생성한 모든 bodies에 대해 pointers을 유지한다.<ul><li>그러므로 body position을 쿼리하여 그래픽 개체의 위치를 업데이트할 수 있다.<li>또한 포인터에 대한 작업이 완료되면 파괴할 수 있다.</ul></ul><h3 id="511-b2_staticbody">5.1.1. <strong>b2_staticBody</strong><a href="#511-b2_staticbody"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>시뮬레이션에서 움직이지 않음<li>무한한 mass를 가진것 처럼 동작<li>mass와 inverse mass값 == 0<li>사용자가 수동적으로 이동 가능<li>속도 == 0<li>다른 static, kinematic body와 충돌하지 않는다.</ul><h3 id="512-b2_kinematicbody">5.1.2. <strong>b2_kinematicBody</strong><a href="#512-b2_kinematicbody"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>속도에 따라 시뮬레이션 중에 움직임<li>forces에 반응하지 않음<li>수동적으로 움직일 수 있지만 일반적으로 속도를 설정하여 이동시킴<li>무한한 mass를 가진것처럼 동작하지만<li>mass와 inverse mass 값 == 0<li>다른 static, kinematic과 충돌하지 않는다.</ul><h3 id="513-b2_dynamicbody">5.1.3. <strong>b2_dynamicBody</strong><a href="#513-b2_dynamicbody"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>완전히 시뮬레이션되는 body<li>사용자가 수동으로 이동할 수 있지만, 일반적으로 forces에 따라 움직임<li>어떠한 body와도 충돌 가능하다.<li>0이 아닌 질량을갖는다<li>만약 0으로 설정하면 자동적으로 1kg의 질량을 갖고 회전하지 않는다.</ul><h3 id="514-body-definition">5.1.4. <strong>Body Definition</strong><a href="#514-body-definition"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body를 생성하기 전에 body definition을 생성해야한다. (<a href="https://box2d.org/documentation/structb2_body_def.html">b2BodyDef</a>)<li>초기화 하는데 필요한 데이터를 가진다.<li>이 정의에서 body로 데이터를 복사한다.<ul><li>정의에 대한 포인터는 유지하지 않는다.<li>정의를 재활용하여 여러 body를 생성할 수 있다.</ul></ul><h4 id="5141-body-type">5.1.4.1. <strong>Body Type</strong><a href="#5141-body-type"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>static, kinematic, and dynamic.<li>나중에 이를 변경하는것인 비용이 비싸므로 생성시에 설정<li>필수적이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">b2_dynamicBody</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="5142-position-and-angle">5.1.4.2. <strong>Position and Angle</strong><a href="#5142-position-and-angle"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>생성시 body위치를 초기화<ul><li>world 원점에서 생성하고, body를 움직이는것보다 성능이 좋다.<li>원점에서 여러 body를 생성하면 성능이 저하된다.</ul><li>body’s origin: Fixtures 그리고 joints은 body 원점을 기준으로 부착된다.<li>질량 중심 위치(cenger of mass): 부착된 shape의 질량분포(mass distribution)에서 결정되거나 <a href="https://box2d.org/documentation/structb2_mass_data.html">b2MassData</a>로 명시적으로 설정할 수 있다.<ul><li>Box2D의 내부 계산의 대부분은 질량 중심 위치를 사용한다.<li>예를들어, b2Body는 질량중심에 대한 선형속도를 저장한다.</ul><li>body의 각도를 라디안 단위로 지정할 수 있으며, 이는 질량중심위치의 영향을 받지 않는다.<li>나중에 mass 속성들을 변경하면, body의 질량중심이 이동할 수 있지만, 원점 위치는 변경되지 않고, 부착된 shapes 과 joints 또한 이동하지 않는다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">0.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">2.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">// the body's origin position.</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">angle</span> <span class="o">=</span> <span class="mf">0.25</span><span class="n">f</span> <span class="o">*</span> <span class="n">b2_pi</span><span class="p">;</span> <span class="c1">// the body's angle in radians.</span>
</pre></table></code></div></div><ul><li>rigid body는 참조 프레임이다.<ul><li>해당 프레임에서 fixtures 및 joints를 정의할 수 있다.<li>이것들은 local 프레임에서 절대 움직이지 않는다.</ul></ul><h4 id="5143-damping">5.1.4.3. <strong>Damping</strong><a href="#5143-damping"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>bodies의 world 속도를 줄이기 위해 사용된다.<li>friction은 접촉할 때 발생함(damping과 다름)<ul><li>마찰을 대체 할 수 없음, 두가지 모두 사용해야함.</ul><li>Damping 매개변수는 0~ INF 사이<ul><li>0: 감쇠가 없음<li>INF: 전체 감쇠</ul><li>일반적으로 0 과 0.1 사이의 값을 사용한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">linearDamping</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">angularDamping</span> <span class="o">=</span> <span class="mf">0.01</span><span class="n">f</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>Damping은 안정성과 성능에 대한 근사치<ul><li>작은 감쇠값: timestep 과 무관<li>더 큰 감쇠값: timestep 에 따라 효과가 달라짐</ul></ul><h4 id="5144-gravity-scale">5.1.4.4. <strong>Gravity Scale</strong><a href="#5144-gravity-scale"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>단일 body의 중력을 조절 (증가하면 안정성이 떨어짐)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// Set the gravity scale to zero so this body will float</span>
<span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">gravityScale</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="5145-sleep-parameters">5.1.4.5. <strong>Sleep Parameters</strong><a href="#5145-sleep-parameters"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>시뮬레이션 횟수가 적을 수록 좋기 때문에 body를 중단하게 함.<li>Box2D가 body(or group)이 정지했다고 판단하면 body는 CPU 오버헤드가 거의 없는 절전상태에 들어간다.<li>awake 상태의 body와 충돌하면 깨어나게된다.<li>Bodies에 연결된 joint 나 접점이 파괴된 경우에도 body가 깨어난다.<li>수동으로 깨울 수 있다.<li>Body 정의에서 잠을 잘 수 있는지 와 생성할 때의 상태를 지정할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">allowSleep</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">awake</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="5146-fixed-rotation">5.1.4.6. <strong>Fixed Rotation</strong><a href="#5146-fixed-rotation"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>캐릭터와 같은 강체가 회전하지 않게 하기 위한 설정<li>하중이 가해져도 회전하지 않는다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">fixedRotation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>이 플래그는 회전 관성(rotational inertia) 그리고 그 역(inverse)이 0으로 설정되도록 한다.</ul><h4 id="5147-bullets">5.1.4.7. <strong>Bullets</strong><a href="#5147-bullets"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>이산 시뮬레이션에서 강체는 한 timestap에서 더 많이 이동할 수 있다.<li>터널링에 관한 것<ul><li>기본적으로 Box2D는 연속 충돌 감지(CCD)를 사용하여 dynamic이 static을 터널링하는 것을 방지한다.<li>이전 위치에서 새 위치로 shape는 sweeping하여 수행한다.<li>엔진은 sweeping동안 새로운 충돌을 찾고, 충돌시간(TOI)을 계산한다.<li>body가 첫번째 TOI로 이동된 다음, solver가 하위 단계를 수행하여 전체 timestep을 완료한다.(하위 단계 내에서 추가 TOI이벤트가 있을 수 있다.)</ul><li>일반적으로 ccd는 dynamic에서 사용되지 않는다.<ul><li>이는 성능을 합리적으로 유지하기 위해 수행된다.<li>일부 게임에서 dynamic body에 ccd가 필요할 경우가 있다. (ex. 고속 총알을 dynamic body에, 이 경우 ccd가 없으면 뚫릴 수 있음)</ul><li>빠르게 움직이는 객체는 bullets이라는 라벨을 붙일 수 있다.<ul><li>bullet은 static, dynamic body 모두에 ccd를 수행한다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">bullet</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>이 플래그는 dynamic body일 경우에만 유효하다.</ul><h4 id="5148-activation">5.1.4.8. <strong>Activation</strong><a href="#5148-activation"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>충돌이나 역학(collision or dynamics)에 참여하지 않을 수 있다.<ul><li>이 상태는 body가 다른 body에 의해 깨어나지 않고, body의 fixture가 broad-phase에 배치되지 않는다는 점을 제외하고는 sleep과 유사하다.</ul><li>즉, 충돌, 레이 캐스트에 참여하지 않는다.<li>이 설정은 나중에 변경할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">active</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>joint는 비활성 body에 연결될 수 있지만, 시뮬레이션되지 않는다.<ul><li>body를 활성화 할 때 joint가 왜곡되지 않도록 주의해야한다.</ul><li>body를 활성화하는 것은 body를 처음부터 생성하는 것 만큼 비용이 많이 든다.<ul><li>따라서 streaming worlds에서 이를 활용하면 안된다.<li>이 경우 생성/ 파괴를 사용하여 메모리를 절약해야한다.</ul></ul><h4 id="5149-user-data">5.1.4.9. <strong>User Data</strong><a href="#5149-user-data"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>사용자 데이터는 void pointer이다.<li>응용 프로그램 객체를 연결할 수 있는 연결고리이다,<li>일관성있게 객체 타입을 연결해야한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">b2BodyDef</span> <span class="n">bodyDef</span><span class="p">;</span>
<span class="n">bodyDef</span><span class="p">.</span><span class="n">userData</span><span class="p">.</span><span class="n">pointer</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myActor</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="515-body-factory">5.1.5. <strong>Body Factory</strong><a href="#515-body-factory"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body는 world class에서 제공하는 body factory를 사용하여 생성 및 파괴된다.<li>이를 통해 world는 효율적으로 메모리 관리를 할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">b2World</span><span class="o">*</span> <span class="n">myWorld</span><span class="p">;</span>
<span class="n">b2Body</span><span class="o">*</span> <span class="n">dynamicBody</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">CreateBody</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bodyDef</span><span class="p">);</span>

<span class="c1">// ... do stuff ...</span>

<span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">DestroyBody</span><span class="p">(</span><span class="n">dynamicBody</span><span class="p">);</span>
<span class="n">dynamicBody</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
</pre></table></code></div></div><blockquote><p>주의: body를 생성할 때 new, malloc을 사용해서는 안된다.</p></blockquote><ul><li>box2D는 body definition 또는 그 데이터에 대한 참조를 유지하지 않는다. (사용자 데이터 포인터는 유지)<li><p>따라서 임시 body 정의를 생성하고, 동일한 body 정의를 재사용할 수 있다.</p><li>body를 삭제하면 부착된 fixtures, joints는 자동적으로 삭제된다.</ul><h3 id="516-using-a-body">5.1.6. <strong>Using a Body</strong><a href="#516-using-a-body"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>생성한 후에, 많은 작업을 수행할 수 있다.<li>질량 속성 설정, 위치 및 속도 접근, forces 적용, 점 및 벡터 변환 등</ul><h3 id="517-mass-data">5.1.7. <strong>Mass Data</strong><a href="#517-mass-data"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>물체에는 질량(스칼라), 질량 중심(2-vector), 회전 관성(스칼라) 가 있다.<li>static body의 경우 질량 및 회전 관성 == 0<li><p>물체의 회전이 고정되어 있으면 회전 관성 == 0</p><li>일반적으로 body에 fixture를 추가할 때 body의 mass 속성이 자동으로 설정된다.<li>런타임에 body의 질량을 조정할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetMassData</span><span class="p">(</span><span class="k">const</span> <span class="n">b2MassData</span><span class="o">*</span> <span class="n">data</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>body의 mass를 직접 설정한 후 fixture에 의해 지시된 natural mass로 되돌릴 경우 아래와 같은 함수를 사용한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">ResetMassData</span><span class="p">();</span>
</pre></table></code></div></div><ul><li>body의 mass data와 관련된 함수는 다음과 같다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetMass</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetInertia</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetLocalCenter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetMassData</span><span class="p">(</span><span class="n">b2MassData</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="518-state-information">5.1.8. <strong>State Information</strong><a href="#518-state-information"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body state 접근하는 함수들</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetType</span><span class="p">(</span><span class="n">b2BodyType</span> <span class="n">type</span><span class="p">);</span>
<span class="n">b2BodyType</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetType</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetBullet</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">IsBullet</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetSleepingAllowed</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">IsSleepingAllowed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetAwake</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">IsAwake</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetEnabled</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">IsEnabled</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetFixedRotation</span><span class="p">(</span><span class="kt">bool</span> <span class="n">flag</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">IsFixedRotation</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="519-position-and-velocity">5.1.9. <strong>Position and Velocity</strong><a href="#519-position-and-velocity"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>속도와 위치에 접근하는 함수들<li>이것은 렌더링할 때 일반적이다.<li>위치를 설정할 수 있지만, 시뮬레이션 결과를 얻는것이 일반적</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">SetTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
<span class="k">const</span> <span class="n">b2Transform</span><span class="o">&amp;</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetTransform</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetPosition</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetAngle</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>Local 그리고 world 좌표에서 질량 중심 위치에 접근할 수 있다.<li>내부 시뮬레이션은 대부분 질량 중심을 사용한다. (보통 사용자가 접근하지 않는다.)<li>일반적으로 body transform 을 사용할 수 있다.<ul><li>ex. body가 정사각형일 경우 질량중심은 정사각형 중심에 있다. (body의 원점은 모서리일 수 있다.)</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetWorldCenter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetLocalCenter</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>선형 및 각속도에 접근할 수 있다.<li>선형 속도(linear velocity): 질량 중심에 대한것, 질량 특성이 변경되면 변경될 수 있다.</ul><h3 id="5110-fiorces-and-impulses">5.1.10. <strong>Fiorces and Impulses</strong><a href="#5110-fiorces-and-impulses"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>힘, 토크, 충격을 body에 적용<li>이 경우 하중이 가해지는 world point 를 넘겨줘야한다.<li>이로 인해 질량 중심에 대한 토크가 발생한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">ApplyForce</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">force</span><span class="p">,</span> <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">ApplyTorque</span><span class="p">(</span><span class="kt">float</span> <span class="n">torque</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">ApplyLinearImpulse</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">impulse</span><span class="p">,</span> <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">ApplyAngularImpulse</span><span class="p">(</span><span class="kt">float</span> <span class="n">impulse</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>힘, 토크, 충격을 가하면 body가 깨어나게 된다. (For example, you may be applying a steady force and want to allow the body to sleep to improve performance.)<li>이를 막기 위해 아래와 같은 코드를 추가할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">myBody</span><span class="o">-&gt;</span><span class="n">IsAwake</span><span class="p">()</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">myBody</span><span class="o">-&gt;</span><span class="n">ApplyForce</span><span class="p">(</span><span class="n">myForce</span><span class="p">,</span> <span class="n">myPoint</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="5111-coordinate-transformations">5.1.11. <strong>Coordinate Transformations</strong><a href="#5111-coordinate-transformations"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body class에는 local 과 world space사이에서 점과 벡터를 변환하는 데 도움이 되는 몇가지 유틸리티 함수가 있다.<ul><li>책추천: “Essential Mathematics for Games and Interactive Applications” by Jim Van Vert</ul><li>이러한 함수들은 inline일 경우 효율적이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">b2Vec2</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetWorldPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">localPoint</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetWorldVector</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">localVector</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetLocalPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">worldPoint</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="n">b2Body</span><span class="o">::</span><span class="n">GetLocalVector</span><span class="p">(</span><span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">worldVector</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="5112-acessing-fixtures-joints-and-contacts">5.1.12. <strong>Acessing Fixtures, Joints, and Contacts</strong><a href="#5112-acessing-fixtures-joints-and-contacts"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>body의 fixtures에 접근할 수 있다. (반복문을 통해)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">body</span><span class="o">-&gt;</span><span class="n">GetFixtureList</span><span class="p">();</span> <span class="n">f</span><span class="p">;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">GetNext</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">MyFixtureData</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">MyFixtureData</span><span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">();</span>
    <span class="c1">// do something with data ...</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>body의 joint 리스트 또한 유사하다.<li>연관된 contacts 리스트도 제공한다.<ul><li>이를 사용해 현재 접촉에 대한 정보를 얻을 수 있다.<li>이 리스트에는 이전 timestep 동안 존재했던것들이 없을 수 있다.</ul></ul><h2 id="52-fixtures">5.2. <strong>Fixtures</strong><a href="#52-fixtures"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>shape는 body에 대해 알지 못한다.<ul><li>물리 시뮬레이션과 독립적으로 사용될 수 있다.</ul><li>따라서 body에 shape를 붙이기 위해 b2Fixture 클래스를 사용한다.<ul><li>여러 fixture가 있는것을 compound body라고 한다.</ul><li>fixture는 아래와 같은 데이터를 가지고 있다.<ul><li>a single shape<li>broad-phase proxies<li>density, friction, and restitution<li>collision filtering flags<li>back pointer to the parent body<li>user data<li>sensor flag</ul></ul><h3 id="521-fixture-creation">5.2.1. <strong>Fixture Creation</strong><a href="#521-fixture-creation"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>fixture 정의를 생성하고, body에서 생성한다.<li>부모 body가 제거되면, 자동으로 fixture도 제거된다. (따로 포인터로 저장할 필요 없다.)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">b2Body</span><span class="o">*</span> <span class="n">myBody</span><span class="p">;</span>
<span class="n">b2FixtureDef</span> <span class="n">fixtureDef</span><span class="p">;</span>
<span class="n">fixtureDef</span><span class="p">.</span><span class="n">shape</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">myShape</span><span class="p">;</span>
<span class="n">fixtureDef</span><span class="p">.</span><span class="n">density</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
<span class="n">b2Fixture</span><span class="o">*</span> <span class="n">myFixture</span> <span class="o">=</span> <span class="n">myBody</span><span class="o">-&gt;</span><span class="n">CreateFixture</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixtureDef</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>깨지기 쉬운 물체를 모델링하기 위해 fixture를 body에서 제거할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">myBody</span><span class="o">-&gt;</span><span class="n">DestroyFixture</span><span class="p">(</span><span class="n">myFixture</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="522-density">5.2.2. <strong>Density</strong><a href="#522-density"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>fixture 밀도는 mass의 속성을 계산하는데 사용된다.<li>밀도는 0 또는 양수이다.<li><p>일반적으로 모든 fixture에 대해 유사한 밀도를 사용해야한다. (stacking 안정성 향상)</p><li>밀도를 설정할 때 body의 질량은 조정되지 않는다. (ResetMassData 호출해야한다.)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixture</span><span class="p">;</span>
<span class="n">fixture</span><span class="o">-&gt;</span><span class="n">SetDensity</span><span class="p">(</span><span class="mf">5.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Body</span><span class="o">*</span> <span class="n">body</span><span class="p">;</span>
<span class="n">body</span><span class="o">-&gt;</span><span class="n">ResetMassData</span><span class="p">();</span>
</pre></table></code></div></div><h3 id="523-friction">5.2.3. <strong>Friction</strong><a href="#523-friction"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>friction은 물체가 사실적으로 서로를 따라 미끄러지도록 하는 데 사용된다.<li>Box2D는 static, dynamic friction을 지원하지만 둘다 동일한 매개변수를 사용한다.<li>마찰은 Box2D에서 정확하게 시뮬레이션된다.<li>마찰 강도는 수직력(normal force)에 비례한다.(쿨롱 마찰)<li>마찰 매개변수는 일반적으로 0과 1 사이에서 설정되지만, 음수가 아닌 값일 수 있다.<ul><li>마찰 값이 0이면 마찰이 꺼짐<li>1이면 강해짐<li>두 shape 사이에서 마찰이 계산될 때 Box2D는 두 상위 fixture의 마찰 매개변수를 결합한다.(기하평균)<li>따라서 하나가 마찰이 0일 경우 접점은 마찰이 없다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixtureA</span><span class="p">;</span>
<span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixtureB</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">friction</span><span class="p">;</span>
<span class="n">friction</span> <span class="o">=</span> <span class="n">sqrtf</span><span class="p">(</span><span class="n">fixtureA</span><span class="o">-&gt;</span><span class="n">friction</span> <span class="o">*</span> <span class="n">fixtureB</span><span class="o">-&gt;</span><span class="n">friction</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><a href="https://box2d.org/documentation/classb2_contact.html#a6cac6c0db18a161a359d73672596b413">b2Contact::SetFriction</a> 을 사용하여 혼합된 마찰을 override할 수 있다.<ul><li>b2ContactListener callback 에서 수행된다.</ul></ul><h3 id="524-restitution">5.2.4. <strong>Restitution</strong><a href="#524-restitution"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>복원은 물체를 튕기기 위해 사용된다.<li>복원 값은 0~1 사이로 설정된다.<li>테이블에 공을 떨어뜨릴 때 만약 0의 값을 가지고 있으면 공은 튀지 않는다.<ul><li>이를 비탄성 충돌이라고 부른다.</ul><li>값이 1 이면 공의 속도가 정확히 반영된다.<ul><li>이를 완전 탄성 충돌이라고 부른다.</ul><li>아래의 코드로 결합될 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixtureA</span><span class="p">;</span>
<span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixtureB</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">restitution</span><span class="p">;</span>
<span class="n">restitution</span> <span class="o">=</span> <span class="n">b2Max</span><span class="p">(</span><span class="n">fixtureA</span><span class="o">-&gt;</span><span class="n">restitution</span><span class="p">,</span> <span class="n">fixtureB</span><span class="o">-&gt;</span><span class="n">restitution</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><p>이와 같은 결합으로 bouncy floor가 아니더라도 bouncy ball을 만들 수 있다.</p><li><a href="https://box2d.org/documentation/classb2_contact.html#a685a1c4cfca30c379c402e20e04723b6">b2Contact::SetRestitution</a>을 사용하여 기본 혼합을 override할 수 있다.<ul><li>b2ContactListener callback 에서 수행된다.</ul><li>다중 접촉에 대해서 복원은 대략적인 시뮬레이션을 수행한다.<ul><li>Box2D가 반복 솔버를 사용하기 때문.<li>Box2D는 충돌 속도가 작은 경우에도 비탄성충돌을 사용한다. (jitter를 방지하는데 사용 b2_velocityRhreshold)</ul></ul><h3 id="525-filtering">5.2.5. <strong>Filtering</strong><a href="#525-filtering"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>collision filtering을 사용하면 fixtures 사이의 충돌을 방지할 수 있다.<ul><li>예를들어, 자전거를 타는 캐릭터, 자전거가 지형과 충돌, 캐릭터가 지형과 충돌하기를 원하지만 캐릭터와 자전거가 충돌하지 않게(겹쳐져야하므로)</ul><li>범주 및 그룹을 사용하여 이러한 충돌 필터링을 지원한다.<li>Box2D는 16개의 충돌 범주를 지원한다.<ul><li>각 fixture에 대해 카테고리를 지정할 수 있다.<li>또한 이 fixture가 충돌할 수 있는 다른 카테고리를 지정할 수 있다.<li>예를 들어, 멀티플레이어 게임에서 모든 플레이어는 서로 충돌하지 않고 몬스터는 서로 충돌하지 않지만, 플레이어와 몬스터는 충돌하게 지정 가능하다.</ul><li>이것은 비트 마스킹으로 수행된다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">b2FixtureDef</span> <span class="n">playerFixtureDef</span><span class="p">,</span> <span class="n">monsterFixtureDef</span><span class="p">;</span>
<span class="n">playerFixtureDef</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">categoryBits</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">;</span>
<span class="n">monsterFixtureDef</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">categoryBits</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">;</span>
<span class="n">playerFixtureDef</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">maskBits</span> <span class="o">=</span> <span class="mh">0x0004</span><span class="p">;</span>
<span class="n">monsterFixtureDef</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">maskBits</span> <span class="o">=</span> <span class="mh">0x0002</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>충돌이 발생하는 규칙은 다음과 같다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">uint16</span> <span class="n">catA</span> <span class="o">=</span> <span class="n">fixtureA</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">categoryBits</span><span class="p">;</span>
<span class="n">uint16</span> <span class="n">maskA</span> <span class="o">=</span> <span class="n">fixtureA</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">maskBits</span><span class="p">;</span>
<span class="n">uint16</span> <span class="n">catB</span> <span class="o">=</span> <span class="n">fixtureB</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">categoryBits</span><span class="p">;</span>
<span class="n">uint16</span> <span class="n">maskB</span> <span class="o">=</span> <span class="n">fixtureB</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">maskBits</span><span class="p">;</span>

<span class="k">if</span> <span class="p">((</span><span class="n">catA</span> <span class="o">&amp;</span> <span class="n">maskB</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">catB</span> <span class="o">&amp;</span> <span class="n">maskA</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// fixtures can collide</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>충돌 그룹을 사용하면 통합 그룹 인덱스를 지정할 수 있다.<ul><li>동일한 그룹 인덱스를 가진 모든 fixture가 항상 충돌(양수 인덱스)하거나 충돌하지 않도록(음수 인덱스) 할 수 있다.<li>이것은 일반적으로 자전거 부품과 같이 관련성이 있는 항목에 사용된다.<li>아래의 예에서 fixture1 과 fixture2는 항상 충돌하지만 fixture3과 4는 절대 충돌하지 않는다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">fixture1Def</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">groupIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">fixture2Def</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">groupIndex</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">fixture3Def</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">groupIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span><span class="p">;</span>
<span class="n">fixture4Def</span><span class="p">.</span><span class="n">filter</span><span class="p">.</span><span class="n">groupIndex</span> <span class="o">=</span> <span class="o">-</span><span class="mi">8</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><p>다른 그룹 인덱스의 fixture간의 충돌은 카테고리 및 마스크 비트에 따라 필터링된다.</p><ul><li>즉, 그룹 필터링은 카테고리 필터링보다 우선순위가 높다.</ul><li>추가적으로 알아야하는 필터링은 다음과 같다.<ul><li>static body에 붙은 fixture는 오직 dynamic 과 충돌<li>kinematic body에 붙은 fixture는 오직 dynamic 과 충돌<li>같은 body에 붙은 fixtures는 결코 서로 충돌하지 않는다.<li>추가적으로 joint로 연결된 body의 fixture간의 충돌을 선택적으로 활성화/비활성화 할 수 있다.</ul><li>때때로 fixture가 이미 생성된 후에 filtering을 변경해야할 수 있다.<ul><li><a href="https://box2d.org/documentation/classb2_fixture.html#ad956250d9f684a407992ec178320127e">GetFilterData</a>, <a href="https://box2d.org/documentation/classb2_fixture.html#a2c5e0d12c174927a4ad550459be334ad">SetFilterData</a>를 사용하여 b2Filter 구조를 가져오고 설정할 수 있다.<li>필터 데이터를 변경해도 다음 time step까지 접촉점(contacts)이 추가되거나 제거되지 않는다. (world class)</ul></ul><h3 id="526-sensors">5.2.6. <strong>Sensors</strong><a href="#526-sensors"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>두개의 fixture가 겹치지만 충돌 응답이 없어야 할 때.<li>센서는 충돌을 감지하지만 응답을 생성하지 않는 fixture이다.<li>모든 fixture를 센서로 표시할 수 있다.<ul><li>static, kinematic, dynamic</ul><li>센서와 solid fixture를 혼합하여 사용할 수 있다.<li>센서는 최소한 하나의 body가 동적일 때만 접점을 형성(감지)한다.<ul><li>센서는 접점을 생성하지 않는다.</ul><li>두가지 방법으로 센서 상태를 가져올 수 있다.<ol><li><a href="https://box2d.org/documentation/classb2_contact.html#a681346f93e2a27403383775a752c06a0">b2Contact::IsTouching</a><li><a href="https://box2d.org/documentation/classb2_contact_listener.html#a35148fc56fb9eac12077200fbd928f65">b2ContactListener::BeginContact</a> and <a href="https://box2d.org/documentation/classb2_contact_listener.html#afb3059058e5c47903a3947c2eef5826b">b2ContactListener::EndContact</a></ol></ul><h2 id="53-joints">5.3. <strong>Joints</strong><a href="#53-joints"><i class="fas fa-hashtag"></i></a></h2></h2><p>Joint Definition Joint Factory Using Joints Distance Joint Revolute Joint Prismatic Joint Pulley Joint Gear Joint Mouse Joint Wheel Joint Weld Joint Rope Joint Friction Joint Motor Joint Wheel Joint</p><h2 id="54-contacts">5.4. <strong>Contacts</strong><a href="#54-contacts"><i class="fas fa-hashtag"></i></a></h2></h2><p>Contact Class Accessing Contacts</p><hr /><p>Contact Listener shape rigid body fixture constraint contact constraint joint joint limit joint motor world solver continuous collision b2_staticBody b2_kinematicBody</p><hr /><p>b2_dynamicBody contact point contact normal contact separation contact manifold normal impulse tangent impulse contact ids</p><hr /><p>Begin Contact Event End Contact Event Pre-Solve Event Post-Solve Event</p><hr /><p>Contact Filtering</p><h2 id="55-world">5.5. <strong>World</strong><a href="#55-world"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>b2World 클래스에는 bodies 그리고 joints이 포함된다.<li>이것은 시뮬레이션의 모든 측면을 관리하고, 비동기 쿼리를 할 수 있게해준다. (AABB쿼리, 레이캐스트)<li>Box2D와의 대부분의 상호 작용은 b2World 객체와 함께 수행된다.</ul><h3 id="551-creating-and-destroying-a-world">5.5.1. <strong>Creating and Destroying a World</strong><a href="#551-creating-and-destroying-a-world"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>중력 벡터와 body가 sleep 상태로 변할 수 있는지에 대한 여부만 넘겨주면 된다.<li>일반적으로 포인터를 사용하여 생성, 해제 한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">b2World</span><span class="o">*</span> <span class="n">myWorld</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">b2World</span><span class="p">(</span><span class="n">gravity</span><span class="p">,</span> <span class="n">doSleep</span><span class="p">);</span>

<span class="c1">// ... do stuff ...</span>

<span class="k">delete</span> <span class="n">myWorld</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="552-using-a-world">5.5.2. <strong>Using a World</strong><a href="#552-using-a-world"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>world 클래스에는 body와 조인트를 생성하고 파괴하는 팩토리가 있다.<li>그 외에 여러 상호작용을 지원한다.</ul><h4 id="5521-simulation">5.5.2.1. <strong>Simulation</strong><a href="#5521-simulation"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>world 클래스는 시뮬레이션을 구동하는데 사용된다.<li>time step 과 velocity, position iteration count 를 지정해야한다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">timeStep</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="mf">60.</span><span class="n">f</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">velocityIterations</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">int32</span> <span class="n">positionIterations</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">Step</span><span class="p">(</span><span class="n">timeStep</span><span class="p">,</span> <span class="n">velocityIterations</span><span class="p">,</span> <span class="n">positionIterations</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>time step 후에 body와 joints에 대한 검사를 수행할 수 있다.<li>actor를 업데이트하고 렌더링할 수 있도록 body에서 position을 가져올 수 있다.<li>게임 루프 어느 곳에서든 timestep을 수행할 수 있다.<ul><li>예를들어, 해당 프레임의 새로운 body에 대한 충돌 결과를 얻으려면 time step이전에 body를 생성해야한다.<li>고정된 timestep을 사용해야한다. (더 큰 time step은 low frame rate 시나리오에서 성능을 높일 수 있다.)<li>일반적으로 1/30 보다 작은 time step을 사용한다. (1/60은 고품질 시뮬레이션)</ul><li>반복횟수는 제약 조건 솔버가 world의 모든 contacts 과 joints을 sweep하는 횟수를 제어한다.<ul><li>더 많은 반복은 더 나은 시뮬레이션을 생성한다.<li>(하지만 60hz에서 10번 반복이 30hz에서 20회 반복보다 더 좋다)</ul><li>stepping 후에는 body에 적용하고 있는 모든 forces를 제거해야한다.<ul><li>clearforces 함수를 통해 수행할 수 있다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">ClearForces</span><span class="p">();</span>
</pre></table></code></div></div><h4 id="5522-exploring-the-world">5.5.2.2. <strong>Exploring the World</strong><a href="#5522-exploring-the-world"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>body, contact, joint 리스트들을 가져와 탐색할 수 있다.<li>아래의 코드는 모든 body를 깨우는 코드이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">b2Body</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">GetBodyList</span><span class="p">();</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">GetNext</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">SetAwake</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>실제 코드에 적용하려면 좀 더 복잡해진다. 예를들어 아래는 오류가 발생할 수 있다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="n">b2Body</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">GetBodyList</span><span class="p">();</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">GetNext</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">GameActor</span><span class="o">*</span> <span class="n">myActor</span> <span class="o">=</span> <span class="p">(</span><span class="n">GameActor</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">().</span><span class="n">pointer</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myActor</span><span class="o">-&gt;</span><span class="n">IsDead</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">DestroyBody</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// ERROR: now GetNext returns garbage.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>만약 위처럼 조회하던 중에 body가 파괴되면(죽은 캐릭터를 파괴), next 포인터는 쓰레기값을 리턴한다.<li>이를 해결하기 위해서는 body를 파괴하기전에 next 포인터를 복사하는것이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">b2Body</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">GetBodyList</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b2Body</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetNext</span><span class="p">();</span>

    <span class="n">GameActor</span><span class="o">*</span> <span class="n">myActor</span> <span class="o">=</span> <span class="p">(</span><span class="n">GameActor</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">().</span><span class="n">pointer</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myActor</span><span class="o">-&gt;</span><span class="n">IsDead</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">DestroyBody</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>위 코드는 현재의 body를 안전하게 제거하지만, 만약 여러 body를 제거하려면 다음과 같이 코드를 짜야한다. (GameCrazyBodyDestroyer에서 body가 삭제되면, 다시 world 쿼리)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="n">b2Body</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">GetBodyList</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b2Body</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">GetNext</span><span class="p">();</span>

    <span class="n">GameActor</span><span class="o">*</span> <span class="n">myActor</span> <span class="o">=</span> <span class="p">(</span><span class="n">GameActor</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">GetUserData</span><span class="p">().</span><span class="n">pointer</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myActor</span><span class="o">-&gt;</span><span class="n">IsDead</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">otherBodiesDestroyed</span> <span class="o">=</span> <span class="n">GameCrazyBodyDestroyer</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">otherBodiesDestroyed</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">GetBodyList</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="5523-aabb-queries">5.5.2.3. <strong>AABB Queries</strong><a href="#5523-aabb-queries"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>경우에 따라 영역에 있는 모든 shape를 확인하고 싶을 때가 있다.<ul><li>b2World 클래스는 이를 위해 광범위한 데이터 구조를 사용해 log(N)방법을 사용한다.</ul><li>쿼리하기 위해서 world 좌표를 가진 AABB와 <a href="https://box2d.org/documentation/classb2_query_callback.html">b2QueryCallback</a>을 구현해야한다.<li>예를 들어 다음 코드는 지정된 AABB와 겹치는 모든 fixture 를 찾고 관련된 모든 body를 깨운다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyQueryCallback</span> <span class="o">:</span> <span class="k">public</span> <span class="n">b2QueryCallback</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">ReportFixture</span><span class="p">(</span><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixture</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">b2Body</span><span class="o">*</span> <span class="n">body</span> <span class="o">=</span> <span class="n">fixture</span><span class="o">-&gt;</span><span class="n">GetBody</span><span class="p">();</span>
        <span class="n">body</span><span class="o">-&gt;</span><span class="n">SetAwake</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

        <span class="c1">// Return true to continue the query.</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Elsewhere ...</span>
<span class="n">MyQueryCallback</span> <span class="n">callback</span><span class="p">;</span>
<span class="n">b2AABB</span> <span class="n">aabb</span><span class="p">;</span>

<span class="n">aabb</span><span class="p">.</span><span class="n">lowerBound</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">aabb</span><span class="p">.</span><span class="n">upperBound</span><span class="p">.</span><span class="n">Set</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">Query</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">aabb</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>You cannot make any assumptions about the order of the callbacks.</ul><h4 id="5524-ray-casts">5.5.2.4. <strong>?Ray Casts?</strong><a href="#5524-ray-casts"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>레이 캐스트를 통해 가시선 검사(line-of-sight check), 총 발사(fire gun) 등을 수행할 수 있다.<li>콜백 클래스를 구현하고, 시작점과 끝점을 제공하여 광선 투사를 수행해야한다.<li>world 클래스는 광선 투사를 수행한다.<li>world 클래스는 구현한 클래스에 광선에 맞은 fixture를 보고한다.<li>콜백은 fixture, 교차점, 단위 법선 벡터 및 광선에 따른 fractional distance를 함께 제공한다.<ul><li>콜백의 순서에 대해 어떠한 가정도 할 수 없다.</ul><li>반환된 fraction을 통해 레이 캐스트의 연속을 제어한다.<ul><li>fraction이 0일 경우, 레이 캐스트가 종료되어야함을 나타낸다.<li>1일 경우 적중이 발생하지 않아, 계속되어야함을 나타낸다.</ul><li>만일 인수목록에서 fraction을 반환하면, 광선이 현재 교차점으로 잘린다.<ul><li>따라서 모든 shape를 레이 캐스팅하거나, 어느 한 shape를 레이캐스팅하거나, 적절한 fraction을 반환하여 가장 가까운 shape를 레이캐스팅할 수있다.</ul><li>fixture를 필터링하기 위해 -1의 분수를 반환할 수 있다.<ul><li>이러면 fixture가 존재하지 않는 것처럼 레이 캐스트가 진행된다.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// This class captures the closest hit shape.</span>
<span class="k">class</span> <span class="nc">MyRayCastCallback</span> <span class="o">:</span> <span class="k">public</span> <span class="n">b2RayCastCallback</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyRayCastCallback</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m_fixture</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">ReportFixture</span><span class="p">(</span><span class="n">b2Fixture</span><span class="o">*</span> <span class="n">fixture</span><span class="p">,</span> <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">point</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">b2Vec2</span><span class="o">&amp;</span> <span class="n">normal</span><span class="p">,</span> <span class="kt">float</span> <span class="n">fraction</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">m_fixture</span> <span class="o">=</span> <span class="n">fixture</span><span class="p">;</span>
        <span class="n">m_point</span> <span class="o">=</span> <span class="n">point</span><span class="p">;</span>
        <span class="n">m_normal</span> <span class="o">=</span> <span class="n">normal</span><span class="p">;</span>
        <span class="n">m_fraction</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">fraction</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">b2Fixture</span><span class="o">*</span> <span class="n">m_fixture</span><span class="p">;</span>
    <span class="n">b2Vec2</span> <span class="n">m_point</span><span class="p">;</span>
    <span class="n">b2Vec2</span> <span class="n">m_normal</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">m_fraction</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Elsewhere ...</span>
<span class="n">MyRayCastCallback</span> <span class="n">callback</span><span class="p">;</span>
<span class="n">b2Vec2</span> <span class="nf">point1</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">b2Vec2</span> <span class="nf">point2</span><span class="p">(</span><span class="mf">3.0</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="n">myWorld</span><span class="o">-&gt;</span><span class="n">RayCast</span><span class="p">(</span><span class="o">&amp;</span><span class="n">callback</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">);</span>
</pre></table></code></div></div><blockquote><p>Caution: Due to round-off errors, ray casts can sneak through small cracks between polygons in your static environment. If this is not acceptable in your application, trying slightly overlapping your polygons.</p></blockquote><h1 id="6-loose-ends">6. <strong>Loose Ends</strong></h1><h2 id="61-user-data">6.1. <strong>User Data</strong><a href="#61-user-data"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="62-custom-user-data">6.2. <strong>Custom User Data</strong><a href="#62-custom-user-data"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="63-implicit-destruction">6.3. <strong>Implicit Destruction</strong><a href="#63-implicit-destruction"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="64-pixels-and-coordinate-systems">6.4. <strong>Pixels and Coordinate Systems</strong><a href="#64-pixels-and-coordinate-systems"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="65-debug-drawing">6.5. <strong>Debug Drawing</strong><a href="#65-debug-drawing"><i class="fas fa-hashtag"></i></a></h2></h2><h2 id="66-limitations">6.6. <strong>Limitations</strong><a href="#66-limitations"><i class="fas fa-hashtag"></i></a></h2></h2><h1 id="7-links">7. links</h1><p>https://box2d.org/documentation/</p><p>https://self-toeic.tistory.com/entry/Box2D-220-%ED%95%9C%EA%B8%80%ED%99%94-Chapter1-Introduction-Box2D-v220-User-Manual</p><p>https://analog-green.tistory.com/511</p><p>http://kimilb412-2.blogspot.com/2014/02/</p><p>https://www.youtube.com/watch?v=IcVtjuwxlj4</p><p>https://www.youtube.com/watch?v=kEClRFKyGkw&amp;t=730s</p><p>http://www.iforce2d.net/b2dtut/introduction</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/game/'>game</a>, <a href='/categories/game-box2d/'>game-box2d</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/box2d/" class="post-tag no-text-decoration" >box2d</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[box2d] box2d 문서 - RohRoh&url=https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[box2d] box2d 문서 - RohRoh&u=https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[box2d] box2d 문서 - RohRoh&url=https://nor-s.github.io/posts/2022/02/21/23/57/box2d1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2022/03/24/03/46/skeleton1/">[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 1</a><li><a href="/posts/2022/03/23/21/58/unreal-animation/">[UE4] 애니메이션 시작하기</a><li><a href="/posts/2022/03/22/04/45/bellman-ford/">[그래프] 벨만-포드 최단 경로 알고리즘</a><li><a href="/posts/2022/03/18/08/26/opengl22/">[learn-opengl] Advanced OpenGL: Framebuffers</a><li><a href="/posts/2022/03/18/09/28/opengl23/">[learn-opengl] Advanced OpenGL: Cubemaps</a></ul></div><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2022/02/16/20/34/unreal1/"><div class="card-body"> <em class="timeago small" date="2022-02-16 20:34:51 +0900" >Feb 16</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] 개발자를 위한 언리얼 엔진 시작하기_1</h3><div class="text-muted small"><p> 개발자를 위한 언리얼 엔진 시작하기 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서. 인트로 8개의 주제 엔진구조 렌더링 월드 빌딩 마테리얼 블루프린트 프로그래밍 캐릭터 애니메이션 월드 빌딩 철학 언리얼: 시각적...</p></div></div></a></div><div class="card"> <a href="/posts/2022/02/18/05/36/unreal2/"><div class="card-body"> <em class="timeago small" date="2022-02-18 05:36:17 +0900" >Feb 18</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] 언리얼 엔진에 오신 것을 환영합니다</h3><div class="text-muted small"><p> 언리얼 엔진에 오신 것을 환영합니다. 언리얼 공식 동영상 튜토리얼의 내용을 정리한 문서. 언리얼 엔진4와의 첫시간 머티리얼 메시의 외관에 영향을 주는것. 머티리얼은 라이팅에 반응항다. 뭔가를 보려면 라이트가 있어야한다. Directional Ligh...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/23/21/58/unreal-animation/"><div class="card-body"> <em class="timeago small" date="2022-03-23 21:58:52 +0900" >Mar 23</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[UE4] 애니메이션 시작하기</h3><div class="text-muted small"><p> 애니메이션 시작하기 철학 다용도성 확보(versatile tools) 레이어화된 애니메이션 플로우 다양한 애니메이션 레이어에서 벌어지는 일들을 쉽게 분리해서 레이어별로 반복 처리하고 폴리시할 수 있음. 재사용성 애니메이션 속의 다양한 요소를 다른 캐릭과 애니메이션 등을 공...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2022/02/21/00/23/pattern4/" class="btn btn-outline-primary" prompt="Older"><p>[게임 프로그래밍 패턴] Design Patterns Revisited: Observer</p></a> <a href="/posts/2022/02/21/23/58/ipc1/" class="btn btn-outline-primary" prompt="Newer"><p>[note] mediapipe와 ipc</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/Nor-s">roh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
