<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="[learn-opengl] Lighting: Basic Lighting" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Basic Lighting" /><meta property="og:description" content="Basic Lighting" /><link rel="canonical" href="https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/" /><meta property="og:url" content="https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/" /><meta property="og:site_name" content="RohRoh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-12T06:08:50+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[learn-opengl] Lighting: Basic Lighting" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"dateModified":"2022-03-12T15:14:12+09:00","datePublished":"2022-03-12T06:08:50+09:00","description":"Basic Lighting","mainEntityOfPage":{"@type":"WebPage","@id":"https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/"},"url":"https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/","@type":"BlogPosting","headline":"[learn-opengl] Lighting: Basic Lighting","@context":"https://schema.org"}</script><title>[learn-opengl] Lighting: Basic Lighting | RohRoh</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="RohRoh"><meta name="application-name" content="RohRoh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/commons/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">RohRoh</a></div><div class="site-subtitle font-italic">my blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Nor-s" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[learn-opengl] Lighting: Basic Lighting</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[learn-opengl] Lighting: Basic Lighting</h1><div class="post-meta text-muted"><div> <em> <a href="https://github.com/Nor-s">roh</a> </em></div><div class="d-flex"><div> <span> <em class="timeago" date="2022-03-12 06:08:50 +0900" data-toggle="tooltip" data-placement="bottom" title="Sat, Mar 12, 2022, 6:08 AM +0900" >Mar 12</em> </span> <span> Updated <em class="timeago" date="2022-03-12 15:14:12 +0900 " data-toggle="tooltip" data-placement="bottom" title="Sat, Mar 12, 2022, 3:14 PM +0900" >Mar 12</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3378 words"> <em>18 min</em> read</span></div></div></div><div class="post-content"><h1 id="basic-lighting"><strong>Basic Lighting</strong></h1><hr /><ul><li>실생활의 조명: 매우 복잡<li><p>OpenGL의 조명: 처리되기 쉽고, 실세계의 사물과 비슷하게 보이는 모델을 사용, 실세계에 대한 근사치 기반</p><ul><li>Phong Lighting model이 그 중 하나.<ul><li>Phong 모델은 3가지의 요소로 이루어짐<li><code class="language-plaintext highlighter-rouge">ambient lighting(주변광)</code>: 조명이 어딘가에 있으면, 오브젝트는 완전히 어두워지지 않음. 이를 시뮬레이션하기 위해 항상 객체에 약간의 색상을 주는 주변 조명 상수가 필요<li><code class="language-plaintext highlighter-rouge">diffuse lighting(분산광)</code>: 밝은 물체가 물체에 미치는 방향 충돌을 시뮬레이션한다. 조명 모델에서 가장 시각적으로 중요한 구성요소. 물체의 일부가 광원을 향할수록 밝아진다.<li><code class="language-plaintext highlighter-rouge">specular lighting(반사광)</code>: 반짝이는 물체에 나타나는 빛의 밝은 부분을 시뮬레이션한다. 반사 하이라이트=&gt; 객체의 색상보다 빛의 색상에 가깝 <img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_phong.png" alt="" /></ul></ul><li>Phong모델 이 3가지 요소들을 시뮬레이션해야함</ul><h2 id="ambient-lighting"><strong>Ambient lighting</strong><a href="#ambient-lighting"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>빛은 하나의 광원이 아니라, 많은 광원들로부터 온다.<ul><li>빛의 특성 중 하나: 어떠한 지점에 도달하기 위해 여러 방향으로 퍼지고 산란<li>빛 == 면에서 반사되어 어떠한 물체의 간접적인 영향을 준다.<ul><li>이를 고려한 알고리즘: <code class="language-plaintext highlighter-rouge">global ilumination</code>알고리즘<li>이 알고리즘은 비용이 비싸며 매우 복잡함.</ul></ul><li>global ilumination 알고리즘보다 간단한 모델을 사용할것임.<ul><li>이를 <code class="language-plaintext highlighter-rouge">ambient lighting</code>라고 부름</ul><li><code class="language-plaintext highlighter-rouge">ambient lighting</code> 추가<ul><li>빛의 컬러 정함<li>작은 상수 ambient 요소와 곱함.<li>이를 오브젝트의 컬러와 곱하여 fragment의 컬러로 사용</ul></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">ambientStrength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">ambientStrength</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>

    <span class="kt">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ambient</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
    <span class="n">FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>이제 프로그램을 실행시키면, 조명의 첫 번째 단계가 적용된것을 확인 가능<ul><li>이 오브젝트는 거의 안보이지만, 완전히 안보이지는 않다.(조명램프는 다른 shader 사용하기 때문에 영향없음)</ul></ul><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/ambient_lighting.png" alt="" /></p><h2 id="diffuse-lighting"><strong>Diffuse Lighting</strong><a href="#diffuse-lighting"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>분산광은 광원에서 오는 광선에 오브젝트의 fragment가 더 가깝게 위치할수록 오브젝트의 밝기가 높아진다.</ul><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/diffuse_light.png" alt="" /></p><ul><li>오브젝트 하나의 fragment에 광선과 fragment 사이의 각이 필요하다.<ul><li>광선이 오브젝트의 면에 수직으로 향한다면 빛은 아주 많이 영향을 끼칠것이다.<li>광선과 fragment 사이의 각을 측정하기 위해서는 법선 벡터(normal vector)라고 불리는 것을 사용한다.<ul><li><code class="language-plaintext highlighter-rouge">법선 벡터</code>: fragment 면에 대해 수직인 벡터이다.(위 이미지에서 노란 화살표)</ul></ul><li>사이각은 내적을 통해 얻을 수 있다.<ul><li>두 벡터 사이의 각이 <code class="language-plaintext highlighter-rouge">90</code>일 경우, 내적은 0이된다.<li>두 벡터 사이의 각 theta의 값이 크면, 빛의 영향을 더 적게 받게됨.<blockquote><p>두 벡터 사이의 코사인을 얻기 위해 정규화된 벡터를 사용해야한다.</p></blockquote></ul><li><p><strong>내적 결과값(스칼라)을 fragment의 색상에 미치는 빛의 영향을 게산하는데 사용할 수 있다.</strong></p><li>즉, diffuse lighting을 계산하기 위해 <code class="language-plaintext highlighter-rouge">Normal vector</code>, <code class="language-plaintext highlighter-rouge">The directed light ray</code> 가 필요하다.<ul><li>레이를 계산하기 위해 빛의 위치 벡터와 fragment의 위치 벡터가 필요하다.</ul></ul><h3 id="normal-vectors"><strong>Normal vectors</strong><a href="#normal-vectors"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>법선벡터<ul><li>vertex는 단지 점<li>vertex의 면을 알아내기 위해 주변의 vertex들을 사용하여 벡터를 구해야한다.<li>간단한 큐브이므로, 수작업으로 추가 가능하다.<ul><li>외적을 사용할 수 있다고한다.</ul><li><a href="https://learnopengl.com/code_viewer.php?code=lighting/basic_lighting_vertex_data">수정된 vertex data</a></ul><li>vertex 배열에 데이터를 추가했으므로 lighting vertex shader를 수정해야함.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#version 330 core
</span><span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">aPos</span><span class="p">;</span>
<span class="k">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">in</span> <span class="kt">vec3</span> <span class="n">aNormal</span><span class="p">;</span>
<span class="c1">//...</span>
</pre></table></code></div></div><ul><li><p>램프는 같은 vertex data를 사용하지만, 추가된 법선 벡터를 사용하지 않음.</p><ul><li>그냥 vertex atribute pointer에 vertex 배열 크기를 반영해야함.(3개의 데이터만 사용함, 그러므로 노멀벡터는 뛰어넘기위해 6을 stride에 곱해줌)<li>이런 vertex 데이터는 이미 GPU메모리 안에 저장되어 있기 때문에, GPU 메모리에 새로운 데이터를 저장할 필요가 없다. (새로운 VBO 할당보다 효율적)</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="n">GL_FALSE</span><span class="p">,</span> <span class="mi">6</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><li><p>모든 빛 계산은 fragment shader에서 완료되므로, 법선벡터를 전달해야함</p></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">Normal</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">Normal</span> <span class="o">=</span> <span class="n">aNormal</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>fragment shader에 <code class="language-plaintext highlighter-rouge">Normal</code>을 입력변수로 선언해야함.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">Normal</span><span class="p">;</span>
</pre></table></code></div></div><h3 id="caculating-the-diffuse-color"><strong>Caculating the diffuse color</strong><a href="#caculating-the-diffuse-color"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>fragment 위치 벡터와 광원의 위치벡터가 필요하다.</p><ul><li>광원의 위치 == 하나의 정적인 변수 =&gt; uniform으로 간단히 선언 가능.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">lightPos</span><span class="p">;</span>
</pre></table></code></div></div><li><p>게임 루프 안에서 <code class="language-plaintext highlighter-rouge">uniform</code>을 업데이트(또는 밖에서 광원위치 고정)</p></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">"lightPos"</span><span class="p">,</span> <span class="n">lightPos</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>그 다음은 fragment의 위치를 얻어야한다.<ul><li>모든 빛에 대한 계산을 world space에서 할것이므로 world space에서의 vertex 위치가 필요하다.<li>vertex 위치는 model 행렬과 곱하여 world space 좌표로 변환하는 것으로 얻을 수 있음<li>이는 vertex shader에서 쉽게 수행가능, 출력 변수를 선언하고, world space 좌표를 계산해야한다.</ul></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
<span class="k">out</span> <span class="kt">vec3</span> <span class="n">Normal</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">*</span> <span class="n">view</span> <span class="o">*</span> <span class="n">model</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">FragPos</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">model</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">Normal</span> <span class="o">=</span> <span class="n">aNormal</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>그리고 마지막으로 해당 값을 입력변수로 fragment shader에 추가해야한다.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="k">in</span> <span class="kt">vec3</span> <span class="n">FragPos</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><p>이제 fragment shader에서 빛에 대한 계산을 시작해야한다.</p><ul><li>먼저 광원과 fragment의 위치 사이의 방향 벡터가 필요<ul><li>벡터 뺄셈으로 계산</ul><li>그리고 모든 벡터들이 단위 벡터로 정규화해야한다.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>
<span class="kt">vec3</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
</pre></table></code></div></div><li>빛계산은 일반적으로 벡터의 크기에 대해 생각하지 않음.<ul><li>방향만 생각(단위 벡터)<li>계산 간단해짐</ul><li><code class="language-plaintext highlighter-rouge">norm</code>, <code class="language-plaintext highlighter-rouge">lightDir</code> 를 내적 =&gt; diffuse 효과를 계산<ul><li><code class="language-plaintext highlighter-rouge">diffuse</code> : 내적의 결과값과 lightColor<li>사이각이 클수록 diffuse 요소는 어두워짐<div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</pre></table></code></div></div></ul><li><p>음의 값을 가진 컬러가 되는것을 방지하기 위해 max 함수를 사용한다.</p><li>이제 ambient와 diffuse 두 색상을 모두 더한 다음 결과에 객체의 색상을 곱해 결과로 생성된 fragment의 출력색상을 얻는다.</ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>
<span class="kt">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span><span class="p">)</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
<span class="n">FragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>결과는 다음과 같다.</ul><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_diffuse.png" alt="" /></p><ul><li>사이 각이 클수록 fragment는 어두워진다.</ul><p><a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.1.basic_lighting_diffuse/basic_lighting_diffuse.cpp">전체 코드</a></p><h3 id="one-last-thing"><strong>One last thing</strong><a href="#one-last-thing"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><p>법선 벡터를 그대로 shader에 보내기만 했음.</p><ul><li>fragment shader에서 수행한 계산들 모두 world space에서 수행되므로 법선 또한 world space에서 수행되어어야 하는게 맞음<li>하지만, model 행렬과 곱하는 것만큼 간단하지 않다.</ul><li><p>간단하지 않은 이유</p></ul><ol><li>법선 벡터는 그냥 방향벡터이다.<ul><li>특정한 위치를 나타내지 않음.<li>또한 동차좌표(위치 벡터의 <code class="language-plaintext highlighter-rouge">w</code>요소)를 가지고 있지 않는다. =&gt; 변환행렬과 곱하기 힘듬.<li>model 행렬을 곱하려면 일부분 제거해 좌측상단의 <code class="language-plaintext highlighter-rouge">3x3</code>행렬을 취해야함<li>즉 변환행렬에서 유효한것은 회전 및 스케일 변환이다.</ul><li>model 행렬이 불균일 스케일을 수행하면, vertex들이 수정되어 법선 벡터가 더이상 해당 면과 수직이 되지 않는다. - 그러므로 이 model행렬로 법선 벡터를 변환하지 못함. (균일 스케일은 단지 크기만 변하기 때문에 법선에 영향안준다) <img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_normal_transformation.png" alt="" /></ol><ul><li><p>불균일 스케일을 적용 =&gt; 수직이 틀어짐 =&gt; 빛을 왜곡하게됨</p><li>해결방법은 법선 벡터에 맞춰서 만들어진 다른 model 행렬을 사용하는것.<ul><li>이 행렬은 <code class="language-plaintext highlighter-rouge">법선 행렬</code>이라고 부른다.<li><a href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/the-normal-matrix/">The Normal Matrix</a></ul><li><p>법선 행렬: model 행렬의 좌측 상단 모서리의 역행렬에 대한 전치행렬</p><ul><li>대부분 자료들은 법선 행렬을 model-view 행렬에서 파생된것으로 사용하지만, 지금은 world space에서만 작업하기 때문에 model 행렬에서 파생시킨것을 사용해야한다.</ul><li>vertex shader에서 <code class="language-plaintext highlighter-rouge">inverse</code>, <code class="language-plaintext highlighter-rouge">transpose</code>함수를 사용하여 법선 행렬을 만들 수 있다.<ul><li>법선벡터와 곱하기위해 3x3행렬로 변환하므로 translation 속성을 잃는것을 주의하자.</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="n">Normal</span> <span class="o">=</span> <span class="n">mat3</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">inverse</span><span class="p">(</span><span class="n">model</span><span class="p">)))</span> <span class="o">*</span> <span class="n">aNormal</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><p>스케일 연산을 수행하지 않으므로, 실제로는 법선 행렬을 사용할 필요가 없고, 법선을 모델행렬과 곱하기만하면됨.</p><li>역행렬 변환 == 비용이 비쌈.<ul><li>scene의 각각의 vertex에 대해 수행해야하므로 이 연산은 피하는게 좋음</ul><li>보통 CPU에서 법선 행렬을 계산하고 uniform을 통해 shader에 전달함.</ul><h2 id="specular-lighting"><strong>Specular Lighting</strong><a href="#specular-lighting"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><p>반사광은 분산광처럼 조명의 방향 벡터 및 대상의 법선 벡터를 기반으로함.</p><ul><li>하지만, 추가적으로 플레이어가 fragment를 보고 있는 방향에 대한 view 방향도 관여한다.</ul><li><p>반사광은 빛의 반사 특성 기반임.</p><ul><li>만약, 거울면에서 반사되어진 빛 즉, 반사광은 가장 밝은 빛일것이다.(아래 그림 참고)</ul></ul><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_specular_theory.png" alt="" /></p><ul><li><p>먼저, 반사 벡터를 계산해야함.</p><ul><li>그리고 반사벡터와 view 방향 사이의 각도를 계산해야함<li>각이 가까움: 반사광의 강도는 강해짐</ul><li><p>그다음에, View 벡터 계산해야함.</p><ul><li>viewer의 world sapce 위치와 fragment들의 위치를 사용하여 이 변수를 계산할 수 있다.</ul><li><p>마지막으로, specular 세기를 계산하고, 빛의 색과 곱하고, 이를 ambient, diffuse 에 추가한다.</p></ul><blockquote><p>이때까지 world space에서 lighthing 계산을 했음. 하지만 대부분 view space 에서 lighting 을 수행함. view space에서 계산을 하면, viewer 위치가 항상 (0, 0, 0)이므로, 항상 뷰어의 위치를 쉽게 알 수 있음. 여기서는 학습목적으로 worldspace에서 계산할것임. view space에서 계산하려면 관련된 모든 벡터를 view 행렬을 사용하여 변환해야함.(법선 행렬 포함)</p></blockquote><ul><li>viewer의 world space 좌표를 얻기 위해 카메라 객체의 위치 벡터를 사용함.<ul><li>uniform 으로 추가하여 fragment shader에 전달</ul></ul><div class="language-glsl highlighter-rouge"><div class="code-header"> <span label-text="Glsl"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="k">uniform</span> <span class="kt">vec3</span> <span class="n">viewPos</span><span class="p">;</span>
</pre></table></code></div></div><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="n">lightingShader</span><span class="p">.</span><span class="n">setVec3</span><span class="p">(</span><span class="s">"viewPos"</span><span class="p">,</span> <span class="n">camera</span><span class="p">.</span><span class="n">Position</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>이제 specular를 계산할 수 있다.<ul><li>먼저 specular 강조 값을 중간으로 정의하여, 하이라이트를 적절히 조절한다.(<code class="language-plaintext highlighter-rouge">1.0f</code>이면 아주 밝음)</ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>
<span class="kt">float</span> <span class="n">specularStrength</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>그 다음, view 방향 벡터와 해당 반사 벡터를 계산한다.<ul><li><code class="language-plaintext highlighter-rouge">lightDir</code> 벡터의 부호가 -로 바뀐것 주의<li><code class="language-plaintext highlighter-rouge">reflect</code> 함수<ul><li>파라미터1: 광원으로부터 fragment 위치로 향하는 벡터<ul><li>lightDir는 그 반대 방향의 벡터이다. (lightDir 벡터 계산할 때 뺠셈 순서 때문)</ul><li>파라미터2: 정규화된 법선벡터</ul></ul></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>
<span class="n">vec3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">viewPos</span> <span class="o">-</span> <span class="n">FragPos</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightDir</span><span class="p">,</span> <span class="n">norm</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>그런 다음, 공식을 사용하여 specular 컴포넌트를 계산해야한다.<ol><li>내적: view 방향과 reflect 방향<li>음수 방지<li>32제곱: <code class="language-plaintext highlighter-rouge">32</code>값은 하이라이트의 shininess 값(낮을수록 빛을 퍼지게, 높을수록 빛을 퍼지게하지않고, 적절히 반사, 하이라이트가 작아짐, 아래 이미지 참고)</ol></ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>
<span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="mi">32</span><span class="p">);</span>
<span class="n">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">specularStrength</span> <span class="o">*</span> <span class="n">spec</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_specular_shininess.png" alt="" /></p><ul><li>마지막으로, ambient와 diffuse 와 함께 계산하는것이다.</ul><div class="language-cpp highlighter-rouge"><div class="code-header"> <span label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>
<span class="n">vec3</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">)</span> <span class="o">*</span> <span class="n">objectColor</span><span class="p">;</span>
<span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>이제 이 <a href="https://learnopengl.com/code_viewer_gh.php?code=src/2.lighting/2.2.basic_lighting_specular/basic_lighting_specular.cpp">코드</a>를 실행하면 아래와 같이 보일것이다.</ul><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_specular.png" alt="" /></p><blockquote><p>초기의 lighting shader들은 vertex shader에서 Phong 모델을 구현했다. 이를 vertex shader에서 구현하는 것은 vertex의 수가 fragment 보다 적기 때문에 계산량이 적어 효율적이었음. 하지만 vertex shader의 최종 컬러 값은 오직 vertex만의 lighting 컬러이므로, fragment에서는 보간된 컬러가 보여진다.</p></blockquote><blockquote><p><img data-proofer-ignore data-src="https://learnopengl.com/img/lighting/basic_lighting_gouruad.png" alt="" /></p></blockquote><blockquote><p>이와 같이 vertex에 구현된 모델을 Gouraud shading이라고 부름.</p></blockquote><ul><li>셰이더는 이처럼 강력하다.<ul><li>약간의 정보와 함께 shader는 모든 오브젝트에 대해 영향을 끼친다.</ul></ul><h2 id="출처"><strong>출처</strong><a href="#출처"><i class="fas fa-hashtag"></i></a></h2></h2><p><a href="https://learnopengl.com/Lighting/Basic-Lighting">learnopengl-basic lighting</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/graphics/'>graphics</a>, <a href='/categories/graphics-opengl/'>graphics-opengl</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/opengl/" class="post-tag no-text-decoration" >opengl</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[learn-opengl] Lighting: Basic Lighting - RohRoh&url=https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[learn-opengl] Lighting: Basic Lighting - RohRoh&u=https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[learn-opengl] Lighting: Basic Lighting - RohRoh&url=https://nor-s.github.io/posts/2022/03/12/06/08/opengl10/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2022/03/24/03/46/skeleton1/">[opengl] OGLDEV: Skeleton Animation In OpenGL using Assimp 1</a><li><a href="/posts/2022/03/23/21/58/unreal-animation/">[UE4] 애니메이션 시작하기</a><li><a href="/posts/2022/03/22/04/45/bellman-ford/">[그래프] 벨만-포드 최단 경로 알고리즘</a><li><a href="/posts/2022/03/18/08/26/opengl22/">[learn-opengl] Advanced OpenGL: Framebuffers</a><li><a href="/posts/2022/03/18/09/28/opengl23/">[learn-opengl] Advanced OpenGL: Cubemaps</a></ul></div><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2022/03/18/08/26/opengl22/"><div class="card-body"> <em class="timeago small" date="2022-03-18 08:26:47 +0900" >Mar 18</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Framebuffers</h3><div class="text-muted small"><p> Framebuffers 지금까지 여러 스크린 버퍼들을 사용해왔다. color buffer: 컬러 값 작성 depth buffer: 깊이 정보 작성 stencil buffer: 특정 조건에 의해 해당 fragment를 폐기함. 이러한 버퍼들을 결합한 것을 Framebuffer라고...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/18/09/28/opengl23/"><div class="card-body"> <em class="timeago small" date="2022-03-18 09:28:02 +0900" >Mar 18</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Cubemaps</h3><div class="text-muted small"><p> Cubemaps 지금까지 2D 텍스처들을 사용해왔다. 다른 유형도 존재 이번에 다룰 유형은 여러 텍스처들을 하나의 텍스처로 매핑한 텍스처이다. 이를 cubemaps라고 부른다. Cubemap은 각 면을 형성하는 2D 텍스처들을 포함하고 있는 텍스처이다...</p></div></div></a></div><div class="card"> <a href="/posts/2022/03/20/01/05/opengl24/"><div class="card-body"> <em class="timeago small" date="2022-03-20 01:05:12 +0900" >Mar 20</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[learn-opengl] Advanced OpenGL: Advanced Data</h3><div class="text-muted small"><p> Advanced Data 버퍼들을 좀 더 흥미로운 방법과 texture들을 통해 shader에 많은 양의 data를 전달하는 흥미로운 방법이 존재한다. 이런 버퍼함수들과, 많은 양의 데이터를 저장하기 위해 텍스처 객체를 사용하는 방법을 다룰 것이다. OpenGL에서의 buffer는 특정 메모리를 관리...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2022/03/12/00/19/11066/" class="btn btn-outline-primary" prompt="Older"><p>[백준][C++] 11066: 파일 합치기 (dp)</p></a> <a href="/posts/2022/03/12/21/27/opengl11/" class="btn btn-outline-primary" prompt="Newer"><p>[learn-opengl] Lighting: Materials</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/Nor-s">roh</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/opengl/">opengl</a> <a class="post-tag" href="/tags/ps/">ps</a> <a class="post-tag" href="/tags/unreal4/">unreal4</a> <a class="post-tag" href="/tags/regex/">regex</a> <a class="post-tag" href="/tags/vscode/">vscode</a> <a class="post-tag" href="/tags/algorithm/">algorithm</a> <a class="post-tag" href="/tags/box2d/">box2d</a> <a class="post-tag" href="/tags/csapp/">csapp</a> <a class="post-tag" href="/tags/note/">note</a> <a class="post-tag" href="/tags/shader/">shader</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
